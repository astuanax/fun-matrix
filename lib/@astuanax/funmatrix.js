(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("@astuanax/funmatrix", [], factory);
	else if(typeof exports === 'object')
		exports["@astuanax/funmatrix"] = factory();
	else
		root["@astuanax/funmatrix"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/matrix.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/*! exports provided: version, parse, parseExpressionAt, tokenizer, Parser, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, tokTypes, keywordTypes, TokContext, tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true};
var startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 9.
  ecmaVersion: 9,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0;
  // Labels in scope.
  this.labels = [];

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
pp.strictDirective = function(start) {
  var this$1 = this;

  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    if (this$1.input[start] === ';')
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this$1.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"};
var switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var this$1 = this;

  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this$1.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
        !(kind !== "var" && init$1.declarations[0].init)) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this$1.type === types._case || this$1.type === types._default) {
      var isCase = this$1.type === types._case;
      if (cur) { this$1.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();
      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this$1.expect(types.colon);
    } else {
      if (!cur) { this$1.unexpected(); }
      cur.consequent.push(this$1.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this$1.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this$1.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node) {
  var this$1 = this;
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this$1.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  if (type === "ForInStatement") {
    if (init.type === "AssignmentPattern" ||
      (init.type === "VariableDeclaration" && init.declarations[0].init != null &&
       (this.strict || init.declarations[0].id.type !== "Identifier")))
      { this.raise(init.start, "Invalid assignment in for-in loop head"); }
  }
  node.left = init;
  node.right = type === "ForInStatement" ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, type)
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl, kind);
    if (this$1.eat(types.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
      this$1.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
    if (!this$1.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  if ((kind === "const" || kind === "let") && this.isContextual("let")) {
    this.raiseRecoverable(this.start, "let is disallowed as a lexically bound name");
  }
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  var this$1 = this;

  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this$1.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this$1.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement === true)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  var this$1 = this;

  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync, true);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      // check for keywords used as local names
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];

        this$1.checkUnreserved(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this$1.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this$1.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  var this$1 = this;

  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var this$1 = this;

  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var this$1 = this;

  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);
    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent();
    } else {
      this$1.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this$1.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Can not use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this$1.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this$1.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this$1.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this$1.expect(types.comma); }
    if (allowEmpty && this$1.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === types.ellipsis) {
      var rest = this$1.parseRestBinding();
      this$1.parseBindingListItem(rest);
      elts.push(rest);
      if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
      this$1.expect(close);
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  var this$1 = this;
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this$1.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  for (var computed = (void 0);;) {
    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;
      if (computed) { this$1.expect(types.bracketR); }
      base = this$1.finishNode(node, "MemberExpression");
    } else if (!noCalls && this$1.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, "CallExpression");
    } else if (this$1.type === types.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate({isTagged: true});
      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
    } else {
      return base
    }
  }
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(this.type !== types.name);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent();
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected();
  }
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types.parenR) {
      first ? first = false : this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this$1.type === types.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
        if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  var this$1 = this;
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this$1.type === types.eof) { this$1.raise(this$1.pos, "Unterminated template literal"); }
    this$1.expect(types.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(types.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    this.checkUnreserved(prop.key);
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this$1.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this$1.type === types.comma)
      { elt = null; }
    else if (this$1.type === types.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this$1.start; }
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Can not use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved === "never") { liberal = false; }
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) { this.checkUnreserved(node); }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP);
};

pp$5.declareName = function(name, bindingType, pos) {
  var this$1 = this;

  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this$1.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name ||
          !this$1.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  var this$1 = this;

  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this$1.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  var this$1 = this;

  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this$1.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this$1.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

var data = {
  "$LONE": [
    "ASCII",
    "ASCII_Hex_Digit",
    "AHex",
    "Alphabetic",
    "Alpha",
    "Any",
    "Assigned",
    "Bidi_Control",
    "Bidi_C",
    "Bidi_Mirrored",
    "Bidi_M",
    "Case_Ignorable",
    "CI",
    "Cased",
    "Changes_When_Casefolded",
    "CWCF",
    "Changes_When_Casemapped",
    "CWCM",
    "Changes_When_Lowercased",
    "CWL",
    "Changes_When_NFKC_Casefolded",
    "CWKCF",
    "Changes_When_Titlecased",
    "CWT",
    "Changes_When_Uppercased",
    "CWU",
    "Dash",
    "Default_Ignorable_Code_Point",
    "DI",
    "Deprecated",
    "Dep",
    "Diacritic",
    "Dia",
    "Emoji",
    "Emoji_Component",
    "Emoji_Modifier",
    "Emoji_Modifier_Base",
    "Emoji_Presentation",
    "Extender",
    "Ext",
    "Grapheme_Base",
    "Gr_Base",
    "Grapheme_Extend",
    "Gr_Ext",
    "Hex_Digit",
    "Hex",
    "IDS_Binary_Operator",
    "IDSB",
    "IDS_Trinary_Operator",
    "IDST",
    "ID_Continue",
    "IDC",
    "ID_Start",
    "IDS",
    "Ideographic",
    "Ideo",
    "Join_Control",
    "Join_C",
    "Logical_Order_Exception",
    "LOE",
    "Lowercase",
    "Lower",
    "Math",
    "Noncharacter_Code_Point",
    "NChar",
    "Pattern_Syntax",
    "Pat_Syn",
    "Pattern_White_Space",
    "Pat_WS",
    "Quotation_Mark",
    "QMark",
    "Radical",
    "Regional_Indicator",
    "RI",
    "Sentence_Terminal",
    "STerm",
    "Soft_Dotted",
    "SD",
    "Terminal_Punctuation",
    "Term",
    "Unified_Ideograph",
    "UIdeo",
    "Uppercase",
    "Upper",
    "Variation_Selector",
    "VS",
    "White_Space",
    "space",
    "XID_Continue",
    "XIDC",
    "XID_Start",
    "XIDS"
  ],
  "General_Category": [
    "Cased_Letter",
    "LC",
    "Close_Punctuation",
    "Pe",
    "Connector_Punctuation",
    "Pc",
    "Control",
    "Cc",
    "cntrl",
    "Currency_Symbol",
    "Sc",
    "Dash_Punctuation",
    "Pd",
    "Decimal_Number",
    "Nd",
    "digit",
    "Enclosing_Mark",
    "Me",
    "Final_Punctuation",
    "Pf",
    "Format",
    "Cf",
    "Initial_Punctuation",
    "Pi",
    "Letter",
    "L",
    "Letter_Number",
    "Nl",
    "Line_Separator",
    "Zl",
    "Lowercase_Letter",
    "Ll",
    "Mark",
    "M",
    "Combining_Mark",
    "Math_Symbol",
    "Sm",
    "Modifier_Letter",
    "Lm",
    "Modifier_Symbol",
    "Sk",
    "Nonspacing_Mark",
    "Mn",
    "Number",
    "N",
    "Open_Punctuation",
    "Ps",
    "Other",
    "C",
    "Other_Letter",
    "Lo",
    "Other_Number",
    "No",
    "Other_Punctuation",
    "Po",
    "Other_Symbol",
    "So",
    "Paragraph_Separator",
    "Zp",
    "Private_Use",
    "Co",
    "Punctuation",
    "P",
    "punct",
    "Separator",
    "Z",
    "Space_Separator",
    "Zs",
    "Spacing_Mark",
    "Mc",
    "Surrogate",
    "Cs",
    "Symbol",
    "S",
    "Titlecase_Letter",
    "Lt",
    "Unassigned",
    "Cn",
    "Uppercase_Letter",
    "Lu"
  ],
  "Script": [
    "Adlam",
    "Adlm",
    "Ahom",
    "Anatolian_Hieroglyphs",
    "Hluw",
    "Arabic",
    "Arab",
    "Armenian",
    "Armn",
    "Avestan",
    "Avst",
    "Balinese",
    "Bali",
    "Bamum",
    "Bamu",
    "Bassa_Vah",
    "Bass",
    "Batak",
    "Batk",
    "Bengali",
    "Beng",
    "Bhaiksuki",
    "Bhks",
    "Bopomofo",
    "Bopo",
    "Brahmi",
    "Brah",
    "Braille",
    "Brai",
    "Buginese",
    "Bugi",
    "Buhid",
    "Buhd",
    "Canadian_Aboriginal",
    "Cans",
    "Carian",
    "Cari",
    "Caucasian_Albanian",
    "Aghb",
    "Chakma",
    "Cakm",
    "Cham",
    "Cherokee",
    "Cher",
    "Common",
    "Zyyy",
    "Coptic",
    "Copt",
    "Qaac",
    "Cuneiform",
    "Xsux",
    "Cypriot",
    "Cprt",
    "Cyrillic",
    "Cyrl",
    "Deseret",
    "Dsrt",
    "Devanagari",
    "Deva",
    "Duployan",
    "Dupl",
    "Egyptian_Hieroglyphs",
    "Egyp",
    "Elbasan",
    "Elba",
    "Ethiopic",
    "Ethi",
    "Georgian",
    "Geor",
    "Glagolitic",
    "Glag",
    "Gothic",
    "Goth",
    "Grantha",
    "Gran",
    "Greek",
    "Grek",
    "Gujarati",
    "Gujr",
    "Gurmukhi",
    "Guru",
    "Han",
    "Hani",
    "Hangul",
    "Hang",
    "Hanunoo",
    "Hano",
    "Hatran",
    "Hatr",
    "Hebrew",
    "Hebr",
    "Hiragana",
    "Hira",
    "Imperial_Aramaic",
    "Armi",
    "Inherited",
    "Zinh",
    "Qaai",
    "Inscriptional_Pahlavi",
    "Phli",
    "Inscriptional_Parthian",
    "Prti",
    "Javanese",
    "Java",
    "Kaithi",
    "Kthi",
    "Kannada",
    "Knda",
    "Katakana",
    "Kana",
    "Kayah_Li",
    "Kali",
    "Kharoshthi",
    "Khar",
    "Khmer",
    "Khmr",
    "Khojki",
    "Khoj",
    "Khudawadi",
    "Sind",
    "Lao",
    "Laoo",
    "Latin",
    "Latn",
    "Lepcha",
    "Lepc",
    "Limbu",
    "Limb",
    "Linear_A",
    "Lina",
    "Linear_B",
    "Linb",
    "Lisu",
    "Lycian",
    "Lyci",
    "Lydian",
    "Lydi",
    "Mahajani",
    "Mahj",
    "Malayalam",
    "Mlym",
    "Mandaic",
    "Mand",
    "Manichaean",
    "Mani",
    "Marchen",
    "Marc",
    "Masaram_Gondi",
    "Gonm",
    "Meetei_Mayek",
    "Mtei",
    "Mende_Kikakui",
    "Mend",
    "Meroitic_Cursive",
    "Merc",
    "Meroitic_Hieroglyphs",
    "Mero",
    "Miao",
    "Plrd",
    "Modi",
    "Mongolian",
    "Mong",
    "Mro",
    "Mroo",
    "Multani",
    "Mult",
    "Myanmar",
    "Mymr",
    "Nabataean",
    "Nbat",
    "New_Tai_Lue",
    "Talu",
    "Newa",
    "Nko",
    "Nkoo",
    "Nushu",
    "Nshu",
    "Ogham",
    "Ogam",
    "Ol_Chiki",
    "Olck",
    "Old_Hungarian",
    "Hung",
    "Old_Italic",
    "Ital",
    "Old_North_Arabian",
    "Narb",
    "Old_Permic",
    "Perm",
    "Old_Persian",
    "Xpeo",
    "Old_South_Arabian",
    "Sarb",
    "Old_Turkic",
    "Orkh",
    "Oriya",
    "Orya",
    "Osage",
    "Osge",
    "Osmanya",
    "Osma",
    "Pahawh_Hmong",
    "Hmng",
    "Palmyrene",
    "Palm",
    "Pau_Cin_Hau",
    "Pauc",
    "Phags_Pa",
    "Phag",
    "Phoenician",
    "Phnx",
    "Psalter_Pahlavi",
    "Phlp",
    "Rejang",
    "Rjng",
    "Runic",
    "Runr",
    "Samaritan",
    "Samr",
    "Saurashtra",
    "Saur",
    "Sharada",
    "Shrd",
    "Shavian",
    "Shaw",
    "Siddham",
    "Sidd",
    "SignWriting",
    "Sgnw",
    "Sinhala",
    "Sinh",
    "Sora_Sompeng",
    "Sora",
    "Soyombo",
    "Soyo",
    "Sundanese",
    "Sund",
    "Syloti_Nagri",
    "Sylo",
    "Syriac",
    "Syrc",
    "Tagalog",
    "Tglg",
    "Tagbanwa",
    "Tagb",
    "Tai_Le",
    "Tale",
    "Tai_Tham",
    "Lana",
    "Tai_Viet",
    "Tavt",
    "Takri",
    "Takr",
    "Tamil",
    "Taml",
    "Tangut",
    "Tang",
    "Telugu",
    "Telu",
    "Thaana",
    "Thaa",
    "Thai",
    "Tibetan",
    "Tibt",
    "Tifinagh",
    "Tfng",
    "Tirhuta",
    "Tirh",
    "Ugaritic",
    "Ugar",
    "Vai",
    "Vaii",
    "Warang_Citi",
    "Wara",
    "Yi",
    "Yiii",
    "Zanabazar_Square",
    "Zanb"
  ]
};
Array.prototype.push.apply(data.$LONE, data.General_Category);
data.gc = data.General_Category;
data.sc = data.Script_Extensions = data.scx = data.Script;

var pp$9 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString$1(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpFlags = function(state) {
  var this$1 = this;

  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this$1.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this$1.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$9.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$9.regexp_disjunction = function(state) {
  var this$1 = this;

  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this$1.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$9.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    {  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$9.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$9.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$9.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$9.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$9.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$9.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$9.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$9.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$9.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$9.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$9.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$9.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$9.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString$1(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString$1(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$9.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$9.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$9.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$9.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$9.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$9.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$9.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$9.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$9.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$9.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$9.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {
    state.raise("Invalid property name");
  }
};
pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (data.$LONE.indexOf(nameOrValue) === -1) {
    state.raise("Invalid property name");
  }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$9.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$9.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$9.regexp_classRanges = function(state) {
  var this$1 = this;

  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$9.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$9.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$9.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$9.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$9.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$9.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$8 = Parser.prototype;

// Move to the next token

pp$8.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$8[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$8.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$8.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$8.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$8.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$8.skipBlockComment = function() {
  var this$1 = this;

  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$8.skipLineComment = function(startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this$1.input.charCodeAt(++this$1.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$8.skipSpace = function() {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this$1.pos;
      break
    case 13:
      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
        ++this$1.pos;
      }
    case 10: case 8232: case 8233:
      ++this$1.pos;
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      break
    case 47: // '/'
      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
      case 42: // '*'
        this$1.skipBlockComment();
        break
      case 47:
        this$1.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this$1.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$8.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$8.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$8.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$8.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$8.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$8.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$8.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$8.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$8.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$8.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$8.readRegexp = function() {
  var this$1 = this;

  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(start, "Unterminated regular expression"); }
    var ch = this$1.input.charAt(this$1.pos);
    if (lineBreak.test(ch)) { this$1.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this$1.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$8.readInt = function(radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this$1.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$8.readRadixNumber = function(radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$8.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$8.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$8.readString = function(quote) {
  var this$1 = this;

  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated string constant"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, "Unterminated string constant"); }
      ++this$1.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$8.readTmplToken = function() {
  var this$1 = this;

  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated template"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(types.dollarBraceL)
        } else {
          ++this$1.pos;
          return this$1.finishToken(types.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;
      switch (ch) {
      case 13:
        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$8.readInvalidTemplateToken = function() {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
    switch (this$1.input[this$1.pos]) {
    case "\\":
      ++this$1.pos;
      break

    case "$":
      if (this$1.input[this$1.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$8.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$8.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$8.readWord1 = function() {
  var this$1 = this;

  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this$1.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;
      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // "u"
        { this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this$1.pos;
      var esc = this$1.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this$1.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$8.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// [walk]: util/walk.js

var version = "6.0.6";

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}


//# sourceMappingURL=acorn.mjs.map


/***/ }),

/***/ "./node_modules/fun.js/src/_private/curry1.js":
/*!****************************************************!*\
  !*** ./node_modules/fun.js/src/_private/curry1.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return curry1; });
/**
 * Returns a curried function with arity 1
 * @function curry1
 * @private
 * @since v1.0.2
 **/

function curry1 (fn) {
  return function curried (a) {
    return arguments.length === 0
      ? this
      : fn(a)
  }
}


/***/ }),

/***/ "./node_modules/fun.js/src/and.js":
/*!****************************************!*\
  !*** ./node_modules/fun.js/src/and.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/**
 * Checks if both predicates are true
 *
 * @function and
 * @description Checks if both predicates are true
 * @since v1.0.2
 * @sig (x, y) -> boolean
 * @param {*} x - A predicate
 * @param {*} y - A predicate
 * @return {boolean}
 **/


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function and (x, y) {
  return x && y
}));


/***/ }),

/***/ "./node_modules/fun.js/src/array/concat.js":
/*!*************************************************!*\
  !*** ./node_modules/fun.js/src/array/concat.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/**
 * @private
 * @function arrayConcat
 * @param a1
 * @param a2
 * @returns {T[]}
 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function concat (a, b) {
  return Array.prototype.concat(a, b)
}));


/***/ }),

/***/ "./node_modules/fun.js/src/array/equals.js":
/*!*************************************************!*\
  !*** ./node_modules/fun.js/src/array/equals.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../not */ "./node_modules/fun.js/src/not.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../equals */ "./node_modules/fun.js/src/equals.js");
/**
 * @private
 * @function equalsArray
 * @description Autocurried function for deep comparison of arrays
 * @param {a} x - Object to compare of type a
 * @param {a} y - Object x to compare with object x
 * @return {boolean}
 */




/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function equalsArray (x, y) {
  if (x.length !== y.length) {
    return false
  }
  for (let i = 0; i < x.length; i++) {
    if (Object(_not__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_equals__WEBPACK_IMPORTED_MODULE_2__["default"])(x[i], y[i]))) return false
  }
  return true
}));


/***/ }),

/***/ "./node_modules/fun.js/src/array/fold.js":
/*!***********************************************!*\
  !*** ./node_modules/fun.js/src/array/fold.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/**
 * @private
 * @function fold
 * @description Returns a single item by mapping over the provided array and calling an iterator function
 * @param {cbFunction} cb - Callback function to modify the item
 * @param {*} init - Initial value
 * @param {Array} a - Array with items to modify by the cb function
 * @return {Array}
 * @alias reduce
 * @since 1.0.2
 * @example
 *
 * const result = fold(add, 0, [1,1,1])
 * // result = 3
 */

/**
 * @callback cbFunction
 * @param {*} r - Accumulator which accumulates the callback's return values
 * @param {*} item - the current element being processed
 * @param {number} index - the indey of the item being processed
 * @param {Array} a - The initial array
 * @return {*}
 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function fold (cb, init, a) {
  let i = -1
  const l = a.length
  let r = init
  while (++i < l) {
    r = cb(r, a[i], i, a)
  }
  return r
}));


/***/ }),

/***/ "./node_modules/fun.js/src/array/is.js":
/*!*********************************************!*\
  !*** ./node_modules/fun.js/src/array/is.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is */ "./node_modules/fun.js/src/is.js");
/**
 * Checks if the provided object is an array, autocurried function
 *
 * @private
 * @function isArray
 * @description Checks if the provided object is an array, autocurried function
 * @param {*} Object to verifiy
 * @return {boolean}
 * @since 1.0.2
 * @example
 *
 * const result = isArray([1,1,1])
 * // result = true
 */



/* harmony default export */ __webpack_exports__["default"] = (Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])('Array'));


/***/ }),

/***/ "./node_modules/fun.js/src/array/map.js":
/*!**********************************************!*\
  !*** ./node_modules/fun.js/src/array/map.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/**
 * @function map
 * @description Maps over an array and applies a function
 * @param {Function} cb
 * @param {Iterable} a
 * @return {Iterable}
 * @since v1.0.2
 * @example
 *
 *  const result = map(identity, [0,2,3])
 *  // result = [0,2,3]
 *  const add2 = add(2)
 *  const result = map(add2, [0,2,3])
 *  // result = [2,4,5]
 **/


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function map (cb, a) {
  let i = -1
  const l = a.length
  const r = new Array(l)
  while (++i < l) {
    r[i] = cb(a[i], i, a)
  }
  return r
}));


/***/ }),

/***/ "./node_modules/fun.js/src/boolean/is.js":
/*!***********************************************!*\
  !*** ./node_modules/fun.js/src/boolean/is.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is */ "./node_modules/fun.js/src/is.js");
/**
 * Curried function that verifies of the provided argument is a boolean
 *
 * @private
 * @function is
 * @description Curried function that verifies of the provided argument is a boolean
 * @since v1.0.2
 * @param {*} Item to verify
 * @return {boolean}
 **/


/* harmony default export */ __webpack_exports__["default"] = (Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])('Boolean'));


/***/ }),

/***/ "./node_modules/fun.js/src/concat.js":
/*!*******************************************!*\
  !*** ./node_modules/fun.js/src/concat.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _array_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array/concat */ "./node_modules/fun.js/src/array/concat.js");
/* harmony import */ var _string_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./string/concat */ "./node_modules/fun.js/src/string/concat.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type */ "./node_modules/fun.js/src/type.js");
/**
 * Concatenates 2 items together
 *
 * @function concat
 * @description Concatenates 2 items together
 * @since v1.0.4
 * @param {a} a - Left side of the concatenation
 * @param {a} b - right side of the concatenation
 * @return {a} Concatenated item
 **/






/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function concat (a, b) {
  const typeMap = {
    'String': _string_concat__WEBPACK_IMPORTED_MODULE_2__["default"],
    'Array': _array_concat__WEBPACK_IMPORTED_MODULE_1__["default"]
  }
  return typeMap[Object(_type__WEBPACK_IMPORTED_MODULE_3__["default"])(a)](a, b)
}));


/***/ }),

/***/ "./node_modules/fun.js/src/curry.js":
/*!******************************************!*\
  !*** ./node_modules/fun.js/src/curry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return curry; });
/* eslint-disable no-use-before-define */
/**
 * @function curry
 * @description Autocurries the provided function
 */
function curry (fun) {
  const argslen = fun.length

  if (argslen === 0) {
    return fun
  }
  return createRecurser([])

  function recurse (acc, args) {
    const _acc = acc.concat(args)
    return _acc.length < argslen
      ? createRecurser(_acc)
      : fun.apply(this, _acc)
  }

  function createRecurser (acc) {
    return function () {
      return recurse(acc, Array.prototype.slice.call(arguments))
    }
  }
}


/***/ }),

/***/ "./node_modules/fun.js/src/date/is.js":
/*!********************************************!*\
  !*** ./node_modules/fun.js/src/date/is.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is */ "./node_modules/fun.js/src/is.js");
/**
 * Created by dierickx.len on 01/04/2017.
 */
/**
 * Created by dierickx.len on 01/04/2017.
 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])('Date'));


/***/ }),

/***/ "./node_modules/fun.js/src/empty.js":
/*!******************************************!*\
  !*** ./node_modules/fun.js/src/empty.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return empty; });
/**

 * @function empty
 * @description Returns the empty equivalent of the first argument
 */

function empty (x) {
  return new x.constructor()
};


/***/ }),

/***/ "./node_modules/fun.js/src/equals.js":
/*!*******************************************!*\
  !*** ./node_modules/fun.js/src/equals.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _exists__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exists */ "./node_modules/fun.js/src/exists.js");
/* harmony import */ var _identical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identical */ "./node_modules/fun.js/src/identical.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type */ "./node_modules/fun.js/src/type.js");
/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./not */ "./node_modules/fun.js/src/not.js");
/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./or */ "./node_modules/fun.js/src/or.js");
/* harmony import */ var _object_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./object/is */ "./node_modules/fun.js/src/object/is.js");
/* harmony import */ var _array_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array/is */ "./node_modules/fun.js/src/array/is.js");
/* harmony import */ var _boolean_is__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./boolean/is */ "./node_modules/fun.js/src/boolean/is.js");
/* harmony import */ var _number_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./number/is */ "./node_modules/fun.js/src/number/is.js");
/* harmony import */ var _string_is__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./string/is */ "./node_modules/fun.js/src/string/is.js");
/* harmony import */ var _date_is__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./date/is */ "./node_modules/fun.js/src/date/is.js");
/* harmony import */ var _array_equals__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./array/equals */ "./node_modules/fun.js/src/array/equals.js");
/* harmony import */ var _object_equals__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./object/equals */ "./node_modules/fun.js/src/object/equals.js");
/**

 * @function equals
 * @description Autocurried function that checks for equality of 2 items
 * @param {*} x - Left side of the equality check
 * @param {*} y - Right side of the equality check
 * @return {boolean}
 * @example
 *
 * const nan = Number.NaN
 * equal(nan, nan) // returns true
 *
 * const arr1 = [0, 1, 2, 3]
 * const arr2 = [null, 1, 2, 3]
 * equals(arr1, arr2) // returns false
 *
 * equals(new Object({'a': 0, 'b': 1}), {'a': 0, 'b': 1}) // true
 *
 */















/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function equals (x, y) {
  if (Object(_identical__WEBPACK_IMPORTED_MODULE_2__["default"])(x, y)) return true

  if (Object(_type__WEBPACK_IMPORTED_MODULE_3__["default"])(x) !== Object(_type__WEBPACK_IMPORTED_MODULE_3__["default"])(y)) return false

  if (Object(_or__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_not__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_exists__WEBPACK_IMPORTED_MODULE_1__["default"])(x)), Object(_not__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_exists__WEBPACK_IMPORTED_MODULE_1__["default"])(y)))) return false

  if (x.constructor !== y.constructor) return false

  if (Object(_string_is__WEBPACK_IMPORTED_MODULE_10__["default"])(x) || Object(_boolean_is__WEBPACK_IMPORTED_MODULE_8__["default"])(x) || Object(_number_is__WEBPACK_IMPORTED_MODULE_9__["default"])(x) || Object(_date_is__WEBPACK_IMPORTED_MODULE_11__["default"])(x)) {
    return Object(_identical__WEBPACK_IMPORTED_MODULE_2__["default"])(x.valueOf(), y.valueOf())
  }
  if (Object(_array_is__WEBPACK_IMPORTED_MODULE_7__["default"])(x)) {
    return Object(_array_equals__WEBPACK_IMPORTED_MODULE_12__["default"])(x, y)
  } else if (Object(_object_is__WEBPACK_IMPORTED_MODULE_6__["default"])(x)) {
    return Object(_object_equals__WEBPACK_IMPORTED_MODULE_13__["default"])(x, y)
  }
  return false
}));


/***/ }),

/***/ "./node_modules/fun.js/src/exists.js":
/*!*******************************************!*\
  !*** ./node_modules/fun.js/src/exists.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exists; });
/**
 * @function exists
 */
function exists (x) {
  return !(x == null)
};


/***/ }),

/***/ "./node_modules/fun.js/src/fold.js":
/*!*****************************************!*\
  !*** ./node_modules/fun.js/src/fold.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _array_fold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array/fold */ "./node_modules/fun.js/src/array/fold.js");
/* harmony import */ var _object_fold__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object/fold */ "./node_modules/fun.js/src/object/fold.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type */ "./node_modules/fun.js/src/type.js");
/**
 * Returns a single item by iterating over an array like object and call a function on each item
 *
 * @function fold
 * @description Returns a single item by iterating over an array like object and call a function on each item
 * @since v1.0.2
 * @sig ((a, b, c, a) → a) → a → [b] → a
 * @param {Function} cb receives 4 values: the accumulator, the item, the index, and the initial value.
 * @param {*} a is the initial value
 * @param {*} [b] the array like item to iterate over
 * @return {*} a is the accumulated value
 **/






/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function fold (cb, init, a) {
  const typeMap = {
    'Object': _object_fold__WEBPACK_IMPORTED_MODULE_2__["default"],
    'Array': _array_fold__WEBPACK_IMPORTED_MODULE_1__["default"]
  }
  // if (a.next) {
  //   return iterableFold(cb, init, a)
  // }
  // if (type(Symbol) !== 'undefined' && a[Symbol.iterator]) {
  //   return iterableFold(cb, init, a[Symbol.iterator]())
  // }
  return typeMap[Object(_type__WEBPACK_IMPORTED_MODULE_3__["default"])(a)](cb, init, a)
}));

// function iterableFold (cb, acc, gen) {
//   let step = gen.next()
//   while (!step.done) {
//     acc = cb(acc, step.value)
//     step = gen.next()
//   }
//   return acc
// }


/***/ }),

/***/ "./node_modules/fun.js/src/identical.js":
/*!**********************************************!*\
  !*** ./node_modules/fun.js/src/identical.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _number_isNan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number/isNan */ "./node_modules/fun.js/src/number/isNan.js");
/**

 * @function identical
 * @description checks for identintical items
 */



/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function identical (x, y) {
  if (x === 0 && y === 0) {
    return 1 / x === 1 / y
  }
  if (x === y) {
    return true
  }
  return !!(Object(_number_isNan__WEBPACK_IMPORTED_MODULE_1__["default"])(x) && Object(_number_isNan__WEBPACK_IMPORTED_MODULE_1__["default"])(y))
}));


/***/ }),

/***/ "./node_modules/fun.js/src/is.js":
/*!***************************************!*\
  !*** ./node_modules/fun.js/src/is.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type */ "./node_modules/fun.js/src/type.js");
/**
 * @function is
 * @description Verifies the type of the provided argument
 *
 */




/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function is (Ctor, val) {
  return Object(_type__WEBPACK_IMPORTED_MODULE_1__["default"])(val) === Ctor
}));


/***/ }),

/***/ "./node_modules/fun.js/src/iterator/is.js":
/*!************************************************!*\
  !*** ./node_modules/fun.js/src/iterator/is.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isIter; });
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is */ "./node_modules/fun.js/src/is.js");
/**
 * Created by dierickx.len on 01/04/2017.
 */

const isFunction = Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])('Function')

function isIter (iter) {
  return isFunction(iter[Symbol.iterator])
}


/***/ }),

/***/ "./node_modules/fun.js/src/iterator/map.js":
/*!*************************************************!*\
  !*** ./node_modules/fun.js/src/iterator/map.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/**
 * Maps over an Iterator and applies a function
 *
 * @function
 * @since v1.0.3
 * @sig (currentValue, idx, [a]) -> {b} -> [b]
 * @param {Function} cb
 * @param {Iterator} a
 * @return {Iterator}
 **/


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function map (callback, iterator) {
  let r = []
  for (let nextValue = iterator.next(); nextValue.done !== true; nextValue = iterator.next()) {
    r.push(callback(iterator.value()))
  }
  return r
}));


/***/ }),

/***/ "./node_modules/fun.js/src/map.js":
/*!****************************************!*\
  !*** ./node_modules/fun.js/src/map.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _array_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array/map */ "./node_modules/fun.js/src/array/map.js");
/* harmony import */ var _object_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object/map */ "./node_modules/fun.js/src/object/map.js");
/* harmony import */ var _map_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map/map */ "./node_modules/fun.js/src/map/map.js");
/* harmony import */ var _string_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string/map */ "./node_modules/fun.js/src/string/map.js");
/* harmony import */ var _iterator_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./iterator/map */ "./node_modules/fun.js/src/iterator/map.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./type */ "./node_modules/fun.js/src/type.js");
/* harmony import */ var _iterator_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./iterator/is */ "./node_modules/fun.js/src/iterator/is.js");
/**
 * Maps over an iterable and applies a function
 *
 * @function map
 * @description Autocurried function which maps over an iterable.
 * @since v1.0.2
 * @sig (currentValue, idx, [a]) -> b -> b
 * @param {Function} cb
 * @param {Iterable} a
 * @return {Iterable}
 **/









/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function map (cb, a) {
  switch (Object(_type__WEBPACK_IMPORTED_MODULE_6__["default"])(a)) {
    case 'Function':
      return Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
        return cb.call(this, a.apply(this, arguments))
      })
    case 'Object':
      return Object(_object_map__WEBPACK_IMPORTED_MODULE_2__["default"])(cb, a)
    case 'String':
      return Object(_string_map__WEBPACK_IMPORTED_MODULE_4__["default"])(cb, a)
    case 'Map':
      return Object(_map_map__WEBPACK_IMPORTED_MODULE_3__["default"])(cb, a)
    case 'Array':
      return Object(_array_map__WEBPACK_IMPORTED_MODULE_1__["default"])(cb, a)
    default:
      return Object(_iterator_is__WEBPACK_IMPORTED_MODULE_7__["default"])(a)
        ? Object(_iterator_map__WEBPACK_IMPORTED_MODULE_5__["default"])(cb, a)
        : Object(_array_map__WEBPACK_IMPORTED_MODULE_1__["default"])(cb, a)
  }
}));


/***/ }),

/***/ "./node_modules/fun.js/src/map/map.js":
/*!********************************************!*\
  !*** ./node_modules/fun.js/src/map/map.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../empty */ "./node_modules/fun.js/src/empty.js");
/**
 * Maps over a Map and applies a function
 *
 * @function
 * @since v1.0.2
 * @sig (currentValue, idx, [a]) -> {b} -> [b]
 * @param {Function} cb
 * @param {Map} a
 * @return {Map}
 **/



/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function map (cb, a) {
  const r = Object(_empty__WEBPACK_IMPORTED_MODULE_1__["default"])(a)
  a.forEach((v, k, map) => {
    r.set(k, cb(v, k, map))
  })
  return r
}));


/***/ }),

/***/ "./node_modules/fun.js/src/not.js":
/*!****************************************!*\
  !*** ./node_modules/fun.js/src/not.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/**
 * @function not
 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function not (x) {
  return !x
}));


/***/ }),

/***/ "./node_modules/fun.js/src/number/is.js":
/*!**********************************************!*\
  !*** ./node_modules/fun.js/src/number/is.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is */ "./node_modules/fun.js/src/is.js");
/**
 * @private
 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])('Number'));


/***/ }),

/***/ "./node_modules/fun.js/src/number/isNan.js":
/*!*************************************************!*\
  !*** ./node_modules/fun.js/src/number/isNan.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isNan; });
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./node_modules/fun.js/src/number/is.js");
/* harmony import */ var _and__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../and */ "./node_modules/fun.js/src/and.js");
/**
 * @function isNaN
 * @description Checks if number is NAN

 */



function isNan (x) {
  return Object(_and__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])(x), isNaN(x))
};


/***/ }),

/***/ "./node_modules/fun.js/src/object/equals.js":
/*!**************************************************!*\
  !*** ./node_modules/fun.js/src/object/equals.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _exists__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../exists */ "./node_modules/fun.js/src/exists.js");
/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../not */ "./node_modules/fun.js/src/not.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../equals */ "./node_modules/fun.js/src/equals.js");
/**

 * equals
 * checks for equality
 */





/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])((x, y) => {
  for (let keyX in x) {
    // noinspection JSUnfilteredForInLoop
    if (Object(_not__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_equals__WEBPACK_IMPORTED_MODULE_3__["default"])(x[keyX], y[keyX]))) return false
  }

  for (let keyY in y) {
    if (Object(_not__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_exists__WEBPACK_IMPORTED_MODULE_1__["default"])(x[keyY])) && Object(_exists__WEBPACK_IMPORTED_MODULE_1__["default"])(y[keyY])) return false
  }

  return true
}));


/***/ }),

/***/ "./node_modules/fun.js/src/object/fold.js":
/*!************************************************!*\
  !*** ./node_modules/fun.js/src/object/fold.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys */ "./node_modules/fun.js/src/object/keys.js");
/**
 * @function fold
 * @private
 *
 */



/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function fold (cb, init, o) {
  const k = Object(_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(o)
  let i = -1
  const l = k.length
  let r = Object(init)
  while (++i < l) {
    r = cb(r, o[k[i]], k[i], o)
  }
  return r
}));


/***/ }),

/***/ "./node_modules/fun.js/src/object/is.js":
/*!**********************************************!*\
  !*** ./node_modules/fun.js/src/object/is.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is */ "./node_modules/fun.js/src/is.js");
/**

 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])('Object'));


/***/ }),

/***/ "./node_modules/fun.js/src/object/keys.js":
/*!************************************************!*\
  !*** ./node_modules/fun.js/src/object/keys.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/**
 * Returns the own keys of an object as an Array
 *
 * @function
 * @since v1.0.2
 * @sig a -> [b]
 * @param {Object}
 * @return {Array}
 **/


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function keys (a) {
  return Object.keys(Object(a))
}));


/***/ }),

/***/ "./node_modules/fun.js/src/object/map.js":
/*!***********************************************!*\
  !*** ./node_modules/fun.js/src/object/map.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../empty */ "./node_modules/fun.js/src/empty.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys */ "./node_modules/fun.js/src/object/keys.js");
/**
 * Maps over an object and applies a function
 *
 * @function
 * @since v1.0.2
 * @sig (currentValue, idx, [a]) -> {b} -> [b]
 * @param {Function} cb
 * @param {Object} a
 * @return {Object}
 **/




/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function map (cb, a) {
  const k = Object(_keys__WEBPACK_IMPORTED_MODULE_2__["default"])(a)
  let i = -1
  const l = k.length
  const r = Object(_empty__WEBPACK_IMPORTED_MODULE_1__["default"])(a)
  while (++i < l) {
    r[k[i]] = cb(a[k[i]], k[i], a)
  }
  return r
}));


/***/ }),

/***/ "./node_modules/fun.js/src/or.js":
/*!***************************************!*\
  !*** ./node_modules/fun.js/src/or.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/fun.js/src/curry.js");
/**
 * @function or
 * @description Returns true if one or the other is true
 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function or (x, y) {
  return x || y
}));


/***/ }),

/***/ "./node_modules/fun.js/src/string/concat.js":
/*!**************************************************!*\
  !*** ./node_modules/fun.js/src/string/concat.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return concat; });
/**
 * @private
 * @function stringConcat
 */

function concat (a, b) { // use function(), arrow function doesn't bind arguments
  return String(a) + String(b)
}


/***/ }),

/***/ "./node_modules/fun.js/src/string/is.js":
/*!**********************************************!*\
  !*** ./node_modules/fun.js/src/string/is.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is */ "./node_modules/fun.js/src/is.js");
/**

 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_is__WEBPACK_IMPORTED_MODULE_0__["default"])('String'));


/***/ }),

/***/ "./node_modules/fun.js/src/string/map.js":
/*!***********************************************!*\
  !*** ./node_modules/fun.js/src/string/map.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curry */ "./node_modules/fun.js/src/curry.js");
/**
 * Maps over a string and applies a function
 *
 * @function
 * @since v1.0.2
 * @sig (currentValue, idx, [a]) -> [a] -> [a]
 * @param {Function} cb
 * @param {Iterable} a
 * @return {Iterable}
 **/


/* harmony default export */ __webpack_exports__["default"] = (Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function map (cb, a) {
  let i = -1
  const l = a.length
  let r = ''
  while (++i < l) {
    r += cb(a.charAt(i), i, a)
  }
  return r
}));


/***/ }),

/***/ "./node_modules/fun.js/src/type.js":
/*!*****************************************!*\
  !*** ./node_modules/fun.js/src/type.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _private_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_private/curry1 */ "./node_modules/fun.js/src/_private/curry1.js");
/**
 * @function type
 */


/* harmony default export */ __webpack_exports__["default"] = (Object(_private_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function type (x) {
  return Object.prototype.toString.call(x).slice(8, -1)
}));


/***/ }),

/***/ "./node_modules/gl/browser_index.js":
/*!******************************************!*\
  !*** ./node_modules/gl/browser_index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function createContext (width, height, options) {
  width = width | 0
  height = height | 0
  if (!(width > 0 && height > 0)) {
    return null
  }

  var canvas = document.createElement('canvas')
  if (!canvas) {
    return null
  }
  var gl
  canvas.width = width
  canvas.height = height

  try {
    gl = canvas.getContext('webgl', options)
  } catch (e) {
    try {
      gl = canvas.getContext('experimental-webgl', options)
    } catch (e) {
      return null
    }
  }

  var _getExtension = gl.getExtension
  var extDestroy = {
    destroy: function () {
      var loseContext = _getExtension.call(gl, 'WEBGL_lose_context')
      if (loseContext) {
        loseContext.loseContext()
      }
    }
  }

  var extResize = {
    resize: function (w, h) {
      canvas.width = w
      canvas.height = h
    }
  }

  var _supportedExtensions = gl.getSupportedExtensions().slice()
  _supportedExtensions.push(
    'STACKGL_destroy_context',
    'STACKGL_resize_drawingbuffer')
  gl.getSupportedExtensions = function () {
    return _supportedExtensions.slice()
  }

  gl.getExtension = function (extName) {
    var name = extName.toLowerCase()
    if (name === 'stackgl_resize_drawingbuffer') {
      return extResize
    }
    if (name === 'stackgl_destroy_context') {
      return extDestroy
    }
    return _getExtension.call(gl, extName)
  }

  return gl || null
}

module.exports = createContext


/***/ }),

/***/ "./node_modules/gpu-mock.js/index.js":
/*!*******************************************!*\
  !*** ./node_modules/gpu-mock.js/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function mock1D() {
  const row = [];
  for (let x = 0; x < this.output.x; x++) {
    this.thread.x = x;
    this.thread.y = 0;
    this.thread.z = 0;
    row.push(this._fn.apply(this, arguments));
  }
  return row;
}

function mock2D() {
  const matrix = [];
  for (let y = 0; y < this.output.y; y++) {
    const row = [];
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      row.push(this._fn.apply(this, arguments));
    }
    matrix.push(row);
  }
  return matrix;
}

function mock3D() {
  const cube = [];
  for (let z = 0; z < this.output.z; z++) {
    const matrix = [];
    for (let y = 0; y < this.output.y; y++) {
      const row = [];
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = y;
        this.thread.z = z;
        row.push(this._fn.apply(this, arguments));
      }
      matrix.push(row);
    }
    cube.push(matrix);
  }
  return cube;
}

module.exports = function gpuMock(fn, options) {
  let contextOutput = null;
  if (options.output.length) {
    if (options.output.length === 3) {
      contextOutput = { x: options.output[0], y: options.output[1], z: options.output[2] };
    } else if (options.output.length === 2) {
      contextOutput = { x: options.output[0], y: options.output[1] };
    } else {
      contextOutput = { x: options.output[0] };
    }
  } else {
    contextOutput = options.output;
  }

  const context = {
    _fn: fn,
    constants: options.constants,
    output: contextOutput,
    thread: {
      x: 0,
      y: 0,
      z: 0
    }
  };

  if (contextOutput.z) {
    return mock3D.bind(context);
  } else if (contextOutput.y) {
    return mock2D.bind(context);
  } else {
    return mock1D.bind(context);
  }
};


/***/ }),

/***/ "./node_modules/gpu.js/src/alias.js":
/*!******************************************!*\
  !*** ./node_modules/gpu.js/src/alias.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	utils
} = __webpack_require__(/*! ./utils */ "./node_modules/gpu.js/src/utils.js");

/**
 *
 * @param name
 * @param source
 * @returns {Function}
 */
function alias(name, source) {
	const fnString = source.toString();
	return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
  ${ utils.getFunctionBodyFromString(fnString) }
}`)();
}

module.exports = {
	alias
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/cpu/function-node.js":
/*!**************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/cpu/function-node.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	FunctionNode
} = __webpack_require__(/*! ../function-node */ "./node_modules/gpu.js/src/backend/function-node.js");

/**
 * @desc [INTERNAL] Represents a single function, inside JS
 *
 * <p>This handles all the raw state, converted state, etc. Of a single function.</p>
 */
class CPUFunctionNode extends FunctionNode {
	/**
	 * @desc Parses the abstract syntax tree for to its *named function*
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astFunctionExpression(ast, retArr) {

		// Setup function return type and name
		if (!this.isRootKernel) {
			retArr.push('function');
			retArr.push(' ');
			retArr.push(this.name);
			retArr.push('(');

			// Arguments handling
			for (let i = 0; i < this.argumentNames.length; ++i) {
				const argumentName = this.argumentNames[i];

				if (i > 0) {
					retArr.push(', ');
				}
				retArr.push('user_');
				retArr.push(argumentName);
			}

			// Function opening
			retArr.push(') {\n');
		}

		// Body statement iteration
		for (let i = 0; i < ast.body.body.length; ++i) {
			this.astGeneric(ast.body.body[i], retArr);
			retArr.push('\n');
		}

		if (!this.isRootKernel) {
			// Function closing
			retArr.push('}\n');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for to *return* statement
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astReturnStatement(ast, retArr) {
		if (this.isRootKernel) {
			retArr.push(this.leadingReturnStatement);
			this.astGeneric(ast.argument, retArr);
			retArr.push(';\n');
			retArr.push(this.followingReturnStatement);
			retArr.push('continue;\n');
		} else if (this.isSubKernel) {
			retArr.push(`subKernelResult_${ this.name } = `);
			this.astGeneric(ast.argument, retArr);
			retArr.push(';');
			retArr.push(`return subKernelResult_${ this.name };`);
		} else {
			retArr.push('return ');
			this.astGeneric(ast.argument, retArr);
			retArr.push(';');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *literal value*
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astLiteral(ast, retArr) {

		// Reject non numeric literals
		if (isNaN(ast.value)) {
			throw this.astErrorOutput(
				'Non-numeric literal not supported : ' + ast.value,
				ast
			);
		}

		retArr.push(ast.value);

		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *binary* expression
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astBinaryExpression(ast, retArr) {
		retArr.push('(');
		this.astGeneric(ast.left, retArr);
		retArr.push(ast.operator);
		this.astGeneric(ast.right, retArr);
		retArr.push(')');
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *identifier* expression
	 * @param {Object} idtNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astIdentifierExpression(idtNode, retArr) {
		if (idtNode.type !== 'Identifier') {
			throw this.astErrorOutput(
				'IdentifierExpression - not an Identifier',
				idtNode
			);
		}

		switch (idtNode.name) {
			case 'Infinity':
				retArr.push('Infinity');
				break;
			default:
				if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
					retArr.push('constants_' + idtNode.name);
				} else {
					const name = this.getKernelArgumentName(idtNode.name);
					if (name) {
						retArr.push('user_' + name);
					} else {
						retArr.push('user_' + idtNode.name);
					}
				}
		}

		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *for-loop* expression
	 * @param {Object} forNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the parsed webgl string
	 */
	astForStatement(forNode, retArr) {
		if (forNode.type !== 'ForStatement') {
			throw this.astErrorOutput('Invalid for statement', forNode);
		}

		const initArr = [];
		const testArr = [];
		const updateArr = [];
		const bodyArr = [];
		let isSafe = null;

		if (forNode.init) {
			this.pushState('in-for-loop-init');
			this.astGeneric(forNode.init, initArr);
			for (let i = 0; i < initArr.length; i++) {
				if (initArr[i].includes && initArr[i].includes(',')) {
					isSafe = false;
				}
			}
			this.popState('in-for-loop-init');
		} else {
			isSafe = false;
		}

		if (forNode.test) {
			this.astGeneric(forNode.test, testArr);
		} else {
			isSafe = false;
		}

		if (forNode.update) {
			this.astGeneric(forNode.update, updateArr);
		} else {
			isSafe = false;
		}

		if (forNode.body) {
			this.pushState('loop-body');
			this.astGeneric(forNode.body, bodyArr);
			this.popState('loop-body');
		}

		// have all parts, now make them safe
		if (isSafe === null) {
			isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
		}

		if (isSafe) {
			retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
			retArr.push(bodyArr.join(''));
			retArr.push('}\n');
		} else {
			const iVariableName = this.getInternalVariableName('safeI');
			if (initArr.length > 0) {
				retArr.push(initArr.join(''), ';\n');
			}
			retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
			if (testArr.length > 0) {
				retArr.push(`if (!${testArr.join('')}) break;\n`);
			}
			retArr.push(bodyArr.join(''));
			retArr.push(`\n${updateArr.join('')};`);
			retArr.push('}\n');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *while* loop
	 * @param {Object} whileNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the parsed javascript string
	 */
	astWhileStatement(whileNode, retArr) {
		if (whileNode.type !== 'WhileStatement') {
			throw this.astErrorOutput(
				'Invalid while statement',
				whileNode
			);
		}

		retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
		retArr.push('if (');
		this.astGeneric(whileNode.test, retArr);
		retArr.push(') {\n');
		this.astGeneric(whileNode.body, retArr);
		retArr.push('} else {\n');
		retArr.push('break;\n');
		retArr.push('}\n');
		retArr.push('}\n');

		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *do while* loop
	 * @param {Object} doWhileNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the parsed webgl string
	 */
	astDoWhileStatement(doWhileNode, retArr) {
		if (doWhileNode.type !== 'DoWhileStatement') {
			throw this.astErrorOutput(
				'Invalid while statement',
				doWhileNode
			);
		}

		retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
		this.astGeneric(doWhileNode.body, retArr);
		retArr.push('if (!');
		this.astGeneric(doWhileNode.test, retArr);
		retArr.push(') {\n');
		retArr.push('break;\n');
		retArr.push('}\n');
		retArr.push('}\n');

		return retArr;

	}

	/**
	 * @desc Parses the abstract syntax tree for *Assignment* Expression
	 * @param {Object} assNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astAssignmentExpression(assNode, retArr) {
		this.astGeneric(assNode.left, retArr);
		retArr.push(assNode.operator);
		this.astGeneric(assNode.right, retArr);
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *Block* statement
	 * @param {Object} bNode - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astBlockStatement(bNode, retArr) {
		if (this.isState('loop-body')) {
			this.pushState('block-body'); // this prevents recursive removal of braces
			for (let i = 0; i < bNode.body.length; i++) {
				this.astGeneric(bNode.body[i], retArr);
			}
			this.popState('block-body');
		} else {
			retArr.push('{\n');
			for (let i = 0; i < bNode.body.length; i++) {
				this.astGeneric(bNode.body[i], retArr);
			}
			retArr.push('}\n');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *Variable Declaration*
	 * @param {Object} varDecNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astVariableDeclaration(varDecNode, retArr) {
		if (varDecNode.kind === 'var') {
			this.varWarn();
		}
		retArr.push(`${varDecNode.kind} `);
		const firstDeclaration = varDecNode.declarations[0];
		const type = this.getType(firstDeclaration.init);
		for (let i = 0; i < varDecNode.declarations.length; i++) {
			this.declarations[varDecNode.declarations[i].id.name] = {
				type: type === 'LiteralInteger' ? 'Number' : type,
				dependencies: {
					constants: [],
					arguments: []
				},
				isUnsafe: false
			};
			if (i > 0) {
				retArr.push(',');
			}
			this.astGeneric(varDecNode.declarations[i], retArr);
		}
		if (!this.isState('in-for-loop-init')) {
			retArr.push(';');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *If* Statement
	 * @param {Object} ifNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astIfStatement(ifNode, retArr) {
		retArr.push('if (');
		this.astGeneric(ifNode.test, retArr);
		retArr.push(')');
		if (ifNode.consequent.type === 'BlockStatement') {
			this.astGeneric(ifNode.consequent, retArr);
		} else {
			retArr.push(' {\n');
			this.astGeneric(ifNode.consequent, retArr);
			retArr.push('\n}\n');
		}

		if (ifNode.alternate) {
			retArr.push('else ');
			if (ifNode.alternate.type === 'BlockStatement') {
				this.astGeneric(ifNode.alternate, retArr);
			} else {
				retArr.push(' {\n');
				this.astGeneric(ifNode.alternate, retArr);
				retArr.push('\n}\n');
			}
		}
		return retArr;

	}

	/**
	 * @desc Parses the abstract syntax tree for *This* expression
	 * @param {Object} tNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astThisExpression(tNode, retArr) {
		retArr.push('_this');
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *Member* Expression
	 * @param {Object} mNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astMemberExpression(mNode, retArr) {
		const {
			signature,
			type,
			property,
			xProperty,
			yProperty,
			zProperty,
			name,
			origin
		} = this.getMemberExpressionDetails(mNode);
		switch (signature) {
			case 'this.thread.value':
				retArr.push(`_this.thread.${ name }`);
				return retArr;
			case 'this.output.value':
				switch (name) {
					case 'x':
						retArr.push(this.output[0]);
						break;
					case 'y':
						retArr.push(this.output[1]);
						break;
					case 'z':
						retArr.push(this.output[2]);
						break;
					default:
						throw this.astErrorOutput('Unexpected expression', mNode);
				}
				return retArr;
			case 'value':
				throw this.astErrorOutput('Unexpected expression', mNode);
			case 'value[]':
			case 'value[][]':
			case 'value[][][]':
			case 'value.value':
				if (origin === 'Math') {
					retArr.push(Math[name]);
					return retArr;
				}
				switch (property) {
					case 'r':
						retArr.push(`user_${ name }[0]`);
						return retArr;
					case 'g':
						retArr.push(`user_${ name }[1]`);
						return retArr;
					case 'b':
						retArr.push(`user_${ name }[2]`);
						return retArr;
					case 'a':
						retArr.push(`user_${ name }[3]`);
						return retArr;
				}
				break;
			case 'this.constants.value':
			case 'this.constants.value[]':
			case 'this.constants.value[][]':
			case 'this.constants.value[][][]':
				break;
			case 'fn()[]':
				this.astGeneric(mNode.object, retArr);
				retArr.push('[');
				this.astGeneric(mNode.property, retArr);
				retArr.push(']');
				return retArr;
			default:
				throw this.astErrorOutput('Unexpected expression', mNode);
		}

		// handle simple types
		switch (type) {
			case 'Number':
			case 'Integer':
			case 'Float':
			case 'Boolean':
				retArr.push(`${ origin }_${ name}`);
				return retArr;
		}

		// handle more complex types
		// argument may have come from a parent
		const synonymName = this.getKernelArgumentName(name);
		const markupName = `${origin}_${synonymName || name}`;

		switch (type) {
			case 'Array(2)':
			case 'Array(3)':
			case 'Array(4)':
			case 'HTMLImageArray':
			case 'ArrayTexture(1)':
			case 'ArrayTexture(2)':
			case 'ArrayTexture(3)':
			case 'ArrayTexture(4)':
			case 'HTMLImage':
			default:
				const isInput = this.isInput(synonymName || name);
				retArr.push(`${ markupName }`);
				if (zProperty && yProperty) {
					if (isInput) {
						const size = this.argumentSizes[this.argumentNames.indexOf(name)];
						retArr.push('[(');
						this.astGeneric(zProperty, retArr);
						retArr.push(`*${ size[1] * size[0]})+(`);
						this.astGeneric(yProperty, retArr);
						retArr.push(`*${ size[0] })+`);
						this.astGeneric(xProperty, retArr);
						retArr.push(']');
					} else {
						retArr.push('[');
						this.astGeneric(zProperty, retArr);
						retArr.push(']');
						retArr.push('[');
						this.astGeneric(yProperty, retArr);
						retArr.push(']');
						retArr.push('[');
						this.astGeneric(xProperty, retArr);
						retArr.push(']');
					}
				} else if (yProperty) {
					if (isInput) {
						const size = this.argumentSizes[this.argumentNames.indexOf(name)];
						retArr.push('[(');
						this.astGeneric(yProperty, retArr);
						retArr.push(`*${ size[0] })+`);
						this.astGeneric(xProperty, retArr);
						retArr.push(']');
					} else {
						retArr.push('[');
						this.astGeneric(yProperty, retArr);
						retArr.push(']');
						retArr.push('[');
						this.astGeneric(xProperty, retArr);
						retArr.push(']');
					}
				} else {
					retArr.push('[');
					this.astGeneric(xProperty, retArr);
					retArr.push(']');
				}
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *call* expression
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns  {Array} the append retArr
	 */
	astCallExpression(ast, retArr) {
		if (ast.callee) {
			// Get the full function call, unrolled
			let funcName = this.astMemberExpressionUnroll(ast.callee);

			// Register the function into the called registry
			if (this.calledFunctions.indexOf(funcName) < 0) {
				this.calledFunctions.push(funcName);
			}
			if (!this.calledFunctionsArguments[funcName]) {
				this.calledFunctionsArguments[funcName] = [];
			}

			const functionArguments = [];
			this.calledFunctionsArguments[funcName].push(functionArguments);

			// Call the function
			retArr.push(funcName);

			// Open arguments space
			retArr.push('(');

			// Add the vars
			for (let i = 0; i < ast.arguments.length; ++i) {
				const argument = ast.arguments[i];
				if (i > 0) {
					retArr.push(', ');
				}
				this.astGeneric(argument, retArr);
				const argumentType = this.getType(argument);
				if (argumentType) {
					functionArguments.push({
						name: argument.name || null,
						type: argumentType
					});
				} else {
					functionArguments.push(null);
				}
			}

			// Close arguments space
			retArr.push(')');

			return retArr;
		}

		// Failure, unknown expression
		throw this.astErrorOutput(
			'Unknown CallExpression',
			ast
		);
	}

	/**
	 * @desc Parses the abstract syntax tree for *Array* Expression
	 * @param {Object} arrNode - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astArrayExpression(arrNode, retArr) {
		const arrLen = arrNode.elements.length;

		retArr.push('[');
		for (let i = 0; i < arrLen; ++i) {
			if (i > 0) {
				retArr.push(', ');
			}
			const subNode = arrNode.elements[i];
			this.astGeneric(subNode, retArr)
		}
		retArr.push(']');

		return retArr;
	}

	astDebuggerStatement(arrNode, retArr) {
		retArr.push('debugger;');
		return retArr;
	}
}

module.exports = {
	CPUFunctionNode
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/cpu/kernel-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/cpu/kernel-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	utils
} = __webpack_require__(/*! ../../utils */ "./node_modules/gpu.js/src/utils.js");
const {
	kernelRunShortcut
} = __webpack_require__(/*! ../../kernel-run-shortcut */ "./node_modules/gpu.js/src/kernel-run-shortcut.js");

function removeFnNoise(fn) {
	if (/^function /.test(fn)) {
		fn = fn.substring(9);
	}
	return fn.replace(/[_]typeof/g, 'typeof');
}

function removeNoise(str) {
	return str
		.replace(/^[A-Za-z]+/, 'function')
		.replace(/[_]typeof/g, 'typeof');
}

function cpuKernelString(cpuKernel, name) {
	return `() => {
    ${ kernelRunShortcut.toString() };
    const utils = {
      allPropertiesOf: ${ removeNoise(utils.allPropertiesOf.toString()) },
      clone: ${ removeNoise(utils.clone.toString()) },
    };
    let Input = function() {};
    class ${ name || 'Kernel' } {
      constructor() {        
        this.argumentsLength = 0;
        this.canvas = null;
        this.context = null;
        this.built = false;
        this.program = null;
        this.argumentNames = ${ JSON.stringify(cpuKernel.argumentNames) };
        this.argumentTypes = ${ JSON.stringify(cpuKernel.argumentTypes) };
        this.argumentSizes = ${ JSON.stringify(cpuKernel.argumentSizes) };
        this.output = ${ JSON.stringify(cpuKernel.output) };
        this._kernelString = \`${ cpuKernel._kernelString }\`;
        this.output = ${ JSON.stringify(cpuKernel.output) };
		    this.run = function() {
          this.run = null;
          this.build(arguments);
          return this.run.apply(this, arguments);
        }.bind(this);
        this.thread = {
          x: 0,
          y: 0,
          z: 0
        };
      }
      setCanvas(canvas) { this.canvas = canvas; return this; }
      setContext(context) { this.context = context; return this; }
      setInput(Type) { Input = Type; }
      ${ removeFnNoise(cpuKernel.build.toString()) }
      setupArguments() {}
      ${ removeFnNoise(cpuKernel.setupConstants.toString()) }
      translateSource() {}
      pickRenderStrategy() {}
      run () { ${ cpuKernel.kernelString } }
      getKernelString() { return this._kernelString; }
      ${ removeFnNoise(cpuKernel.validateSettings.toString()) }
      ${ removeFnNoise(cpuKernel.checkOutput.toString()) }
    };
    return kernelRunShortcut(new Kernel());
  };`;
}

module.exports = {
	cpuKernelString
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/cpu/kernel.js":
/*!*******************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/cpu/kernel.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	Kernel
} = __webpack_require__(/*! ../kernel */ "./node_modules/gpu.js/src/backend/kernel.js");
const {
	FunctionBuilder
} = __webpack_require__(/*! ../function-builder */ "./node_modules/gpu.js/src/backend/function-builder.js");
const {
	CPUFunctionNode
} = __webpack_require__(/*! ./function-node */ "./node_modules/gpu.js/src/backend/cpu/function-node.js");
const {
	utils
} = __webpack_require__(/*! ../../utils */ "./node_modules/gpu.js/src/utils.js");
const {
	cpuKernelString
} = __webpack_require__(/*! ./kernel-string */ "./node_modules/gpu.js/src/backend/cpu/kernel-string.js");

/**
 * @desc Kernel Implementation for CPU.
 * <p>Instantiates properties to the CPU Kernel.</p>
 */
class CPUKernel extends Kernel {
	static getFeatures() {
		return this.features;
	}
	static get features() {
		return Object.freeze({
			kernelMap: true,
			isIntegerDivisionAccurate: true
		});
	}
	static get isSupported() {
		return true;
	}
	static isContextMatch(context) {
		return false;
	}
	/**
	 * @desc The current mode in which gpu.js is executing.
	 */
	static get mode() {
		return 'cpu';
	}

	static nativeFunctionArguments() {
		return null;
	}

	static nativeFunctionReturnType() {
		return null;
	}

	static combineKernels(combinedKernel) {
		return combinedKernel;
	}

	constructor(source, settings) {
		super(source, settings);
		this.mergeSettings(source.settings || settings);

		this._imageData = null;
		this._colorData = null;
		this._kernelString = null;
		this.thread = {
			x: 0,
			y: 0,
			z: 0
		};
		this.translatedSources = null;
		this.run = function() { //note: need arguments
			this.run = null;
			this.build.apply(this, arguments);
			return this.run.apply(this, arguments);
		}.bind(this);
	}

	initCanvas() {
		if (typeof document !== 'undefined') {
			return document.createElement('canvas');
		} else if (typeof OffscreenCanvas !== 'undefined') {
			return new OffscreenCanvas(0, 0);
		}
	}

	initContext() {
		if (!this.canvas) return null;
		return this.canvas.getContext('2d');
	}

	initPlugins(settings) {
		return [];
	}

	/**
	 * @desc Validate settings related to CPU Kernel, such as
	 * dimensions size, and auto dimension support.
	 */
	validateSettings() {
		if (!this.output || this.output.length === 0) {
			if (arguments.length !== 1) {
				throw 'Auto dimensions only supported for kernels with only one input';
			}

			const argType = utils.getVariableType(arguments[0]);
			if (argType === 'Array') {
				this.output = utils.getDimensions(argType);
			} else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
				this.output = arguments[0].output;
			} else {
				throw 'Auto dimensions not supported for input type: ' + argType;
			}
		}

		if (this.graphical) {
			if (this.output.length !== 2) {
				throw new Error('Output must have 2 dimensions on graphical mode');
			}
		}

		this.checkOutput();
	}

	translateSource() {
		this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
		if (this.subKernels) {
			const followingReturnStatement = []
			for (let i = 0; i < this.subKernels.length; i++) {
				const {
					name
				} = this.subKernels[i];
				followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
			}
			this.followingReturnStatement = followingReturnStatement.join('');
		}
		const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
		this.translatedSources = functionBuilder.getPrototypes('kernel');
		if (!this.graphical && !this.returnType) {
			this.returnType = functionBuilder.getKernelResultType();
		}
	}

	/**
	 * @desc Builds the Kernel, by generating the kernel
	 * string using thread dimensions, and arguments
	 * supplied to the kernel.
	 *
	 * <p>If the graphical flag is enabled, canvas is used.</p>
	 */
	build() {
		this.setupConstants();
		this.setupArguments(arguments);
		this.validateSettings();
		this.translateSource();

		if (this.graphical) {
			const {
				canvas,
				output
			} = this;
			if (!canvas) {
				throw new Error('no canvas available for using graphical output');
			}
			const width = output[0];
			const height = output[1] || 1;
			canvas.width = width;
			canvas.height = height;
			this._imageData = this.context.createImageData(width, height);
			this._colorData = new Uint8ClampedArray(width * height * 4);
		}

		const kernelString = this.getKernelString();
		this.kernelString = kernelString;

		if (this.debug) {
			console.log('Function output:');
			console.log(kernelString);
		}

		try {
			this.run = new Function([], kernelString).bind(this)();
		} catch (e) {
			console.error('An error occurred compiling the javascript: ', e);
		}
	}

	color(r, g, b, a) {
		if (typeof a === 'undefined') {
			a = 1;
		}

		r = Math.floor(r * 255);
		g = Math.floor(g * 255);
		b = Math.floor(b * 255);
		a = Math.floor(a * 255);

		const width = this.output[0];
		const height = this.output[1];

		const x = this.thread.x;
		const y = height - this.thread.y - 1;

		const index = x + y * width;

		this._colorData[index * 4 + 0] = r;
		this._colorData[index * 4 + 1] = g;
		this._colorData[index * 4 + 2] = b;
		this._colorData[index * 4 + 3] = a;
	}

	/**
	 * @desc Generates kernel string for this kernel program.
	 *
	 * <p>If sub-kernels are supplied, they are also factored in.
	 * This string can be saved by calling the `toString` method
	 * and then can be reused later.</p>
	 *
	 * @returns {String} result
	 *
	 */
	getKernelString() {
		if (this._kernelString !== null) return this._kernelString;

		let kernelThreadString = null;
		let {
			translatedSources
		} = this;
		if (translatedSources.length > 1) {
			translatedSources = translatedSources.filter(fn => {
				if (/^function/.test(fn)) return fn;
				kernelThreadString = fn;
				return false;
			})
		} else {
			kernelThreadString = translatedSources.shift();
		}
		const kernelString = this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() }
  const constants = this.constants;
  const _this = this;
  return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
    ${ this._processConstants() }
    ${ this._processArguments() }
    ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
    ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
  };`;
		return kernelString;
	}

	/**
	 * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.
	 */
	toString() {
		return cpuKernelString(this);
	}

	/**
	 * @desc Get the maximum loop size String.
	 * @returns {String} result
	 */
	_getLoopMaxString() {
		return (
			this.loopMaxIterations ?
			` ${ parseInt(this.loopMaxIterations) };` :
			' 1000;'
		);
	}

	_processConstants() {
		if (!this.constants) return '';

		const result = [];
		for (let p in this.constants) {
			const type = this.constantTypes[p];
			switch (type) {
				case 'HTMLImage':
					result.push(`    const constants_${p} = this._imageTo2DArray(this.constants.${p});\n`);
					break;
				case 'HTMLImageArray':
					result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
					break;
				case 'Input':
					result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
					break;
				default:
					result.push(`    const constants_${p} = this.constants.${p};\n`);
			}
		}
		return result.join('');
	}

	_processArguments() {
		const result = [];
		for (let i = 0; i < this.argumentTypes.length; i++) {
			switch (this.argumentTypes[i]) {
				case 'HTMLImage':
					result.push(`    user_${this.argumentNames[i]} = this._imageTo2DArray(user_${this.argumentNames[i]});\n`);
					break;
				case 'HTMLImageArray':
					result.push(`    user_${this.argumentNames[i]} = this._imageTo3DArray(user_${this.argumentNames[i]});\n`);
					break;
				case 'Input':
					result.push(`    user_${this.argumentNames[i]} = user_${this.argumentNames[i]}.value;\n`);
					break;
			}
		}
		return result.join('');
	}

	_imageTo2DArray(image) {
		const canvas = this.canvas;
		if (canvas.width < image.width) {
			canvas.width = image.width;
		}
		if (canvas.height < image.height) {
			canvas.height = image.height;
		}
		const ctx = this.context;
		ctx.drawImage(image, 0, 0, image.width, image.height);
		const pixelsData = ctx.getImageData(0, 0, image.width, image.height).data;
		const imageArray = new Array(image.height);
		let index = 0;
		for (let y = image.height - 1; y >= 0; y--) {
			const row = imageArray[y] = new Array(image.width);
			for (let x = 0; x < image.width; x++) {
				const pixel = new Float32Array(4);
				pixel[0] = pixelsData[index++] / 255; // r
				pixel[1] = pixelsData[index++] / 255; // g
				pixel[2] = pixelsData[index++] / 255; // b
				pixel[3] = pixelsData[index++] / 255; // a
				row[x] = pixel;
			}
		}
		return imageArray;
	}

	getPixels() {
		// https://stackoverflow.com/a/41973289/1324039
		const [width, height] = this.output;
		const halfHeight = height / 2 | 0; // the | 0 keeps the result an int
		const bytesPerRow = width * 4;
		// make a temp buffer to hold one row
		const temp = new Uint8Array(width * 4);
		const pixels = this._imageData.data.slice(0);
		for (let y = 0; y < halfHeight; ++y) {
			var topOffset = y * bytesPerRow;
			var bottomOffset = (height - y - 1) * bytesPerRow;

			// make copy of a row on the top half
			temp.set(pixels.subarray(topOffset, topOffset + bytesPerRow));

			// copy a row from the bottom half to the top
			pixels.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

			// copy the copy of the top half row to the bottom half
			pixels.set(temp, bottomOffset);
		}
		return pixels;
	}

	_imageTo3DArray(images) {
		const imagesArray = new Array(images.length);
		for (let i = 0; i < images.length; i++) {
			imagesArray[i] = this._imageTo2DArray(images[i]);
		}
		return imagesArray;
	}

	_resultKernelBody(kernelString) {
		switch (this.output.length) {
			case 1:
				return this._resultKernel1DLoop(kernelString) + this._kernelOutput();
			case 2:
				return this._resultKernel2DLoop(kernelString) + this._kernelOutput();
			case 3:
				return this._resultKernel3DLoop(kernelString) + this._kernelOutput();
			default:
				throw new Error('unsupported size kernel');
		}
	}

	_graphicalKernelBody(kernelThreadString) {
		switch (this.output.length) {
			case 2:
				return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
			default:
				throw new Error('unsupported size kernel');
		}
	}

	_graphicalOutput() {
		return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`
	}

	_getKernelResultTypeConstructorString() {
		switch (this.returnType) {
			case 'LiteralInteger':
			case 'Number':
			case 'Integer':
			case 'Float':
				return 'Float32Array';
			case 'Array(2)':
			case 'Array(3)':
			case 'Array(4)':
				return 'Array';
			default:
				if (this.graphical) {
					return 'Float32Array';
				}
				throw new Error(`unhandled returnType ${ this.returnType }`);
		}
	}

	_resultKernel1DLoop(kernelString) {
		const {
			output
		} = this;
		const constructorString = this._getKernelResultTypeConstructorString();
		return `const result = new ${constructorString}(${ output[0] });
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(${ output[0] });\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let x = 0; x < ${ output[0] }; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
	}

	_resultKernel2DLoop(kernelString) {
		const {
			output
		} = this;
		const constructorString = this._getKernelResultTypeConstructorString();
		return `const result = new Array(${ output[1] });
		${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(${ output[1] });\n`).join('    ') }
		${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < ${ output[1] }; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${constructorString}(${ output[0] });
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(${ output[0] });\n`).join('') }
      for (let x = 0; x < ${ output[0] }; x++) {
      	this.thread.x = x;
        ${ kernelString }
      }
    }`;
	}

	_graphicalKernel2DLoop(kernelString) {
		const {
			output
		} = this;
		const constructorString = this._getKernelResultTypeConstructorString();
		return `  ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(${ output[1] });\n`).join('    ') }
		${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < ${ output[1] }; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(${ output[0] });\n`).join('') }
      for (let x = 0; x < ${ output[0] }; x++) {
      	this.thread.x = x;
        ${ kernelString }
      }
    }`;
	}

	_resultKernel3DLoop(kernelString) {
		const {
			output
		} = this;
		const constructorString = this._getKernelResultTypeConstructorString();
		return `const result = new Array(${ output[2] });
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(${ output[2] });\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < ${ output[2] }; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(${ output[1] });
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(${ output[1] });\n`).join('      ') }
      for (let y = 0; y < ${ output[1] }; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${constructorString}(${ output[0] });
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(${ output[0] });\n`).join('        ') }
        for (let x = 0; x < ${ output[0] }; x++) {
        	this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
	}

	_kernelOutput() {
		if (!this.subKernels) {
			return '\n    return result;';
		}
		return `\n    return {
      result: result,
      ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
    };`;
	}

	_mapSubKernels(fn) {
		return this.subKernels === null ? [''] :
			this.subKernels.map(fn);
	}



	destroy(removeCanvasReference) {
		if (removeCanvasReference) {
			delete this.canvas;
		}
	}

	static destroyContext(context) {}

	toJSON() {
		const json = super.toJSON();
		json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
		return json;
	}
}

module.exports = {
	CPUKernel
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/function-builder.js":
/*!*************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/function-builder.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @desc This handles all the raw state, converted state, etc. of a single function.
 * [INTERNAL] A collection of functionNodes.
 */
class FunctionBuilder {
	/**
	 *
	 * @param {Kernel} kernel
	 * @param {FunctionNode} FunctionNode
	 * @param {object} [extraNodeOptions]
	 * @returns FunctionBuilder
	 */
	static fromKernel(kernel, FunctionNode, extraNodeOptions) {
		const {
			argumentNames,
			argumentTypes,
			argumentSizes,
			argumentBitRatios,
			constants,
			constantTypes,
			constantBitRatios,
			debug,
			loopMaxIterations,
			nativeFunctions,
			output,
			optimizeFloatMemory,
			precision,
			plugins,
			source,
			subKernels,
			functions,
			leadingReturnStatement,
			followingReturnStatement,
		} = kernel;

		const lookupReturnType = (functionName, ast, requestingNode) => {
			return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
		};

		const lookupArgumentType = (argumentName, requestingNode) => {
			return functionBuilder.lookupArgumentType(argumentName, requestingNode);
		};

		const lookupFunctionArgumentTypes = (functionName) => {
			return functionBuilder.lookupFunctionArgumentTypes(functionName);
		};

		const lookupFunctionArgumentName = (functionName, argumentIndex) => {
			return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
		};

		const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
			return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
		};

		const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
			functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
		};

		const triggerTrackArgumentSynonym = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
			functionBuilder.trackArgumentSynonym(functionName, argumentName, calleeFunctionName, argumentIndex);
		};

		const lookupArgumentSynonym = (originFunctionName, functionName, argumentName) => {
			return functionBuilder.lookupArgumentSynonym(originFunctionName, functionName, argumentName);
		};

		const onFunctionCall = (functionName, calleeFunctionName) => {
			functionBuilder.trackFunctionCall(functionName, calleeFunctionName);
		};

		const onNestedFunction = (fnString, returnType) => {
			functionBuilder.addFunctionNode(new FunctionNode(fnString, Object.assign({}, nodeOptions, {
				returnType: returnType || 'Number', // TODO: I think this needs removed
				lookupReturnType,
				lookupArgumentType,
				lookupFunctionArgumentTypes,
				lookupFunctionArgumentName,
				lookupFunctionArgumentBitRatio,
				triggerImplyArgumentType,
				triggerTrackArgumentSynonym,
				lookupArgumentSynonym,
				onFunctionCall
			})));
		};

		const nodeOptions = Object.assign({
			isRootKernel: false,
			onNestedFunction,
			lookupReturnType,
			lookupArgumentType,
			lookupFunctionArgumentTypes,
			lookupFunctionArgumentName,
			lookupFunctionArgumentBitRatio,
			triggerImplyArgumentType,
			triggerTrackArgumentSynonym,
			lookupArgumentSynonym,
			onFunctionCall,
			optimizeFloatMemory,
			precision,
			constants,
			constantTypes,
			constantBitRatios,
			debug,
			loopMaxIterations,
			output,
			plugins,
		}, extraNodeOptions || {});

		const rootNodeOptions = Object.assign({}, nodeOptions, {
			isRootKernel: true,
			name: 'kernel',
			argumentNames,
			argumentTypes,
			argumentSizes,
			argumentBitRatios,
			leadingReturnStatement,
			followingReturnStatement,
		});

		if (typeof source === 'object' && source.functionNodes) {
			return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
		}

		const rootNode = new FunctionNode(source, rootNodeOptions);

		let functionNodes = null;
		if (functions) {
			functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
				returnType: fn.returnType,
				argumentTypes: fn.argumentTypes,
				output,
				plugins,
				constants,
				constantTypes,
				constantBitRatios,
				optimizeFloatMemory,
				precision,
				lookupReturnType,
				lookupArgumentType,
				lookupFunctionArgumentTypes,
				lookupFunctionArgumentName,
				lookupFunctionArgumentBitRatio,
				triggerImplyArgumentType,
				triggerTrackArgumentSynonym,
				lookupArgumentSynonym,
				onFunctionCall,
			}));
		}

		let subKernelNodes = null;
		if (subKernels) {
			subKernelNodes = subKernels.map((subKernel) => {
				const {
					name,
					source
				} = subKernel;
				return new FunctionNode(source, Object.assign({}, nodeOptions, {
					name,
					isSubKernel: true,
					isRootKernel: false,
					returnType: 'Number', // TODO: I think this needs removed
				}));
			});
		}

		const functionBuilder = new FunctionBuilder({
			kernel,
			rootNode,
			functionNodes,
			nativeFunctions,
			subKernelNodes
		});

		return functionBuilder;
	}

	/**
	 *
	 * @param {IFunctionBuilderSettings} [settings]
	 */
	constructor(settings) {
		settings = settings || {};
		this.kernel = settings.kernel;
		this.rootNode = settings.rootNode;
		this.functionNodes = settings.functionNodes || [];
		this.subKernelNodes = settings.subKernelNodes || [];
		this.nativeFunctions = settings.nativeFunctions || [];
		this.functionMap = {};
		this.nativeFunctionNames = [];
		this.lookupChain = [];
		this.argumentChain = [];
		this.functionNodeDependencies = {};

		if (this.rootNode) {
			this.functionMap['kernel'] = this.rootNode;
		}

		if (this.functionNodes) {
			for (let i = 0; i < this.functionNodes.length; i++) {
				this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
			}
		}

		if (this.subKernelNodes) {
			for (let i = 0; i < this.subKernelNodes.length; i++) {
				this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
			}
		}

		if (this.nativeFunctions) {
			for (let i = 0; i < this.nativeFunctions.length; i++) {
				const nativeFunction = this.nativeFunctions[i];
				this.nativeFunctionNames.push(nativeFunction.name);
			}
		}
	}

	/**
	 * @desc Add the function node directly
	 *
	 * @param {FunctionNode} functionNode - functionNode to add
	 *
	 */
	addFunctionNode(functionNode) {
		this.functionMap[functionNode.name] = functionNode;
		if (functionNode.isRootKernel) {
			this.rootNode = functionNode;
		}
	}

	/**
	 * @desc Trace all the depending functions being called, from a single function
	 *
	 * This allow for 'unneeded' functions to be automatically optimized out.
	 * Note that the 0-index, is the starting function trace.
	 *
	 * @param {String} functionName - Function name to trace from, default to 'kernel'
	 * @param {String[]} [retList] - Returning list of function names that is traced. Including itself.
	 *
	 * @returns {String[]}  Returning list of function names that is traced. Including itself.
	 */
	traceFunctionCalls(functionName, retList) {
		functionName = functionName || 'kernel';
		retList = retList || [];

		if (this.nativeFunctionNames.indexOf(functionName) > -1) {
			if (retList.indexOf(functionName) === -1) {
				retList.push(functionName);
			}
			return retList;
		}

		const functionNode = this.functionMap[functionName];
		if (functionNode) {
			// Check if function already exists
			const functionIndex = retList.indexOf(functionName);
			if (functionIndex === -1) {
				retList.push(functionName);
				functionNode.toString(); //ensure JS trace is done
				for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
					this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
				}
			} else {
				/**
				 * https://github.com/gpujs/gpu.js/issues/207
				 * if dependent function is already in the list, because a function depends on it, and because it has
				 * already been traced, we know that we must move the dependent function to the end of the the retList.
				 * */
				const dependantFunctionName = retList.splice(functionIndex, 1)[0];
				retList.push(dependantFunctionName);
			}
		}

		return retList;
	}

	/**
	 * @desc Return the string for a function
	 * @param {String} functionName - Function name to trace from. If null, it returns the WHOLE builder stack
	 * @returns {String} The full string, of all the various functions. Trace optimized if functionName given
	 */
	getPrototypeString(functionName) {
		return this.getPrototypes(functionName).join('\n');
	}

	/**
	 * @desc Return the string for a function
	 * @param {String} [functionName] - Function name to trace from. If null, it returns the WHOLE builder stack
	 * @returns {Array} The full string, of all the various functions. Trace optimized if functionName given
	 */
	getPrototypes(functionName) {
		if (this.rootNode) {
			this.rootNode.toString();
		}
		if (functionName) {
			return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
		}
		return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
	}

	/**
	 * @desc Get string from function names
	 * @param {String[]} functionList - List of function to build string
	 * @returns {String} The string, of all the various functions. Trace optimized if functionName given
	 */
	getStringFromFunctionNames(functionList) {
		const ret = [];
		for (let i = 0; i < functionList.length; ++i) {
			const node = this.functionMap[functionList[i]];
			if (node) {
				ret.push(this.functionMap[functionList[i]].toString());
			}
		}
		return ret.join('\n');
	}

	/**
	 * @desc Return string of all functions converted
	 * @param {String[]} functionList - List of function names to build the string.
	 * @returns {Array} Prototypes of all functions converted
	 */
	getPrototypesFromFunctionNames(functionList) {
		const ret = [];
		for (let i = 0; i < functionList.length; ++i) {
			const functionName = functionList[i];
			const functionIndex = this.nativeFunctionNames.indexOf(functionName);
			if (functionIndex > -1) {
				ret.push(this.nativeFunctions[functionIndex].source);
				continue;
			}
			const node = this.functionMap[functionName];
			if (node) {
				ret.push(node.toString());
			}
		}
		return ret;
	}

	toJSON() {
		return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
			const nativeIndex = this.nativeFunctions.indexOf(name);
			if (nativeIndex > -1) {
				return {
					name,
					source: this.nativeFunctions[nativeIndex].source
				};
			} else if (this.functionMap[name]) {
				return this.functionMap[name].toJSON();
			} else {
				throw new Error(`function ${ name } not found`);
			}
		});
	}

	fromJSON(jsonFunctionNodes, FunctionNode) {
		this.functionMap = {};
		for (let i = 0; i < jsonFunctionNodes.length; i++) {
			const jsonFunctionNode = jsonFunctionNodes[i];
			this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
		}
		return this;
	}

	/**
	 * @desc Get string for a particular function name
	 * @param {String} functionName - Function name to trace from. If null, it returns the WHOLE builder stack
	 * @returns {String} settings - The string, of all the various functions. Trace optimized if functionName given
	 */
	getString(functionName) {
		if (functionName) {
			return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
		}
		return this.getStringFromFunctionNames(Object.keys(this.functionMap));
	}

	lookupArgumentType(argumentName, requestingNode) {
		const index = requestingNode.argumentNames.indexOf(argumentName);
		if (index === -1) return null;
		if (this.lookupChain.length === 0) return null;
		let link = this.lookupChain[this.lookupChain.length - 1 - this.argumentChain.length];
		if (!link) return null;
		const {
			ast,
			requestingNode: parentRequestingNode
		} = link;
		if (ast.arguments.length === 0) return null;
		const usedVariable = ast.arguments[index];
		if (!usedVariable) return null;
		this.argumentChain.push(argumentName);
		const type = parentRequestingNode.getType(usedVariable);
		this.argumentChain.pop();
		return type;
	}

	lookupReturnType(functionName, ast, requestingNode) {
		// TODO: track circlical logic
		if (ast.type !== 'CallExpression') {
			throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
		}
		if (this._isNativeFunction(functionName)) {
			return this._lookupNativeFunctionReturnType(functionName);
		} else if (this._isFunction(functionName)) {
			const node = this._getFunction(functionName);
			if (node.returnType) {
				return node.returnType;
			} else {
				// get ready for a ride!
				this.lookupChain.push({
					name: requestingNode.name,
					ast,
					requestingNode
				});
				const type = node.getType(node.getJsAST());
				this.lookupChain.pop();
				return node.returnType = type;
			}
		}

		// function not found, maybe native?
		return null;
	}

	_getFunction(functionName) {
		if (!this._isFunction(functionName)) {
			new Error(`Function ${functionName} not found`);
		}
		return this.functionMap[functionName];
	}

	_isFunction(functionName) {
		return Boolean(this.functionMap[functionName]);
	}

	_getNativeFunction(functionName) {
		for (let i = 0; i < this.nativeFunctions.length; i++) {
			if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
		}
		return null;
	}

	_isNativeFunction(functionName) {
		return Boolean(this._getNativeFunction(functionName));
	}

	_lookupNativeFunctionReturnType(functionName) {
		let nativeFunction = this._getNativeFunction(functionName);
		if (nativeFunction) {
			return nativeFunction.returnType;
		}
		throw new Error(`Native function ${ functionName } not found`);
	}

	lookupFunctionArgumentTypes(functionName) {
		if (this._isNativeFunction(functionName)) {
			return this._getNativeFunction(functionName).argumentTypes;
		} else if (this._isFunction(functionName)) {
			return this._getFunction(functionName).argumentTypes;
		}
		return null;
	}

	lookupFunctionArgumentName(functionName, argumentIndex) {
		return this._getFunction(functionName).argumentNames[argumentIndex];
	}

	lookupFunctionArgumentBitRatio(functionName, argumentName) {
		if (!this._isFunction(functionName)) {
			throw new Error('function not found');
		}
		if (this.rootNode.name === functionName) {
			const i = this.rootNode.argumentNames.indexOf(argumentName);
			if (i !== -1) {
				return this.rootNode.argumentBitRatios[i];
			} else {
				throw new Error('argument bit ratio not found');
			}
		} else {
			const node = this._getFunction(functionName);
			const argumentSynonym = node.argumentSynonym[node.synonymIndex];
			if (!argumentSynonym) {
				throw new Error('argument synonym not found');
			}
			return this.lookupFunctionArgumentBitRatio(argumentSynonym.functionName, argumentSynonym.argumentName);
		}
	}

	assignArgumentType(functionName, i, argumentType, requestingNode) {
		if (!this._isFunction(functionName)) return;
		this._getFunction(functionName).argumentTypes[i] = argumentType;
	}

	trackArgumentSynonym(functionName, argumentName, calleeFunctionName, argumentIndex) {
		if (!this._isFunction(calleeFunctionName)) return;
		const node = this._getFunction(calleeFunctionName);
		if (!node.argumentSynonym) {
			node.argumentSynonym = {};
		}
		const calleeArgumentName = node.argumentNames[argumentIndex];
		if (!node.argumentSynonym[calleeArgumentName]) {
			node.argumentSynonym[calleeArgumentName] = {};
		}
		node.synonymIndex++;
		node.argumentSynonym[node.synonymIndex] = {
			functionName,
			argumentName,
			calleeArgumentName,
			calleeFunctionName,
		};
	}

	lookupArgumentSynonym(originFunctionName, functionName, argumentName) {
		if (originFunctionName === functionName) return argumentName;
		if (!this._isFunction(functionName)) return null;
		const node = this._getFunction(functionName);
		const argumentSynonym = node.argumentSynonym[node.synonymUseIndex];
		if (!argumentSynonym) return null;
		if (argumentSynonym.calleeArgumentName !== argumentName) return null;
		node.synonymUseIndex++;
		if (originFunctionName !== functionName) {
			return this.lookupArgumentSynonym(originFunctionName, argumentSynonym.functionName, argumentSynonym.argumentName);
		}
		return argumentSynonym.argumentName;
	}

	trackFunctionCall(functionName, calleeFunctionName) {
		if (!this.functionNodeDependencies[functionName]) {
			this.functionNodeDependencies[functionName] = new Set();
		}
		this.functionNodeDependencies[functionName].add(calleeFunctionName);
	}

	getKernelResultType() {
		return this.rootNode.getType(this.rootNode.ast);
	}

	getReturnTypes() {
		const result = {
			[this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
		};
		const list = this.traceFunctionCalls(this.rootNode.name);
		for (let i = 0; i < list.length; i++) {
			const functionName = list[i];
			const functionNode = this.functionMap[functionName];
			result[functionName] = functionNode.getType(functionNode.ast);
		}
		return result;
	}
}

module.exports = {
	FunctionBuilder
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/function-node.js":
/*!**********************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/function-node.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	utils
} = __webpack_require__(/*! ../utils */ "./node_modules/gpu.js/src/utils.js");
const acorn = __webpack_require__(/*! acorn */ "./node_modules/acorn/dist/acorn.mjs");

/**
 *
 * @desc Represents a single function, inside JS, webGL, or openGL.
 * <p>This handles all the raw state, converted state, etc. Of a single function.</p>
 */
class FunctionNode {
	/**
	 *
	 * @param {string|object} source
	 * @param {IFunctionSettings} [settings]
	 */
	constructor(source, settings) {
		if (!source) {
			throw new Error('source parameter is missing');
		}
		settings = settings || {};

		this.source = source;
		this.name = typeof source === 'string' ? settings.isRootKernel ?
			'kernel' :
			(settings.name || utils.getFunctionNameFromString(source)) : null;
		this.calledFunctions = [];
		this.calledFunctionsArguments = {};
		this.constants = {};
		this.constantTypes = {};
		this.constantBitRatios = {};
		this.isRootKernel = false;
		this.isSubKernel = false;
		this.debug = null;
		this.declarations = {};
		this.states = [];
		this.lookupReturnType = null;
		this.lookupArgumentType = null;
		this.lookupFunctionArgumentTypes = null;
		this.lookupFunctionArgumentBitRatio = null;
		this.triggerImplyArgumentType = null;
		this.triggerTrackArgumentSynonym = null;
		this.lookupArgumentSynonym = null;
		this.onNestedFunction = null;
		this.onFunctionCall = null;
		this.optimizeFloatMemory = null;
		this.precision = null;
		this.loopMaxIterations = null;
		this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
		this.argumentTypes = [];
		this.argumentSizes = [];
		this.argumentBitRatios = null;
		this.returnType = null;
		this.output = [];
		this.plugins = null;
		this.leadingReturnStatement = null;
		this.followingReturnStatement = null;

		if (settings) {
			for (const p in settings) {
				if (!settings.hasOwnProperty(p)) continue;
				if (!this.hasOwnProperty(p)) continue;
				this[p] = settings[p];
			}
		}

		this.synonymIndex = -1;
		this.synonymUseIndex = 0;
		this.argumentSynonym = {};
		this.literalTypes = {};

		if (this.isRootKernel && !this.returnType) {
			this.returnType = 'Number';
		}

		this.validate();
		this._string = null;
		this._internalVariableNames = {};
	}

	validate() {
		if (typeof this.source !== 'string') {
			throw new Error('this.source not a string');
		}

		if (!utils.isFunctionString(this.source)) {
			throw new Error('this.source not a function string');
		}

		if (!this.name) {
			throw new Error('this.name could not be set');
		}

		if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
			throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
		}

		if (this.output.length < 1) {
			throw new Error('this.output is not big enough');
		}
	}

	/**
	 * @param {String} name
	 * @returns {boolean}
	 */
	isIdentifierConstant(name) {
		if (!this.constants) return false;
		return this.constants.hasOwnProperty(name);
	}

	isInput(argumentName) {
		return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
	}

	pushState(state) {
		this.states.push(state);
	}

	popState(state) {
		if (this.state !== state) {
			throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
		}
		this.states.pop();
	}

	isState(state) {
		return this.state === state;
	}

	get state() {
		return this.states[this.states.length - 1];
	}

	/**
	 * @function
	 * @name astMemberExpressionUnroll
	 * @desc Parses the abstract syntax tree for binary expression.
	 *
	 * <p>Utility function for astCallExpression.</p>
	 *
	 * @param {Object} ast - the AST object to parse
	 *
	 * @returns {String} the function namespace call, unrolled
	 */
	astMemberExpressionUnroll(ast) {
		if (ast.type === 'Identifier') {
			return ast.name;
		} else if (ast.type === 'ThisExpression') {
			return 'this';
		}

		if (ast.type === 'MemberExpression') {
			if (ast.object && ast.property) {
				//babel sniffing
				if (ast.object.hasOwnProperty('name') && ast.object.name[0] === '_') {
					return this.astMemberExpressionUnroll(ast.property);
				}

				return (
					this.astMemberExpressionUnroll(ast.object) +
					'.' +
					this.astMemberExpressionUnroll(ast.property)
				);
			}
		}

		//babel sniffing
		if (ast.hasOwnProperty('expressions')) {
			const firstExpression = ast.expressions[0];
			if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
				return this.astMemberExpressionUnroll(ast.expressions[1]);
			}
		}

		// Failure, unknown expression
		throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
	}

	/**
	 * @desc Parses the class function JS, and returns its Abstract Syntax Tree object.
	 * This is used internally to convert to shader code
	 *
	 * @param {Object} [inParser] - Parser to use, assumes in scope 'parser' if null or undefined
	 *
	 * @returns {Object} The function AST Object, note that result is cached under this.ast;
	 */
	getJsAST(inParser) {
		if (typeof this.source === 'object') {
			return this.ast = this.source;
		}
		if (this.ast) {
			return this.ast;
		}

		inParser = inParser || acorn;
		if (inParser === null) {
			throw 'Missing JS to AST parser';
		}

		const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
			locations: true
		}));
		// take out the function object, outside the var declarations
		const functionAST = ast.body[0].declarations[0].init;
		if (!ast) {
			throw new Error('Failed to parse JS code');
		}

		return this.ast = functionAST;
	}

	/**
	 * @desc Return the type of parameter sent to subKernel/Kernel.
	 * @param {String} name - Name of the parameter
	 * @returns {String} Type of the parameter
	 */
	getVariableType(name) {
		let type = null;
		const argumentIndex = this.argumentNames.indexOf(name);
		if (argumentIndex === -1) {
			if (this.declarations[name]) {
				return this.declarations[name].type;
			}
		} else {
			const argumentType = this.argumentTypes[argumentIndex];
			if (argumentType) {
				type = argumentType;
			} else if (this.lookupArgumentType) {
				type = this.argumentTypes[argumentIndex] = this.lookupArgumentType(name, this);
			}
		}
		if (!type) {
			// TODO: strict type detection mode?
			// throw new Error(`Declaration of ${name} not found`);
		}
		return type;
	}

	getConstantType(constantName) {
		if (this.constantTypes[constantName]) {
			const type = this.constantTypes[constantName];
			if (type === 'Float') {
				return 'Number';
			} else {
				return type;
			}
		}
		throw new Error(`Type for constant "${ constantName }" not declared`);
	}

	/**
	 * @desc Return the name of the *user argument*(subKernel argument) corresponding
	 * to the argument supplied to the kernel
	 *
	 * @param {String} name - Name of the argument
	 * @returns {String} Name of the parameter
	 */
	getKernelArgumentName(name) {
		if (!this.lookupArgumentSynonym) return null;
		const argumentIndex = this.argumentNames.indexOf(name);
		if (argumentIndex === -1) return null;
		return this.lookupArgumentSynonym('kernel', this.name, name);
	}

	toString() {
		if (this._string) return this._string;
		return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
	}

	toJSON() {
		const settings = {
			source: this.source,
			name: this.name,
			constants: this.constants,
			constantTypes: this.constantTypes,
			isRootKernel: this.isRootKernel,
			isSubKernel: this.isSubKernel,
			debug: this.debug,
			output: this.output,
			loopMaxIterations: this.loopMaxIterations,
			argumentNames: this.argumentNames,
			argumentTypes: this.argumentTypes,
			argumentSizes: this.argumentSizes,
			returnType: this.returnType,
			leadingReturnStatement: this.leadingReturnStatement,
			followingReturnStatement: this.followingReturnStatement,
		};

		return {
			ast: this.ast,
			settings
		};
	}

	/**
	 * Recursively looks up type for ast expression until it's found
	 * @param ast
	 * @returns {String|null}
	 */
	getType(ast) {
		if (Array.isArray(ast)) {
			return this.getType(ast[ast.length - 1]);
		}
		switch (ast.type) {
			case 'BlockStatement':
				return this.getType(ast.body);
			case 'ArrayExpression':
				return `Array(${ ast.elements.length })`;
			case 'Literal':
				const literalKey = `${ast.start},${ast.end}`;
				if (this.literalTypes[literalKey]) {
					return this.literalTypes[literalKey];
				}
				if (Number.isInteger(ast.value)) {
					return 'LiteralInteger';
				} else if (ast.value === true || ast.value === false) {
					return 'Boolean';
				} else {
					return 'Number';
				}
			case 'CallExpression':
				if (this.isAstMathFunction(ast)) {
					return 'Number';
				}
				if (!ast.callee || !ast.callee.name) {
					if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
						return this.lookupReturnType(ast.callee.expressions[ast.callee.expressions.length - 1].property.name, ast, this);
					}
					throw this.astErrorOutput('Unknown call expression', ast);
				}
				if (ast.callee && ast.callee.name) {
					return this.lookupReturnType(ast.callee.name, ast, this);
				}
				throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
			case 'BinaryExpression':
				// modulos is Number
				switch (ast.operator) {
					case '%':
						return 'Number';
					case '>':
					case '<':
						return 'Boolean';
				}
				const type = this.getType(ast.left);
				return typeLookupMap[type] || type;
			case 'UpdateExpression':
				return this.getType(ast.argument);
			case 'UnaryExpression':
				return this.getType(ast.argument);
			case 'VariableDeclaration':
				return this.getType(ast.declarations[0]);
			case 'VariableDeclarator':
				return this.getType(ast.id);
			case 'Identifier':
				if (this.isAstVariable(ast)) {
					const signature = this.getVariableSignature(ast);
					if (signature === 'value') {
						if (this.argumentNames.indexOf(ast.name) > -1) {
							return this.getVariableType(ast.name);
						} else if (this.declarations[ast.name]) {
							return this.declarations[ast.name].type;
						}
					}
				}
				if (ast.name === 'Infinity') {
					return 'Number';
				}
				const origin = this.findIdentifierOrigin(ast);
				if (origin && origin.init) {
					return this.getType(origin.init);
				}
				return null;
			case 'ReturnStatement':
				return this.getType(ast.argument);
			case 'MemberExpression':
				if (this.isAstMathFunction(ast)) {
					switch (ast.property.name) {
						case 'ceil':
							return 'Integer';
						case 'floor':
							return 'Integer';
						case 'round':
							return 'Integer';
					}
					return 'Number';
				}
				if (this.isAstVariable(ast)) {
					const variableSignature = this.getVariableSignature(ast);
					switch (variableSignature) {
						case 'value[]':
							return typeLookupMap[this.getVariableType(ast.object.name)];
						case 'value[][]':
							return typeLookupMap[this.getVariableType(ast.object.object.name)];
						case 'value[][][]':
							return typeLookupMap[this.getVariableType(ast.object.object.object.name)];
						case 'value[][][][]':
							return typeLookupMap[this.getVariableType(ast.object.object.object.object.name)];
						case 'this.thread.value':
							return 'Integer';
						case 'this.output.value':
							return 'LiteralInteger';
						case 'this.constants.value':
							return this.getConstantType(ast.property.name);
						case 'this.constants.value[]':
							return typeLookupMap[this.getConstantType(ast.object.property.name)];
						case 'this.constants.value[][]':
							return typeLookupMap[this.getConstantType(ast.object.object.property.name)];
						case 'this.constants.value[][][]':
							return typeLookupMap[this.getConstantType(ast.object.object.object.property.name)];
						case 'this.constants.value[][][][]':
							return typeLookupMap[this.getConstantType(ast.object.object.object.object.property.name)];
						case 'fn()[]':
							return typeLookupMap[this.getType(ast.object)];
						case 'fn()[][]':
							return typeLookupMap[this.getType(ast.object)];
						case 'fn()[][][]':
							return typeLookupMap[this.getType(ast.object)];
						case 'value.value':
							if (this.isAstMathVariable(ast)) {
								return 'Number';
							}
							switch (ast.property.name) {
								case 'r':
									return typeLookupMap[this.getVariableType(ast.object.name)];
								case 'g':
									return typeLookupMap[this.getVariableType(ast.object.name)];
								case 'b':
									return typeLookupMap[this.getVariableType(ast.object.name)];
								case 'a':
									return typeLookupMap[this.getVariableType(ast.object.name)];
							}
						case '[][]':
							return 'Number';
					}
					throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
				}
				throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
			case 'ConditionalExpression':
				return this.getType(ast.consequent);
			case 'FunctionDeclaration':
			case 'FunctionExpression':
				const lastReturn = this.findLastReturn(ast.body);
				if (lastReturn) {
					return this.getType(lastReturn);
				}
				return null;
			case 'IfStatement':
				return this.getType(ast.consequent);
			default:
				throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
		}
	}

	isAstMathVariable(ast) {
		const mathProperties = [
			'E',
			'PI',
			'SQRT2',
			'SQRT1_2',
			'LN2',
			'LN10',
			'LOG2E',
			'LOG10E',
		];
		return ast.type === 'MemberExpression' &&
			ast.object && ast.object.type === 'Identifier' &&
			ast.object.name === 'Math' &&
			ast.property &&
			ast.property.type === 'Identifier' &&
			mathProperties.indexOf(ast.property.name) > -1;
	}

	isAstMathFunction(ast) {
		const mathFunctions = [
			'abs',
			'acos',
			'asin',
			'atan',
			'atan2',
			'ceil',
			'cos',
			'exp',
			'floor',
			'log',
			'log2',
			'max',
			'min',
			'pow',
			'random',
			'round',
			'sign',
			'sin',
			'sqrt',
			'tan',
		];
		return ast.type === 'CallExpression' &&
			ast.callee &&
			ast.callee.type === 'MemberExpression' &&
			ast.callee.object &&
			ast.callee.object.type === 'Identifier' &&
			ast.callee.object.name === 'Math' &&
			ast.callee.property &&
			ast.callee.property.type === 'Identifier' &&
			mathFunctions.indexOf(ast.callee.property.name) > -1;
	}

	isAstVariable(ast) {
		return ast.type === 'Identifier' || ast.type === 'MemberExpression';
	}

	isSafe(ast) {
		return this.isSafeDependencies(this.getDependencies(ast));
	}

	isSafeDependencies(dependencies) {
		return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
	}

	getDependencies(ast, dependencies, isNotSafe) {
		if (!dependencies) {
			dependencies = [];
		}
		if (!ast) return null;
		if (Array.isArray(ast)) {
			for (let i = 0; i < ast.length; i++) {
				this.getDependencies(ast[i], dependencies, isNotSafe);
			}
			return dependencies;
		}
		switch (ast.type) {
			case 'Literal':
				dependencies.push({
					origin: 'literal',
					value: ast.value,
					isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
				});
				break;
			case 'VariableDeclarator':
				return this.getDependencies(ast.init, dependencies, isNotSafe);
			case 'Identifier':
				if (this.declarations[ast.name]) {
					dependencies.push({
						name: ast.name,
						origin: 'declaration',
						isSafe: isNotSafe ? false : this.isSafeDependencies(this.declarations[ast.name].dependencies),
					});
				} else if (this.argumentNames.indexOf(ast.name) > -1) {
					dependencies.push({
						name: ast.name,
						origin: 'argument',
						isSafe: false,
					});
				}
				break;
			case 'FunctionDeclaration':
				return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
			case 'ReturnStatement':
				return this.getDependencies(ast.argument, dependencies);
			case 'BinaryExpression':
				isNotSafe = (ast.operator === '/' || ast.operator === '*');
				this.getDependencies(ast.left, dependencies, isNotSafe);
				this.getDependencies(ast.right, dependencies, isNotSafe);
				return dependencies;
			case 'UnaryExpression':
			case 'UpdateExpression':
				return this.getDependencies(ast.argument, dependencies, isNotSafe);
			case 'VariableDeclaration':
				return this.getDependencies(ast.declarations, dependencies, isNotSafe);
			case 'ArrayExpression':
				dependencies.push({
					origin: 'declaration',
					isSafe: true,
				});
				return dependencies;
			case 'CallExpression':
				dependencies.push({
					origin: 'function',
					isSafe: true,
				});
				return dependencies;
			case 'MemberExpression':
				const details = this.getMemberExpressionDetails(ast);
				if (details) {
					return details.type;
				}
			default:
				throw this.astErrorOutput(`Unhandled type ${ ast.type } in getAllVariables`, ast);
		}
		return dependencies;
	}

	getVariableSignature(ast) {
		if (!this.isAstVariable(ast)) {
			throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
		}
		if (ast.type === 'Identifier') {
			return 'value';
		}
		const signature = [];
		while (true) {
			if (!ast) break;
			if (ast.computed) {
				signature.push('[]');
			} else if (ast.type === 'ThisExpression') {
				signature.unshift('this');
			} else if (ast.property && ast.property.name) {
				if (
					ast.property.name === 'x' ||
					ast.property.name === 'y' ||
					ast.property.name === 'z'
				) {
					signature.unshift('.value');
				} else if (
					ast.property.name === 'constants' ||
					ast.property.name === 'thread' ||
					ast.property.name === 'output'
				) {
					signature.unshift('.' + ast.property.name);
				} else {
					signature.unshift('.value');
				}
			} else if (ast.name) {
				signature.unshift('value');
			} else if (ast.callee && ast.callee.name) {
				signature.unshift('fn()');
			} else if (ast.elements) {
				signature.unshift('[]');
			} else {
				signature.unshift('unknown');
			}
			ast = ast.object;
		}

		const signatureString = signature.join('');
		const allowedExpressions = [
			'value',
			'value[]',
			'value[][]',
			'value[][][]',
			'value[][][][]',
			'value.value',
			'this.thread.value',
			'this.output.value',
			'this.constants.value',
			'this.constants.value[]',
			'this.constants.value[][]',
			'this.constants.value[][][]',
			'this.constants.value[][][][]',
			'fn()[]',
			'fn()[][]',
			'fn()[][][]',
			'[][]',
		];
		if (allowedExpressions.indexOf(signatureString) > -1) {
			return signatureString;
		}
		return null;
	}

	build() {
		return this.toString().length > 0;
	}

	/**
	 * @desc Parses the abstract syntax tree for generically to its respective function
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the parsed string array
	 */
	astGeneric(ast, retArr) {
		if (ast === null) {
			throw this.astErrorOutput('NULL ast', ast);
		} else {
			if (Array.isArray(ast)) {
				for (let i = 0; i < ast.length; i++) {
					this.astGeneric(ast[i], retArr);
				}
				return retArr;
			}

			switch (ast.type) {
				case 'FunctionDeclaration':
					return this.astFunctionDeclaration(ast, retArr);
				case 'FunctionExpression':
					return this.astFunctionExpression(ast, retArr);
				case 'ReturnStatement':
					return this.astReturnStatement(ast, retArr);
				case 'Literal':
					return this.astLiteral(ast, retArr);
				case 'BinaryExpression':
					return this.astBinaryExpression(ast, retArr);
				case 'Identifier':
					return this.astIdentifierExpression(ast, retArr);
				case 'AssignmentExpression':
					return this.astAssignmentExpression(ast, retArr);
				case 'ExpressionStatement':
					return this.astExpressionStatement(ast, retArr);
				case 'EmptyStatement':
					return this.astEmptyStatement(ast, retArr);
				case 'BlockStatement':
					return this.astBlockStatement(ast, retArr);
				case 'IfStatement':
					return this.astIfStatement(ast, retArr);
				case 'BreakStatement':
					return this.astBreakStatement(ast, retArr);
				case 'ContinueStatement':
					return this.astContinueStatement(ast, retArr);
				case 'ForStatement':
					return this.astForStatement(ast, retArr);
				case 'WhileStatement':
					return this.astWhileStatement(ast, retArr);
				case 'DoWhileStatement':
					return this.astDoWhileStatement(ast, retArr);
				case 'VariableDeclaration':
					return this.astVariableDeclaration(ast, retArr);
				case 'VariableDeclarator':
					return this.astVariableDeclarator(ast, retArr);
				case 'ThisExpression':
					return this.astThisExpression(ast, retArr);
				case 'SequenceExpression':
					return this.astSequenceExpression(ast, retArr);
				case 'UnaryExpression':
					return this.astUnaryExpression(ast, retArr);
				case 'UpdateExpression':
					return this.astUpdateExpression(ast, retArr);
				case 'LogicalExpression':
					return this.astLogicalExpression(ast, retArr);
				case 'MemberExpression':
					return this.astMemberExpression(ast, retArr);
				case 'CallExpression':
					return this.astCallExpression(ast, retArr);
				case 'ArrayExpression':
					return this.astArrayExpression(ast, retArr);
				case 'DebuggerStatement':
					return this.astDebuggerStatement(ast, retArr);
				case 'ConditionalExpression':
					return this.astConditionalExpression(ast, retArr);
			}

			throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
		}
	}
	/**
	 * @desc To throw the AST error, with its location.
	 * @param {string} error - the error message output
	 * @param {Object} ast - the AST object where the error is
	 */
	astErrorOutput(error, ast) {
		if (typeof this.source !== 'string') {
			return new Error(error);
		}

		const debugString = utils.getAstString(this.source, ast);
		const leadingSource = this.source.substr(ast.start);
		const splitLines = leadingSource.split(/\n/);
		const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
		return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
	}

	astDebuggerStatement(arrNode, retArr) {
		return retArr;
	}

	astConditionalExpression(ast, retArr) {
		if (ast.type !== 'ConditionalExpression') {
			throw this.astErrorOutput('Not a conditional expression', ast);
		}
		retArr.push('(');
		this.astGeneric(ast.test, retArr);
		retArr.push('?');
		this.astGeneric(ast.consequent, retArr);
		retArr.push(':');
		this.astGeneric(ast.alternate, retArr);
		retArr.push(')');
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for to its *named function declaration*
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astFunctionDeclaration(ast, retArr) {
		if (this.onNestedFunction) {
			let returnType = this.getType(ast);
			if (returnType === 'LiteralInteger') {
				returnType = 'Number';
			}
			this.onNestedFunction(utils.getAstString(this.source, ast), returnType);
		}
		return retArr;
	}
	astFunctionExpression(ast, retArr) {
		return retArr;
	}
	astReturnStatement(ast, retArr) {
		return retArr;
	}
	astLiteral(ast, retArr) {
		this.literalTypes[`${ast.start},${ast.end}`] = 'Number';
		return retArr;
	}
	astBinaryExpression(ast, retArr) {
		return retArr;
	}
	astIdentifierExpression(ast, retArr) {
		return retArr;
	}
	astAssignmentExpression(ast, retArr) {
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *generic expression* statement
	 * @param {Object} esNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astExpressionStatement(esNode, retArr) {
		this.astGeneric(esNode.expression, retArr);
		retArr.push(';');
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for an *Empty* Statement
	 * @param {Object} eNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astEmptyStatement(eNode, retArr) {
		return retArr;
	}
	astBlockStatement(ast, retArr) {
		return retArr;
	}
	astIfStatement(ast, retArr) {
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *Break* Statement
	 * @param {Object} brNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astBreakStatement(brNode, retArr) {
		retArr.push('break;');
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *Continue* Statement
	 * @param {Object} crNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astContinueStatement(crNode, retArr) {
		retArr.push('continue;\n');
		return retArr;
	}
	astForStatement(ast, retArr) {
		return retArr;
	}
	astWhileStatement(ast, retArr) {
		return retArr;
	}
	astDoWhileStatement(ast, retArr) {
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *Variable Declaration*
	 * @param {Object} varDecNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astVariableDeclaration(varDecNode, retArr) {
		const declarations = varDecNode.declarations;
		if (!declarations || !declarations[0] || !declarations[0].init) {
			throw this.astErrorOutput('Unexpected expression', varDecNode);
		}
		const result = [];
		const firstDeclaration = declarations[0];
		const init = firstDeclaration.init;
		let type = this.isState('in-for-loop-init') ? 'Integer' : this.getType(init);
		if (type === 'LiteralInteger') {
			// We had the choice to go either float or int, choosing float
			type = 'Number';
		}
		const markupType = typeMap[type];
		if (!markupType) {
			throw this.astErrorOutput(`Markup type ${ markupType } not handled`, varDecNode);
		}
		let dependencies = this.getDependencies(firstDeclaration.init);
		this.declarations[firstDeclaration.id.name] = Object.freeze({
			type,
			dependencies,
			isSafe: dependencies.every(dependency => dependency.isSafe)
		});
		const initResult = [`${type} user_${firstDeclaration.id.name}=`];
		this.astGeneric(init, initResult);
		result.push(initResult.join(''));

		// first declaration is done, now any added ones setup
		for (let i = 1; i < declarations.length; i++) {
			const declaration = declarations[i];
			dependencies = this.getDependencies(declaration);
			this.declarations[declaration.id.name] = Object.freeze({
				type,
				dependencies,
				isSafe: false
			});
			this.astGeneric(declaration, result);
		}

		retArr.push(retArr, result.join(','));
		retArr.push(';');
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *Variable Declarator*
	 * @param {Object} iVarDecNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astVariableDeclarator(iVarDecNode, retArr) {
		this.astGeneric(iVarDecNode.id, retArr);
		if (iVarDecNode.init !== null) {
			retArr.push('=');
			this.astGeneric(iVarDecNode.init, retArr);
		}
		return retArr;
	}
	astThisExpression(ast, retArr) {
		return retArr;
	}
	astSequenceExpression(sNode, retArr) {
		for (let i = 0; i < sNode.expressions.length; i++) {
			if (i > 0) {
				retArr.push(',');
			}
			this.astGeneric(sNode.expressions, retArr);
		}
		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *Unary* Expression
	 * @param {Object} uNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astUnaryExpression(uNode, retArr) {
		if (uNode.prefix) {
			retArr.push(uNode.operator);
			this.astGeneric(uNode.argument, retArr);
		} else {
			this.astGeneric(uNode.argument, retArr);
			retArr.push(uNode.operator);
		}

		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *Update* Expression
	 * @param {Object} uNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astUpdateExpression(uNode, retArr) {
		if (uNode.prefix) {
			retArr.push(uNode.operator);
			this.astGeneric(uNode.argument, retArr);
		} else {
			this.astGeneric(uNode.argument, retArr);
			retArr.push(uNode.operator);
		}

		return retArr;
	}
	/**
	 * @desc Parses the abstract syntax tree for *Logical* Expression
	 * @param {Object} logNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astLogicalExpression(logNode, retArr) {
		retArr.push('(');
		this.astGeneric(logNode.left, retArr);
		retArr.push(logNode.operator);
		this.astGeneric(logNode.right, retArr);
		retArr.push(')');
		return retArr;
	}
	astMemberExpression(ast, retArr) {
		return retArr;
	}
	astCallExpression(ast, retArr) {
		return retArr;
	}
	astArrayExpression(ast, retArr) {
		return retArr;
	}

	getMemberExpressionDetails(ast) {
		if (ast.type !== 'MemberExpression') {
			throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
		}
		let name = null;
		let type = null;
		const variableSignature = this.getVariableSignature(ast);
		switch (variableSignature) {
			case 'value':
				return null;
			case 'this.thread.value':
			case 'this.output.value':
				return {
					signature: variableSignature,
					type: 'Integer',
					name: ast.property.name
				};
			case 'value[]':
				if (typeof ast.object.name !== 'string') {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				name = ast.object.name;
				return {
					name,
					origin: 'user',
					signature: variableSignature,
					type: this.getVariableType(name),
					xProperty: ast.property
				};
			case 'value[][]':
				if (typeof ast.object.object.name !== 'string') {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				name = ast.object.object.name;
				return {
					name,
					origin: 'user',
					signature: variableSignature,
					type: this.getVariableType(name),
					yProperty: ast.object.property,
					xProperty: ast.property,
				};
			case 'value[][][]':
				if (typeof ast.object.object.object.name !== 'string') {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				name = ast.object.object.object.name;
				return {
					name,
					origin: 'user',
					signature: variableSignature,
					type: this.getVariableType(name),
					zProperty: ast.object.object.property,
					yProperty: ast.object.property,
					xProperty: ast.property,
				};
			case 'value[][][][]':
				if (typeof ast.object.object.object.object.name !== 'string') {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				name = ast.object.object.object.object.name;
				return {
					name,
					origin: 'user',
					signature: variableSignature,
					type: this.getVariableType(name),
					zProperty: ast.object.object.property,
					yProperty: ast.object.property,
					xProperty: ast.property,
				};
			case 'value.value':
				if (typeof ast.property.name !== 'string') {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				if (this.isAstMathVariable(ast)) {
					name = ast.property.name;
					return {
						name,
						origin: 'Math',
						type: 'Number',
						signature: variableSignature,
					};
				}
				switch (ast.property.name) {
					case 'r':
					case 'g':
					case 'b':
					case 'a':
						name = ast.object.name;
						return {
							name,
							property: ast.property.name,
							origin: 'user',
							signature: variableSignature,
							type: 'Number'
						};
					default:
						throw this.astErrorOutput('Unexpected expression', ast);
				}
			case 'this.constants.value':
				if (typeof ast.property.name !== 'string') {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				name = ast.property.name;
				type = this.getConstantType(name);
				if (!type) {
					throw this.astErrorOutput('Constant has no type', ast);
				}
				return {
					name,
					type,
					origin: 'constants',
					signature: variableSignature,
				};
			case 'this.constants.value[]':
				if (typeof ast.object.property.name !== 'string') {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				name = ast.object.property.name;
				type = this.getConstantType(name);
				if (!type) {
					throw this.astErrorOutput('Constant has no type', ast);
				}
				return {
					name,
					type,
					origin: 'constants',
					signature: variableSignature,
					xProperty: ast.property,
				};
			case 'this.constants.value[][]':
				{
					if (typeof ast.object.object.property.name !== 'string') {
						throw this.astErrorOutput('Unexpected expression', ast);
					}
					name = ast.object.object.property.name;
					type = this.getConstantType(name);
					if (!type) {
						throw this.astErrorOutput('Constant has no type', ast);
					}
					return {
						name,
						type,
						origin: 'constants',
						signature: variableSignature,
						yProperty: ast.object.property,
						xProperty: ast.property,
					};
				}
			case 'this.constants.value[][][]':
				{
					if (typeof ast.object.object.object.property.name !== 'string') {
						throw this.astErrorOutput('Unexpected expression', ast);
					}
					name = ast.object.object.object.property.name;
					type = this.getConstantType(name);
					if (!type) {
						throw this.astErrorOutput('Constant has no type', ast);
					}
					return {
						name,
						type,
						origin: 'constants',
						signature: variableSignature,
						zProperty: ast.object.object.property,
						yProperty: ast.object.property,
						xProperty: ast.property,
					};
				}
			case 'fn()[]':
			case '[][]':
				return {
					signature: variableSignature,
					property: ast.property,
				};
			default:
				throw this.astErrorOutput('Unexpected expression', ast);
		}
	}

	findIdentifierOrigin(astToFind) {
		const stack = [this.ast];

		while (stack.length > 0) {
			const atNode = stack[0];
			if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
				return atNode;
			}
			stack.shift();
			if (atNode.argument) {
				stack.push(atNode.argument);
			} else if (atNode.body) {
				stack.push(atNode.body);
			} else if (atNode.declarations) {
				stack.push(atNode.declarations);
			} else if (Array.isArray(atNode)) {
				for (let i = 0; i < atNode.length; i++) {
					stack.push(atNode[i]);
				}
			}
		}
		return null;
	}

	findLastReturn(ast) {
		const stack = [ast || this.ast];

		while (stack.length > 0) {
			const atNode = stack.pop();
			if (atNode.type === 'ReturnStatement') {
				return atNode;
			}
			if (atNode.argument) {
				stack.push(atNode.argument);
			} else if (atNode.body) {
				stack.push(atNode.body);
			} else if (atNode.declarations) {
				stack.push(atNode.declarations);
			} else if (Array.isArray(atNode)) {
				for (let i = 0; i < atNode.length; i++) {
					stack.push(atNode[i]);
				}
			} else if (atNode.consequent) {
				stack.push(atNode.consequent);
			}
		}
		return null;
	}

	getInternalVariableName(name) {
		if (!this._internalVariableNames.hasOwnProperty(name)) {
			this._internalVariableNames[name] = 0;
		}
		this._internalVariableNames[name]++;
		if (this._internalVariableNames[name] === 1) {
			return name;
		}
		return name + this._internalVariableNames[name];
	}

	varWarn() {
		console.warn('var declarations are deprecated, weird things happen when falling back to CPU because var scope differs in javascript than in most languages.  Use const or let');
	}
}

const typeLookupMap = {
	'Array': 'Number',
	'Array(2)': 'Number',
	'Array(3)': 'Number',
	'Array(4)': 'Number',
	'Array2D': 'Number',
	'Array3D': 'Number',
	'Input': 'Number',
	'HTMLImage': 'Array(4)',
	'HTMLImageArray': 'Array(4)',
	'NumberTexture': 'Number',
	'MemoryOptimizedNumberTexture': 'Number',
	'ArrayTexture(1)': 'Number',
	'ArrayTexture(2)': 'Array(2)',
	'ArrayTexture(3)': 'Array(3)',
	'ArrayTexture(4)': 'Array(4)',
};

module.exports = {
	FunctionNode
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/gl-kernel.js":
/*!******************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/gl-kernel.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	Kernel
} = __webpack_require__(/*! ./kernel */ "./node_modules/gpu.js/src/backend/kernel.js");

const {
	Texture
} = __webpack_require__(/*! ../texture */ "./node_modules/gpu.js/src/texture.js");

const {
	utils
} = __webpack_require__(/*! ../utils */ "./node_modules/gpu.js/src/utils.js");

/**
 * @abstract
 */
class GLKernel extends Kernel {
	static get mode() {
		return 'gpu';
	}

	static getIsFloatRead() {
		const kernelString = `function kernelFunction() {
			return 1;
		}`;
		const kernel = new this(kernelString, {
			context: this.testContext,
			canvas: this.testCanvas,
			validate: false,
			output: [1],
			precision: 'single',
			//TODO: not sure how to handle?
			floatOutputForce: true,
			returnType: 'Number'
		});
		const result = kernel.run();
		kernel.destroy(true);
		return result[0] === 1;
	}

	static getIsIntegerDivisionAccurate() {
		function kernelFunction(v1, v2) {
			return v1[this.thread.x] / v2[this.thread.x];
		}
		const kernel = new this(kernelFunction.toString(), {
			context: this.testContext,
			canvas: this.testCanvas,
			validate: false,
			output: [2],
			returnType: 'Number',
			precision: 'unsigned',
		});
		const result = kernel.run([6, 6030401], [3, 3991]);
		kernel.destroy(true);
		// have we not got whole numbers for 6/3 or 6030401/3991
		// add more here if others see this problem
		return result[0] === 2 && result[1] === 1511;
	}

	/**
	 * @abstract
	 */
	static get testCanvas() {
		throw new Error(`"testCanvas" not defined on ${ this.name }`);
	}

	/**
	 * @abstract
	 */
	static get testContext() {
		throw new Error(`"testContext" not defined on ${ this.name }`);
	}

	/**
	 * @abstract
	 */
	static get features() {
		throw new Error(`"features" not defined on ${ this.name }`);
	}

	/**
	 * @abstract
	 */
	static setupFeatureChecks() {
		throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
	}

	/**
	 * @desc Fix division by factor of 3 FP accuracy bug
	 * @param {Boolean} fix - should fix
	 */
	setFixIntegerDivisionAccuracy(fix) {
		this.fixIntegerDivisionAccuracy = fix;
		return this;
	}

	/**
	 * @desc Toggle output mode
	 * @param {String} flag - 'single' or 'unsigned'
	 */
	setPrecision(flag) {
		this.precision = flag;
		return this;
	}

	// TODO: not sure how to handle
	setFloatOutputForce(flag) {
		this.floatOutputForce = flag;
		return this;
	}

	/**
	 * @desc Toggle texture output mode
	 * @param {Boolean} flag - true to enable floatTextures
	 */
	setFloatTextures(flag) {
		utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
		this.floatTextures = flag;
		return this;
	}

	setOptimizeFloatMemory(flag) {
		this.optimizeFloatMemory = flag;
		return this;
	}

	/**
	 * A highly readable very forgiving micro-parser for a glsl function that gets argument types
	 * @param {String} source
	 * @returns {{argumentTypes: String[], argumentNames: String[]}}
	 */
	static nativeFunctionArguments(source) {
		const argumentTypes = [];
		const argumentNames = [];
		const states = [];
		const isStartingVariableName = /^[a-zA-Z_]/;
		const isVariableChar = /[a-zA-Z_0-9]/;
		let i = 0;
		let argumentName = null;
		let argumentType = null;
		while (i < source.length) {
			const char = source[i];
			const nextChar = source[i + 1];
			const state = states.length > 0 ? states[states.length - 1] : null;

			// begin MULTI_LINE_COMMENT handling
			if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
				states.push('MULTI_LINE_COMMENT');
				i += 2;
				continue;
			} else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
				states.pop();
				i += 2;
				continue;
			}
			// end MULTI_LINE_COMMENT handling

			// begin COMMENT handling
			else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
				states.push('COMMENT');
				i += 2;
				continue;
			} else if (state === 'COMMENT' && char === '\n') {
				states.pop();
				i++;
				continue;
			}
			// end COMMENT handling

			// being FUNCTION_ARGUMENTS handling
			else if (state === null && char === '(') {
				states.push('FUNCTION_ARGUMENTS');
				i++;
				continue;
			} else if (state === 'FUNCTION_ARGUMENTS') {
				if (char === ')') {
					states.pop();
					break;
				}
				if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
					states.push('DECLARE_VARIABLE');
					argumentType = 'float';
					argumentName = '';
					i += 6;
					continue;
				} else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
					states.push('DECLARE_VARIABLE');
					argumentType = 'int';
					argumentName = '';
					i += 4;
					continue;
				} else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
					states.push('DECLARE_VARIABLE');
					argumentType = 'vec2';
					argumentName = '';
					i += 5;
					continue;
				} else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
					states.push('DECLARE_VARIABLE');
					argumentType = 'vec3';
					argumentName = '';
					i += 5;
					continue;
				} else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
					states.push('DECLARE_VARIABLE');
					argumentType = 'vec4';
					argumentName = '';
					i += 5;
					continue;
				}
			}
			// end FUNCTION_ARGUMENTS handling

			// begin DECLARE_VARIABLE handling
			else if (state === 'DECLARE_VARIABLE') {
				if (argumentName === '') {
					if (char === ' ') {
						i++;
						continue;
					}
					if (!isStartingVariableName.test(char)) {
						throw new Error('variable name is not expected string');
					}
				}
				argumentName += char;
				if (!isVariableChar.test(nextChar)) {
					states.pop();
					argumentNames.push(argumentName);
					argumentTypes.push(typeMap[argumentType]);
				}
			}
			// end DECLARE_VARIABLE handling

			// Progress to next character
			i++;
		}
		if (states.length > 0) {
			throw new Error('GLSL function was not parsable');
		}
		return {
			argumentNames,
			argumentTypes,
		};
	}

	static nativeFunctionReturnType(source) {
		return typeMap[source.match(/int|float|vec[2-4]/)[0]];
	}

	static combineKernels(combinedKernel, lastKernel) {
		combinedKernel.apply(null, arguments);
		const {
			texSize,
			context,
			threadDim
		} = lastKernel.texSize;
		let result;
		if (lastKernel.precision === 'single') {
			const w = texSize[0];
			const h = Math.ceil(texSize[1] / 4);
			result = new Float32Array(w * h * 4 * 4);
			context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
		} else {
			const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
			context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
			result = new Float32Array(bytes.buffer);
		}

		result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

		if (lastKernel.output.length === 1) {
			return result;
		} else if (lastKernel.output.length === 2) {
			return utils.splitArray(result, lastKernel.output[0]);
		} else if (lastKernel.output.length === 3) {
			const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
			return cube.map(function(x) {
				return utils.splitArray(x, lastKernel.output[0]);
			});
		}
	}

	constructor(source, settings) {
		super(source, settings);
		this.texSize = null;
		// TODO: not sure how to handle
		this.floatOutputForce = null;
		this.fixIntegerDivisionAccuracy = null;
		this.translatedSource = null;
		this.renderStrategy = null;
		this.compiledFragmentShader = null;
		this.compiledVertexShader = null;

		this.optimizeFloatMemory = null;
	}

	translateSource() {
		throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
	}

	pickRenderStrategy(args) {
		// TODO: replace boolean returns with setting a state that belongs on this that represents the need for fallback
		if (this.graphical) return;
		if (this.precision === 'unsigned') {
			switch (this.returnType) {
				case 'LiteralInteger':
				case 'Float':
				case 'Number':
				case 'Integer':
					if (this.pipeline) {
						this.renderStrategy = renderStrategy.PackedTexture;
						this.renderOutput = this.renderTexture;
					} else if (this.output[2] > 0) {
						this.renderStrategy = renderStrategy.PackedPixelTo3DFloat;
						this.renderOutput = this.render3DPackedFloat;
					} else if (this.output[1] > 0) {
						this.renderStrategy = renderStrategy.PackedPixelTo2DFloat;
						this.renderOutput = this.render2DPackedFloat;
					} else {
						this.renderStrategy = renderStrategy.PackedPixelToFloat;
						this.renderOutput = this.renderPackedFloat;
					}
					return true;
				case 'Array(2)':
				case 'Array(3)':
				case 'Array(4)':
					this.onRequestFallback(args);
					return false;
			}
		} else if (this.precision === 'single') {
			if (this.pipeline) {
				this.renderStrategy = renderStrategy.FloatTexture;
				this.renderOutput = this.renderTexture;
				return true;
			}
			switch (this.returnType) {
				case 'LiteralInteger':
				case 'Float':
				case 'Number':
				case 'Integer':
					if (this.output[2] > 0) {
						if (this.optimizeFloatMemory) {
							this.renderStrategy = renderStrategy.MemoryOptimizedFloatPixelToMemoryOptimized3DFloat;
							this.renderOutput = this.renderMemoryOptimized3DFloat;
						} else {
							this.renderStrategy = renderStrategy.FloatPixelTo3DFloat;
							this.renderOutput = this.render3DFloat;
						}
					} else if (this.output[1] > 0) {
						if (this.optimizeFloatMemory) {
							this.renderStrategy = renderStrategy.MemoryOptimizedFloatPixelToMemoryOptimized2DFloat;
							this.renderOutput = this.renderMemoryOptimized2DFloat;
						} else {
							this.renderStrategy = renderStrategy.FloatPixelTo2DFloat;
							this.renderOutput = this.render2DFloat;
						}
					} else {
						if (this.optimizeFloatMemory) {
							this.renderStrategy = renderStrategy.MemoryOptimizedFloatPixelToMemoryOptimizedFloat;
							this.renderOutput = this.renderMemoryOptimizedFloat;
						} else {
							this.renderStrategy = renderStrategy.FloatPixelToFloat;
							this.renderOutput = this.renderFloat;
						}
					}
					return true;
				case 'Array(2)':
					if (this.output[2] > 0) {
						this.renderStrategy = renderStrategy.FloatPixelTo3DArray2;
						this.renderOutput = this.render3DArray2;
					} else if (this.output[1] > 0) {
						this.renderStrategy = renderStrategy.FloatPixelTo2DArray2;
						this.renderOutput = this.render2DArray2;
					} else {
						this.renderStrategy = renderStrategy.FloatPixelToArray2;
						this.renderOutput = this.renderArray2;
					}
					return true;
				case 'Array(3)':
					if (this.output[2] > 0) {
						this.renderStrategy = renderStrategy.FloatPixelTo3DArray3;
						this.renderOutput = this.render3DArray3;
					} else if (this.output[1] > 0) {
						this.renderStrategy = renderStrategy.FloatPixelTo2DArray3;
						this.renderOutput = this.render2DArray3;
					} else {
						this.renderStrategy = renderStrategy.FloatPixelToArray3;
						this.renderOutput = this.renderArray3;
					}
					return true;
				case 'Array(4)':
					if (this.output[2] > 0) {
						this.renderStrategy = renderStrategy.FloatPixelTo3DArray4;
						this.renderOutput = this.render3DArray4;
					} else if (this.output[1] > 0) {
						this.renderStrategy = renderStrategy.FloatPixelTo2DArray4;
						this.renderOutput = this.render2DArray4;
					} else {
						this.renderStrategy = renderStrategy.FloatPixelToArray4;
						this.renderOutput = this.renderArray4;
					}
					return true;
			}
		} else {
			throw new Error(`unhandled precision of "${this.precision}"`);
		}

		throw new Error(`unhandled return type "${this.returnType}"`);
	}

	/**
	 * @abstract
	 * @returns String
	 */
	getKernelString() {
		throw new Error(`abstract method call`);
	}

	getMainResultTexture() {
		switch (this.returnType) {
			case 'LiteralInteger':
			case 'Float':
			case 'Integer':
			case 'Number':
				return this.getMainResultNumberTexture();
			case 'Array(2)':
				return this.getMainResultArray2Texture();
			case 'Array(3)':
				return this.getMainResultArray3Texture();
			case 'Array(4)':
				return this.getMainResultArray4Texture();
			default:
				throw new Error(`unhandled returnType type ${ this.returnType }`);
		}
	}

	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultKernelNumberTexture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultSubKernelNumberTexture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultKernelArray2Texture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultSubKernelArray2Texture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultKernelArray3Texture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultSubKernelArray3Texture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultKernelArray4Texture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultSubKernelArray4Texture() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultGraphical() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultMemoryOptimizedFloats() {
		throw new Error(`abstract method call`);
	}
	/**
	 * @abstract
	 * @returns String[]
	 */
	getMainResultPackedPixels() {
		throw new Error(`abstract method call`);
	}

	getMainResultString() {
		if (this.graphical) {
			return this.getMainResultGraphical();
		} else if (this.precision === 'single') {
			if (this.optimizeFloatMemory) {
				return this.getMainResultMemoryOptimizedFloats();
			}
			return this.getMainResultTexture();
		} else {
			return this.getMainResultPackedPixels();
		}
	}

	getMainResultNumberTexture() {
		return utils.linesToString(this.getMainResultKernelNumberTexture()) +
			utils.linesToString(this.getMainResultSubKernelNumberTexture());
	}

	getMainResultArray2Texture() {
		return utils.linesToString(this.getMainResultKernelArray2Texture()) +
			utils.linesToString(this.getMainResultSubKernelArray2Texture());
	}

	getMainResultArray3Texture() {
		return utils.linesToString(this.getMainResultKernelArray3Texture()) +
			utils.linesToString(this.getMainResultSubKernelArray3Texture());
	}

	getMainResultArray4Texture() {
		return utils.linesToString(this.getMainResultKernelArray4Texture()) +
			utils.linesToString(this.getMainResultSubKernelArray4Texture());
	}

	getReturnTextureType() {
		if (this.graphical) {
			return 'ArrayTexture(4)';
		}
		if (this.precision === 'single') {
			switch (this.returnType) {
				case 'Float':
				case 'Number':
				case 'Integer':
					if (this.optimizeFloatMemory) {
						return 'MemoryOptimizedNumberTexture';
					} else {
						return 'ArrayTexture(1)';
					}
				case 'Array(2)':
					return 'ArrayTexture(2)';
				case 'Array(3)':
					return 'ArrayTexture(3)';
				case 'Array(4)':
					return 'ArrayTexture(4)';
				default:
					throw new Error(`unsupported returnType ${this.returnType}`);
			}
		} else {
			switch (this.returnType) {
				case 'Float':
				case 'Number':
				case 'Integer':
					return 'NumberTexture';
				case 'Array(2)':
				case 'Array(3)':
				case 'Array(4)':
				default:
					throw new Error(`unsupported returnType ${ this.returnType }`);
			}
		}
	}

	renderTexture() {
		return new Texture({
			texture: this.outputTexture,
			size: this.texSize,
			dimensions: this.threadDim,
			output: this.output,
			context: this.context,
			gpu: this.gpu,
			type: this.getReturnTextureType(),
		});
	}
	readPackedPixelsToUint8Array() {
		if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
		const {
			texSize,
			context: gl
		} = this;
		const result = new Uint8Array(texSize[0] * texSize[1] * 4);
		gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
		return result;
	}
	readPackedPixelsToFloat32Array() {
		return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
	}
	readFloatPixelsToFloat32Array() {
		if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
		const {
			texSize,
			context: gl
		} = this;
		const w = texSize[0];
		const h = texSize[1];
		const result = new Float32Array(w * h * 4);
		gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
		return result;
	}
	readMemoryOptimizedFloatPixelsToFloat32Array() {
		if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
		const {
			texSize,
			context: gl
		} = this;
		const w = texSize[0];
		const h = texSize[1];
		const result = new Float32Array(w * h * 4);
		gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
		return result;
	}
	renderPackedFloat() {
		const [xMax] = this.output;
		return this.readPackedPixelsToFloat32Array().subarray(0, xMax);
	}
	render2DPackedFloat() {
		const pixels = this.readPackedPixelsToFloat32Array();
		const [xMax, yMax] = this.output;
		const yResults = new Array(yMax);
		for (let y = 0; y < yMax; y++) {
			const xStart = y * xMax;
			const xEnd = xStart + xMax;
			yResults[y] = pixels.subarray(xStart, xEnd);
		}
		return yResults;
	}
	render3DPackedFloat() {
		const pixels = this.readPackedPixelsToFloat32Array();
		const [xMax, yMax, zMax] = this.output;
		const zResults = new Array(zMax);
		for (let z = 0; z < zMax; z++) {
			const yResults = new Array(yMax);
			for (let y = 0; y < yMax; y++) {
				const xStart = (z * yMax * xMax) + y * xMax;
				const xEnd = xStart + xMax;
				yResults[y] = pixels.subarray(xStart, xEnd);
			}
			zResults[z] = yResults;
		}
		return zResults;
	}
	renderFloat() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax] = this.output;
		const xResults = new Float32Array(xMax);
		let i = 0;
		for (let x = 0; x < xMax; x++) {
			xResults[x] = pixels[i];
			i += 4;
		}
		return xResults;
	}
	renderMemoryOptimizedFloat() {
		const pixels = this.readMemoryOptimizedFloatPixelsToFloat32Array();
		const [xMax] = this.output;
		return pixels.subarray(0, xMax);
	}
	render2DFloat() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax] = this.output;
		const yResults = new Array(yMax);
		let i = 0;
		for (let y = 0; y < yMax; y++) {
			const xResults = new Float32Array(xMax);
			for (let x = 0; x < xMax; x++) {
				xResults[x] = pixels[i];
				i += 4;
			}
			yResults[y] = xResults;
		}
		return yResults;
	}
	renderMemoryOptimized2DFloat() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax] = this.output;
		const yResults = new Array(yMax);
		for (let y = 0; y < yMax; y++) {
			const offset = y * xMax;
			yResults[y] = pixels.subarray(offset, offset + xMax);
		}
		return yResults;
	}
	render3DFloat() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax, zMax] = this.output;
		const zResults = new Array(zMax);
		let i = 0;
		for (let z = 0; z < zMax; z++) {
			const yResults = new Array(yMax);
			for (let y = 0; y < yMax; y++) {
				const xResults = new Float32Array(xMax);
				for (let x = 0; x < xMax; x++) {
					xResults[x] = pixels[i];
					i += 4;
				}
				yResults[y] = xResults;
			}
			zResults[z] = yResults;
		}
		return zResults;
	}
	renderMemoryOptimized3DFloat() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax, zMax] = this.output;
		const zResults = new Array(zMax);
		for (let z = 0; z < zMax; z++) {
			const yResults = new Array(yMax);
			for (let y = 0; y < yMax; y++) {
				const offset = (z * yMax * xMax) + (y * xMax);
				yResults[y] = pixels.subarray(offset, offset + xMax);
			}
			zResults[z] = yResults;
		}
		return zResults;
	}
	renderArray2() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax] = this.output;
		const xResults = new Array(xMax);
		const xResultsMax = xMax * 4;
		let i = 0;
		for (let x = 0; x < xResultsMax; x += 4) {
			xResults[i++] = pixels.subarray(x, x + 2);
		}
		return xResults;
	}
	render2DArray2() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax] = this.output;
		const yResults = new Array(yMax);
		const XResultsMax = xMax * 4;
		for (let y = 0; y < yMax; y++) {
			const xResults = new Array(xMax);
			let i = 0;
			for (let x = 0; x < XResultsMax; x += 4) {
				xResults[i++] = pixels.subarray(x, x + 2);
			}
			yResults[y] = xResults;
		}
		return yResults;
	}
	render3DArray2() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax, zMax] = this.output;
		const xResultsMax = xMax * 4;
		const zResults = new Array(zMax);
		for (let z = 0; z < zMax; z++) {
			const yResults = new Array(yMax);
			for (let y = 0; y < yMax; y++) {
				const xResults = new Array(xMax);
				let i = 0;
				for (let x = 0; x < xResultsMax; x += 4) {
					xResults[i++] = pixels.subarray(x, x + 2);
				}
				yResults[y] = xResults;
			}
			zResults[z] = yResults;
		}
		return zResults;
	}
	renderArray3() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax] = this.output;
		const xResults = new Array(xMax);
		const xResultsMax = xMax * 4;
		let i = 0;
		for (let x = 0; x < xResultsMax; x += 4) {
			xResults[i++] = pixels.subarray(x, x + 3);
		}
		return xResults;
	}
	render2DArray3() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax] = this.output;
		const xMaxResults = xMax * 4;
		const yResults = new Array(yMax);
		for (let y = 0; y < yMax; y++) {
			const xResults = new Array(xMax);
			let i = 0;
			for (let x = 0; x < xMaxResults; x += 4) {
				xResults[i++] = pixels.subarray(x, x + 3);
			}
			yResults[y] = xResults;
		}
		return yResults;
	}
	render3DArray3() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax, zMax] = this.output;
		const xMaxResults = xMax * 4;
		const zResults = new Array(zMax);
		for (let z = 0; z < zMax; z++) {
			const yResults = new Array(yMax);
			for (let y = 0; y < yMax; y++) {
				const xResults = new Array(xMax);
				let i = 0;
				for (let x = 0; x < xMaxResults; x += 4) {
					xResults[i++] = pixels.subarray(x, x + 3);
				}
				yResults[y] = xResults;
			}
			zResults[z] = yResults;
		}
		return zResults;
	}
	renderArray4() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax] = this.output;
		const xResults = new Array(xMax);
		const xResultsMax = xMax * 4;
		let i = 0;
		for (let x = 0; x < xResultsMax; x += 4) {
			xResults[i++] = pixels.subarray(x, x + 4);
		}
		return xResults;
	}
	render2DArray4() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax] = this.output;
		const xMaxResult = xMax * 4;
		const yResults = new Array(yMax);
		for (let y = 0; y < yMax; y++) {
			const xResults = new Array(xMax);
			let i = 0;
			for (let x = 0; x < xMaxResult; x += 4) {
				xResults[i++] = pixels.subarray(x, x + 4);
			}
			yResults[y] = xResults;
		}
		return yResults;
	}
	render3DArray4() {
		const pixels = this.readFloatPixelsToFloat32Array();
		const [xMax, yMax, zMax] = this.output;
		const xResultsMap = xMax * 4;
		const zResults = new Array(zMax);
		for (let z = 0; z < zMax; z++) {
			const yResults = new Array(yMax);
			for (let y = 0; y < yMax; y++) {
				const xResults = new Array(xMax);
				let i = 0;
				for (let x = 0; x < xResultsMap; x += 4) {
					xResults[i++] = pixels.subarray(x, x + 4);
				}
				yResults[y] = xResults;
			}
			zResults[z] = yResults;
		}
		return zResults;
	}
	getPixels() {
		const {
			context: gl,
			output
		} = this;
		const [width, height] = output;
		const pixels = new Uint8Array(width * height * 4);
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
		return pixels;
	}
}

const renderStrategy = Object.freeze({
	PackedPixelToUint8Array: Symbol('PackedPixelToUint8Array'),
	PackedPixelToFloat: Symbol('PackedPixelToFloat'),
	PackedPixelTo2DFloat: Symbol('PackedPixelTo2DFloat'),
	PackedPixelTo3DFloat: Symbol('PackedPixelTo3DFloat'),
	PackedTexture: Symbol('PackedTexture'),
	FloatPixelToFloat32Array: Symbol('FloatPixelToFloat32Array'),
	FloatPixelToFloat: Symbol('FloatPixelToFloat'),
	FloatPixelTo2DFloat: Symbol('FloatPixelTo2DFloat'),
	FloatPixelTo3DFloat: Symbol('FloatPixelTo3DFloat'),
	FloatPixelToArray2: Symbol('FloatPixelToArray2'),
	FloatPixelTo2DArray2: Symbol('FloatPixelTo2DArray2'),
	FloatPixelTo3DArray2: Symbol('FloatPixelTo3DArray2'),
	FloatPixelToArray3: Symbol('FloatPixelToArray3'),
	FloatPixelTo2DArray3: Symbol('FloatPixelTo2DArray3'),
	FloatPixelTo3DArray3: Symbol('FloatPixelTo3DArray3'),
	FloatPixelToArray4: Symbol('FloatPixelToArray4'),
	FloatPixelTo2DArray4: Symbol('FloatPixelTo2DArray4'),
	FloatPixelTo3DArray4: Symbol('FloatPixelTo3DArray4'),
	FloatTexture: Symbol('FloatTexture'),
	MemoryOptimizedFloatPixelToMemoryOptimizedFloat: Symbol('MemoryOptimizedFloatPixelToFloat'),
	MemoryOptimizedFloatPixelToMemoryOptimized2DFloat: Symbol('MemoryOptimizedFloatPixelTo2DFloat'),
	MemoryOptimizedFloatPixelToMemoryOptimized3DFloat: Symbol('MemoryOptimizedFloatPixelTo3DFloat'),
});

const typeMap = {
	int: 'Integer',
	float: 'Number',
	vec2: 'Array(2)',
	vec3: 'Array(3)',
	vec4: 'Array(4)',
};

module.exports = {
	GLKernel,
	renderStrategy
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/headless-gl/kernel.js":
/*!***************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/headless-gl/kernel.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const getContext = __webpack_require__(/*! gl */ "./node_modules/gl/browser_index.js");
const {
	WebGLKernel
} = __webpack_require__(/*! ../web-gl/kernel */ "./node_modules/gpu.js/src/backend/web-gl/kernel.js");

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

class HeadlessGLKernel extends WebGLKernel {
	static get isSupported() {
		if (isSupported !== null) return isSupported;
		this.setupFeatureChecks();
		isSupported = testContext !== null;
		return isSupported;
	}

	static setupFeatureChecks() {
		testCanvas = null;
		testExtensions = null;
		if (typeof getContext !== 'function') return;
		try { // just in case, edge cases
			testContext = getContext(2, 2, {
				preserveDrawingBuffer: true
			});
			if (!testContext || !testContext.getExtension) return;
			testExtensions = {
				STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
				STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
				OES_texture_float: testContext.getExtension('OES_texture_float'),
				OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
				OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
				WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
			};
			features = this.getFeatures();
		} catch (e) {}
	}

	static isContextMatch(context) {
		try {
			return context.getParameter(context.RENDERER) === 'ANGLE';
		} catch (e) {
			return false;
		}
	}

	static getFeatures() {
		const isDrawBuffers = this.getIsDrawBuffers();
		return Object.freeze({
			isFloatRead: this.getIsFloatRead(),
			isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
			isTextureFloat: this.getIsTextureFloat(),
			isDrawBuffers,
			kernelMap: isDrawBuffers
		});
	}

	static getIsTextureFloat() {
		return Boolean(testExtensions.OES_texture_float);
	}

	static getIsDrawBuffers() {
		return Boolean(testExtensions.WEBGL_draw_buffers);
	}

	static get testCanvas() {
		return testCanvas;
	}

	static get testContext() {
		return testContext;
	}

	static get features() {
		return features;
	}

	initCanvas() {
		return {};
	}

	initContext() {
		const context = getContext(2, 2, {
			preserveDrawingBuffer: true
		});
		return context;
	}

	initExtensions() {
		this.extensions = {
			STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
			STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
			OES_texture_float: this.context.getExtension('OES_texture_float'),
			OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
			OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
			WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
		};
	}

	destroyExtensions() {
		this.extensions.STACKGL_resize_drawingbuffer = null;
		this.extensions.STACKGL_destroy_context = null;
		this.extensions.OES_texture_float = null;
		this.extensions.OES_texture_float_linear = null;
		this.extensions.OES_element_index_uint = null;
		this.extensions.WEBGL_draw_buffers = null;
	}

	static destroyContext(context) {
		const extension = context.getExtension('STACKGL_destroy_context');
		if (extension && extension.destroy) {
			extension.destroy();
		}
	}
}

module.exports = {
	HeadlessGLKernel
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/kernel.js":
/*!***************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/kernel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	utils
} = __webpack_require__(/*! ../utils */ "./node_modules/gpu.js/src/utils.js");
const {
	Input
} = __webpack_require__(/*! ../input */ "./node_modules/gpu.js/src/input.js");

class Kernel {
	/**
	 * @type {Boolean}
	 */
	static get isSupported() {
		throw new Error(`"isSupported" not implemented on ${ this.name }`);
	}

	/**
	 * @type {Boolean}
	 */
	static isContextMatch(context) {
		throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
	}

	static getFeatures() {
		throw new Error(`"getFeatures" not implemented on ${ this.name }`);
	}

	static destroyContext(context) {
		throw new Error(`"destroyContext" called on ${ this.name }`);
	}

	static nativeFunctionArguments() {
		throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
	}

	static nativeFunctionReturnType() {
		throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
	}

	static combineKernels() {
		throw new Error(`"combineKernels" called on ${ this.name }`);
	}

	/**
	 *
	 * @param {string|object} source
	 * @param [settings]
	 */
	constructor(source, settings) {
		if (typeof source !== 'object') {
			if (typeof source !== 'string') {
				throw new Error('source not a string');
			}
			if (!utils.isFunctionString(source)) {
				throw new Error('source not a function string');
			}
		}

		this.onRequestFallback = null;

		/**
		 * Name of the arguments found from parsing source argument
		 * @type {String[]}
		 */
		this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
		this.argumentTypes = null;
		this.argumentSizes = null;
		this.argumentBitRatios = null;
		this.argumentsLength = 0;
		this.constantsLength = 0;


		/**
		 * The function source
		 * @type {String}
		 */
		this.source = source;

		/**
		 * The size of the kernel's output
		 * @type {Number[]}
		 */
		this.output = null;

		/**
		 * Debug mode
		 * @type {Boolean}
		 */
		this.debug = false;

		/**
		 * Graphical mode
		 * @type {Boolean}
		 */
		this.graphical = false;

		/**
		 * Maximum loops when using argument values to prevent infinity
		 * @type {Number}
		 */
		this.loopMaxIterations = 0;

		/**
		 * Constants used in kernel via `this.constants`
		 * @type {Object}
		 */
		this.constants = null;
		this.constantTypes = null;
		this.constantBitRatios = null;
		this.hardcodeConstants = false;

		/**
		 *
		 * @type {Object}
		 */
		this.canvas = null;

		/**
		 *
		 * @type {Object}
		 */
		this.context = null;

		/**
		 *
		 * @type {GPU}
		 */
		this.gpu = null;

		/**
		 *
		 * @type {IGPUFunction[]}
		 */
		this.functions = null;

		/**
		 *
		 * @type {IGPUNativeFunction[]}
		 */
		this.nativeFunctions = null;

		/**
		 *
		 * @type {ISubKernel[]}
		 */
		this.subKernels = null;

		/**
		 *
		 * @type {Boolean}
		 */
		this.validate = true;

		/**
		 * Enforces kernel to write to a new array or texture on run
		 * @type {Boolean}
		 */
		this.immutable = false;

		/**
		 * Enforces kernel to write to a texture on run
		 * @type {Boolean}
		 */
		this.pipeline = false;
		this.precision = null;

		this.plugins = null;

		this.returnType = null;
		this.leadingReturnStatement = null;
		this.followingReturnStatement = null;
	}

	mergeSettings(settings) {
		for (let p in settings) {
			if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
			if (p === 'output') {
				if (!Array.isArray(settings.output)) {
					this.setOutput(settings.output); // Flatten output object
					continue;
				}
			} else if (p === 'functions' && typeof settings.functions[0] === 'function') {
				this.functions = settings.functions.map(source => utils.functionToIFunction(source));
				continue;
			}
			this[p] = settings[p];
		}

		if (!this.canvas) this.canvas = this.initCanvas();
		if (!this.context) this.context = this.initContext();
		if (!this.plugins) this.plugins = this.initPlugins(settings);
	}
	/**
	 * @desc Builds the Kernel, by compiling Fragment and Vertical Shaders,
	 * and instantiates the program.
	 * @abstract
	 */
	build() {
		throw new Error(`"build" not defined on ${ this.constructor.name }`);
	}

	/**
	 * @desc Run the kernel program, and send the output to renderOutput
	 * <p> This method calls a helper method *renderOutput* to return the result. </p>
	 * @returns {Float32Array|Float32Array[]|Float32Array[][]|void} Result The final output of the program, as float, and as Textures for reuse.
	 * @abstract
	 */
	run() {
		throw new Error(`"run" not defined on ${ this.constructor.name }`)
	}

	/**
	 * @abstract
	 * @return {Object}
	 */
	initCanvas() {
		throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
	}

	/**
	 * @abstract
	 * @return {Object}
	 */
	initContext() {
		throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
	}

	/**
	 * @param {IFunctionSettings} settings
	 * @return {Object};
	 * @abstract
	 */
	initPlugins(settings) {
		throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
	}

	/**
	 * @desc Setup the parameter types for the parameters
	 * supplied to the Kernel function
	 *
	 * @param {IArguments} args - The actual parameters sent to the Kernel
	 */
	setupArguments(args) {
		if (!this.argumentTypes) {
			this.argumentTypes = [];
			for (let i = 0; i < args.length; i++) {
				const argType = utils.getVariableType(args[i]);
				this.argumentTypes.push(argType === 'Integer' ? 'Number' : argType);
			}
		}

		// setup sizes
		this.argumentSizes = new Array(args.length);
		this.argumentBitRatios = new Int32Array(args.length);

		for (let i = 0; i < args.length; i++) {
			const arg = args[i];
			this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
			this.argumentBitRatios[i] = this.getBitRatio(arg);
		}

		if (this.argumentNames.length !== args.length) {
			throw new Error(`arguments are miss-aligned`);
		}
	}

	/**
	 * Setup constants
	 */
	setupConstants() {
		this.constantTypes = {};
		this.constantBitRatios = {};
		if (this.constants) {
			for (let p in this.constants) {
				this.constantTypes[p] = utils.getVariableType(this.constants[p]);
				this.constantBitRatios[p] = this.getBitRatio(this.constants[p]);
			}
		}
	}

	/**
	 *
	 * @param flag
	 * @returns {Kernel}
	 */
	setOptimizeFloatMemory(flag) {
		this.optimizeFloatMemory = flag;
		return this;
	}

	/**
	 * @desc Set output dimensions of the kernel function
	 * @param {Array|Object} output - The output array to set the kernel output size to
	 */
	setOutput(output) {
		if (output.hasOwnProperty('x')) {
			if (output.hasOwnProperty('y')) {
				if (output.hasOwnProperty('z')) {
					this.output = [output.x, output.y, output.z];
				} else {
					this.output = [output.x, output.y];
				}
			} else {
				this.output = [output.x];
			}
		} else {
			this.output = output;
		}
		return this;
	}

	/**
	 * @desc Toggle debug mode
	 * @param {Boolean} flag - true to enable debug
	 */
	setDebug(flag) {
		this.debug = flag;
		return this;
	}

	/**
	 * @desc Toggle graphical output mode
	 * @param {Boolean} flag - true to enable graphical output
	 */
	setGraphical(flag) {
		this.graphical = flag;
		return this;
	}

	/**
	 * @desc Set the maximum number of loop iterations
	 * @param {number} max - iterations count
	 */
	setLoopMaxIterations(max) {
		this.loopMaxIterations = max;
		return this;
	}

	/**
	 * @desc Set Constants
	 */
	setConstants(constants) {
		this.constants = constants;
		return this;
	}

	/**
	 *
	 * @param {IFunction[]|KernelFunction[]} functions
	 * @returns {Kernel}
	 */
	setFunctions(functions) {
		if (typeof functions[0] === 'function') {
			this.functions = functions.map(source => utils.functionToIFunction(source));
		} else {
			this.functions = functions;
		}
		return this;
	}

	/**
	 * Set writing to texture on/off
	 * @param flag
	 * @returns {Kernel}
	 */
	setPipeline(flag) {
		this.pipeline = flag;
		return this;
	}

	/**
	 * Set precision to 'unsigned' or 'single'
	 * @param {String} flag 'unsigned' or 'single'
	 * @returns {Kernel}
	 */
	setPrecision(flag) {
		this.precision = flag;
		return this;
	}

	setOutputToTexture(flag) {
		utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
		this.pipeline = flag;
		return this;
	}

	/**
	 * Set to immutable
	 * @param flag
	 * @returns {Kernel}
	 */
	setImmutable(flag) {
		this.immutable = flag;
		return this;
	}

	/**
	 * @desc Bind the canvas to kernel
	 * @param {Object} canvas
	 */
	setCanvas(canvas) {
		this.canvas = canvas;
		return this;
	}

	/**
	 * @deprecated
	 * @returns {Object}
	 */
	getCanvas() {
		utils.warnDeprecated('method', 'getCanvas');
		return this.canvas;
	}

	/**
	 * @deprecated
	 * @returns {Object}
	 */
	getWebGl() {
		utils.warnDeprecated('method', 'getWebGl');
		return this.context;
	}

	/**
	 * @desc Bind the webGL instance to kernel
	 * @param {WebGLRenderingContext} context - webGl instance to bind
	 */
	setContext(context) {
		this.context = context;
		return this;
	}

	setArgumentTypes(argumentTypes) {
		this.argumentTypes = argumentTypes;
		return this;
	}

	requestFallback(args) {
		if (!this.onRequestFallback) {
			throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
		}
		return this.onRequestFallback(args);
	}

	/**
	 * @desc Validate settings
	 * @abstract
	 */
	validateSettings() {
		throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
	}

	/**
	 * Run kernel in async mode
	 * @returns {Promise<KernelOutput>}
	 */
	exec() {
		const args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));
		return new Promise((accept, reject) => {
			try {
				accept(this.run.apply(this, args));
			} catch (e) {
				reject(e);
			}
		});
	}

	/**
	 * @desc Add a sub kernel to the root kernel instance.
	 * This is what `createKernelMap` uses.
	 *
	 * @param {ISubKernel} subKernel - function (as a String) of the subKernel to add
	 */
	addSubKernel(subKernel) {
		if (this.subKernels === null) {
			this.subKernels = [];
		}
		if (!subKernel.source) throw new Error('subKernel missing "source" property');
		if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
		if (!subKernel.name) throw new Error('subKernel missing "name" property');
		this.subKernels.push(subKernel);
		return this;
	}

	/**
	 * @desc Destroys all memory associated with this kernel
	 * @param {Boolean} removeCanvasReferences remove any associated canvas references?
	 */
	destroy(removeCanvasReferences) {
		throw new Error(`"destroy" called on ${ this.constructor.name }`);
	}

	/**
	 * bit storage ratio of source to target 'buffer', i.e. if 8bit array -> 32bit tex = 4
	 * @param value
	 * @returns {number}
	 */
	getBitRatio(value) {
		if (this.precision === 'single') {
			// 8 and 16 are upconverted to float32
			return 4;
		} else if (Array.isArray(value[0])) {
			return this.getBitRatio(value[0]);
		} else if (value.constructor === Input) {
			return this.getBitRatio(value.value);
		}
		switch (value.constructor) {
			case Uint8Array:
			case Int8Array:
				return 1;
			case Uint16Array:
			case Int16Array:
				return 2;
			case Float32Array:
			case Int32Array:
			default:
				return 4;
		}
	}

	/**
	 * @returns {number[]}
	 */
	getPixels() {
		throw new Error(`"getPixels" called on ${ this.constructor.name }`);
	}

	checkOutput() {
		if (!this.output || !Array.isArray(this.output)) throw new Error('kernel.output not an array');
		if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
		for (let i = 0; i < this.output.length; i++) {
			if (isNaN(this.output[i]) || this.output[i] < 1) {
				throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
			}
		}
	}

	toJSON() {
		const settings = {
			output: this.output,
			threadDim: this.threadDim,
			pipeline: this.pipeline,
			argumentNames: this.argumentNames,
			argumentsTypes: this.argumentTypes,
			argumentsLength: this.argumentsLength,
			constants: this.constants,
			constantsLength: this.constantsLength,
			pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
			returnType: this.returnType,
		};
		return {
			settings
		};
	}
}

module.exports = {
	Kernel
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl/fragment-shader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl/fragment-shader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const fragmentShader = `__HEADER__;
precision highp float;
precision highp int;
precision highp sampler2D;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

vec4 round(vec4 x) {
  return floor(x + 0.5);
}

float round(float x) {
  return floor(x + 0.5);
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
	int channel = integerMod(index, 2);
	if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
	if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
	return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 encode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
	fragmentShader
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl/function-node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl/function-node.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	FunctionNode
} = __webpack_require__(/*! ../function-node */ "./node_modules/gpu.js/src/backend/function-node.js");
// Closure capture for the ast function, prevent collision with existing AST functions
// The prefixes to use
const jsMathPrefix = 'Math.';
const localPrefix = 'this.';

/**
 * @desc [INTERNAL] Takes in a function node, and does all the AST voodoo required to toString its respective WebGL code
 * @extends FunctionNode
 * @returns the converted WebGL function string
 */
class WebGLFunctionNode extends FunctionNode {
	constructor(source, settings) {
		super(source, settings);
		this.fixIntegerDivisionAccuracy = null;
		if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
			this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
		}
	}

	/**
	 * @desc Parses the abstract syntax tree for to its *named function*
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astFunctionExpression(ast, retArr) {
		// Setup function return type and name
		if (this.isRootKernel) {
			retArr.push('void');
		} else {
			// looking up return type, this is a little expensive, and can be avoided if returnType is set
			if (!this.returnType) {
				const lastReturn = this.findLastReturn();
				if (lastReturn) {
					this.returnType = this.getType(ast.body);
					if (this.returnType === 'LiteralInteger') {
						this.returnType = 'Number';
					}
				}
			}

			const {
				returnType
			} = this;
			if (!returnType) {
				retArr.push('void');
			} else {
				const type = typeMap[returnType];
				if (!type) {
					throw new Error(`unknown type ${returnType}`);
				}
				retArr.push(type);
			}
		}
		retArr.push(' ');
		retArr.push(this.name);
		retArr.push('(');

		if (!this.isRootKernel) {
			// Arguments handling
			for (let i = 0; i < this.argumentNames.length; ++i) {
				const argumentName = this.argumentNames[i];

				if (i > 0) {
					retArr.push(', ');
				}
				let argumentType = this.getVariableType(argumentName);
				if (!argumentType || argumentType === 'LiteralInteger') {
					argumentType = 'Number';
				}
				const type = typeMap[argumentType];
				if (!type) {
					throw this.astErrorOutput('Unexpected expression', ast);
				}
				retArr.push(type);
				retArr.push(' ');
				retArr.push('user_');
				retArr.push(argumentName);
			}
		}

		// Function opening
		retArr.push(') {\n');

		// Body statement iteration
		for (let i = 0; i < ast.body.body.length; ++i) {
			this.astGeneric(ast.body.body[i], retArr);
			retArr.push('\n');
		}

		// Function closing
		retArr.push('}\n');
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for to *return* statement
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astReturnStatement(ast, retArr) {
		if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
		const type = this.getType(ast.argument);

		const result = [];

		if (!this.returnType) {
			if (this.isRootKernel) {
				this.returnType = 'Number';
			} else {
				this.returnType = type;
			}
		}

		switch (this.returnType) {
			case 'LiteralInteger':
			case 'Number':
			case 'Float':
				switch (type) {
					case 'Integer':
						result.push('float(');
						this.astGeneric(ast.argument, result);
						result.push(')');
						break;
					case 'LiteralInteger':
						this.pushState('casting-to-float');
						this.astGeneric(ast.argument, result);
						this.popState('casting-to-float');

						// Running astGeneric forces the LiteralInteger to pick a type, and here, if we are returning a float, yet
						// the LiteralInteger has picked to be an integer because of constraints on it we cast it to float.
						if (this.getType(ast) === 'Integer') {
							result.unshift('float(');
							result.push(')');
						}
						break;
					default:
						this.astGeneric(ast.argument, result);
				}
				break;
			case 'Integer':
				switch (type) {
					case 'Number':
						this.pushState('casting-to-integer');
						result.push('int(');
						this.astGeneric(ast.argument, result);
						result.push(')');
						this.popState('casting-to-integer');
						break;
					case 'LiteralInteger':
						this.pushState('casting-to-integer');
						this.astGeneric(ast.argument, result);
						this.popState('casting-to-integer');
						break;
					default:
						this.astGeneric(ast.argument, result);
				}
				break;
			case 'Array(4)':
			case 'Array(3)':
			case 'Array(2)':
			case 'Input':
				this.astGeneric(ast.argument, result);
				break;
			default:
				throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
		}

		if (this.isRootKernel) {
			retArr.push(`kernelResult = ${ result.join('') };`);
			retArr.push('return;');
		} else if (this.isSubKernel) {
			retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
			retArr.push(`return subKernelResult_${ this.name };`);
		} else {
			retArr.push(`return ${ result.join('') };`);
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *literal value*
	 *
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 *
	 * @returns {Array} the append retArr
	 */
	astLiteral(ast, retArr) {
		// Reject non numeric literals
		if (isNaN(ast.value)) {
			throw this.astErrorOutput(
				'Non-numeric literal not supported : ' + ast.value,
				ast
			);
		}

		if (Number.isInteger(ast.value)) {
			if (this.isState('in-for-loop-init') || this.isState('casting-to-integer')) {
				this.literalTypes[`${ast.start},${ast.end}`] = 'Integer';
				retArr.push(`${ast.value}`);
			} else if (this.isState('casting-to-float')) {
				this.literalTypes[`${ast.start},${ast.end}`] = 'Number';
				retArr.push(`${ast.value}.0`);
			} else {
				this.literalTypes[`${ast.start},${ast.end}`] = 'Number';
				retArr.push(`${ast.value}.0`);
			}
		} else if (this.isState('casting-to-integer')) {
			this.literalTypes[`${ast.start},${ast.end}`] = 'Integer';
			retArr.push(parseInt(ast.raw));
		} else {
			this.literalTypes[`${ast.start},${ast.end}`] = 'Number';
			retArr.push(`${ast.value}`);
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *binary* expression
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astBinaryExpression(ast, retArr) {
		if (ast.operator === '%') {
			retArr.push('mod(');

			const leftType = this.getType(ast.left);
			if (leftType === 'Integer') {
				retArr.push('float(');
				this.astGeneric(ast.left, retArr);
				retArr.push(')');
			} else if (leftType === 'LiteralInteger') {
				this.pushState('casting-to-float');
				this.astGeneric(ast.left, retArr);
				this.popState('casting-to-float');
			} else {
				this.astGeneric(ast.left, retArr);
			}

			retArr.push(',');
			const rightType = this.getType(ast.right);

			if (rightType === 'Integer') {
				retArr.push('float(');
				this.astGeneric(ast.right, retArr);
				retArr.push(')');
			} else if (rightType === 'LiteralInteger') {
				this.pushState('casting-to-float');
				this.astGeneric(ast.right, retArr);
				this.popState('casting-to-float');
			} else {
				this.astGeneric(ast.right, retArr);
			}
			retArr.push(')');
			return retArr;
		}

		retArr.push('(');
		if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
			retArr.push('div_with_int_check(');

			switch (this.getType(ast.left)) {
				case 'Integer':
					retArr.push('float(');
					this.pushState('casting-to-float');
					this.astGeneric(ast.left, retArr);
					this.popState('casting-to-float');
					retArr.push(')');
					break;
				case 'LiteralInteger':
					this.pushState('casting-to-float');
					this.astGeneric(ast.left, retArr);
					this.popState('casting-to-float');
					break;
				default:
					this.astGeneric(ast.left, retArr);
			}

			retArr.push(', ');

			switch (this.getType(ast.right)) {
				case 'Integer':
					retArr.push('float(');
					this.pushState('casting-to-float');
					this.astGeneric(ast.right, retArr);
					this.popState('casting-to-float');
					retArr.push(')');
					break;
				case 'LiteralInteger':
					this.pushState('casting-to-float');
					this.astGeneric(ast.right, retArr);
					this.popState('casting-to-float');
					break;
				default:
					this.astGeneric(ast.right, retArr);
			}

			retArr.push(')');
		} else {
			const leftType = this.getType(ast.left) || 'Number';
			const rightType = this.getType(ast.right) || 'Number';
			if (!leftType || !rightType) {
				throw this.astErrorOutput(`Unhandled binary expression`, ast);
			}
			const key = leftType + ' & ' + rightType;
			switch (key) {
				case 'Integer & Integer':
					this.astGeneric(ast.left, retArr);
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.astGeneric(ast.right, retArr);
					break;
				case 'Number & Float':
				case 'Float & Number':
				case 'Float & Float':
				case 'Number & Number':
					this.astGeneric(ast.left, retArr);
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.astGeneric(ast.right, retArr);
					break;
				case 'LiteralInteger & LiteralInteger':
					this.pushState('casting-to-float');
					this.astGeneric(ast.left, retArr);
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.astGeneric(ast.right, retArr);
					this.popState('casting-to-float');
					break;

				case 'Integer & Float':
				case 'Integer & Number':
					if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
						// if right value is actually a float, don't loose that information, cast left to right rather than the usual right to left
						if (!Number.isInteger(ast.right.value)) {
							this.pushState('casting-to-float');
							retArr.push('float(');
							this.astGeneric(ast.left, retArr);
							retArr.push(')');
							this.popState('casting-to-float');
							retArr.push(operatorMap[ast.operator] || ast.operator);
							this.astGeneric(ast.right, retArr);
							break;
						}
					}
					this.astGeneric(ast.left, retArr);
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.pushState('casting-to-integer');
					if (ast.right.type === 'Literal') {
						const literalResult = [];
						this.astGeneric(ast.right, literalResult);
						const literalType = this.getType(ast.right);
						if (literalType === 'Integer') {
							retArr.push(literalResult.join(''));
						} else {
							throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
						}
					} else {
						retArr.push('int(');
						this.astGeneric(ast.right, retArr);
						retArr.push(')');
					}
					this.popState('casting-to-integer');
					break;
				case 'Integer & LiteralInteger':
					this.astGeneric(ast.left, retArr);
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.pushState('casting-to-integer');
					this.astGeneric(ast.right, retArr);
					this.popState('casting-to-integer');
					break;

				case 'Number & Integer':
					this.astGeneric(ast.left, retArr);
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.pushState('casting-to-float');
					retArr.push('float(');
					this.astGeneric(ast.right, retArr);
					retArr.push(')');
					this.popState('casting-to-float');
					break;
				case 'Float & LiteralInteger':
				case 'Number & LiteralInteger':
					if (this.isState('in-for-loop-test')) {
						retArr.push('int(');
						this.astGeneric(ast.left, retArr);
						retArr.push(')');
						retArr.push(operatorMap[ast.operator] || ast.operator);
						this.pushState('casting-to-integer');
						this.astGeneric(ast.right, retArr);
						this.popState('casting-to-integer');
					} else {
						this.astGeneric(ast.left, retArr);
						retArr.push(operatorMap[ast.operator] || ast.operator);
						this.pushState('casting-to-float');
						this.astGeneric(ast.right, retArr);
						this.popState('casting-to-float');
					}
					break;
				case 'LiteralInteger & Float':
				case 'LiteralInteger & Number':
					if (this.isState('in-for-loop-test') || this.isState('in-for-loop-init') || this.isState('casting-to-integer')) {
						this.pushState('casting-to-integer');
						this.astGeneric(ast.left, retArr);
						retArr.push(operatorMap[ast.operator] || ast.operator);
						retArr.push('int(');
						this.astGeneric(ast.right, retArr);
						retArr.push(')');
						this.popState('casting-to-integer');
					} else {
						this.astGeneric(ast.left, retArr);
						retArr.push(operatorMap[ast.operator] || ast.operator);
						this.pushState('casting-to-float');
						this.astGeneric(ast.right, retArr);
						this.popState('casting-to-float');
					}
					break;
				case 'LiteralInteger & Integer':
					this.pushState('casting-to-integer');
					this.astGeneric(ast.left, retArr);
					this.popState('casting-to-integer');
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.astGeneric(ast.right, retArr);
					break;

				case 'Boolean & Boolean':
					this.astGeneric(ast.left, retArr);
					retArr.push(operatorMap[ast.operator] || ast.operator);
					this.astGeneric(ast.right, retArr);
					break;

				default:
					throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
			}
		}

		retArr.push(')');
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *identifier* expression
	 * @param {Object} idtNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astIdentifierExpression(idtNode, retArr) {
		if (idtNode.type !== 'Identifier') {
			throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
		}

		const type = this.getType(idtNode);

		if (idtNode.name === 'Infinity') {
			// https://stackoverflow.com/a/47543127/1324039
			retArr.push('3.402823466e+38');
		} else if (type === 'Boolean') {
			if (this.argumentNames.indexOf(idtNode.name) > -1) {
				retArr.push(`bool(user_${idtNode.name})`);
			} else {
				retArr.push(`user_${idtNode.name}`);
			}
		} else {
			const userArgumentName = this.getKernelArgumentName(idtNode.name);
			if (userArgumentName) {
				retArr.push(`user_${userArgumentName}`);
			} else {
				retArr.push(`user_${idtNode.name}`);
			}
		}

		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *for-loop* expression
	 * @param {Object} forNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the parsed webgl string
	 */
	astForStatement(forNode, retArr) {
		if (forNode.type !== 'ForStatement') {
			throw this.astErrorOutput('Invalid for statement', forNode);
		}

		const initArr = [];
		const testArr = [];
		const updateArr = [];
		const bodyArr = [];
		let isSafe = null;

		if (forNode.init) {
			this.pushState('in-for-loop-init');
			this.astGeneric(forNode.init, initArr);
			for (let i = 0; i < initArr.length; i++) {
				if (initArr[i].includes && initArr[i].includes(',')) {
					isSafe = false;
				}
			}
			this.popState('in-for-loop-init');
		} else {
			isSafe = false;
		}

		if (forNode.test) {
			this.pushState('in-for-loop-test');
			this.astGeneric(forNode.test, testArr);
			this.popState('in-for-loop-test');
		} else {
			isSafe = false;
		}

		if (forNode.update) {
			this.astGeneric(forNode.update, updateArr);
		} else {
			isSafe = false;
		}

		if (forNode.body) {
			this.pushState('loop-body');
			this.astGeneric(forNode.body, bodyArr);
			this.popState('loop-body');
		}

		// have all parts, now make them safe
		if (isSafe === null) {
			isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
		}

		if (isSafe) {
			retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
			retArr.push(bodyArr.join(''));
			retArr.push('}\n');
		} else {
			const iVariableName = this.getInternalVariableName('safeI');
			if (initArr.length > 0) {
				retArr.push(initArr.join(''), ';\n');
			}
			retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
			if (testArr.length > 0) {
				retArr.push(`if (!${testArr.join('')}) break;\n`);
			}
			retArr.push(bodyArr.join(''));
			retArr.push(`\n${updateArr.join('')};`);
			retArr.push('}\n');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *while* loop
	 * @param {Object} whileNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the parsed webgl string
	 */
	astWhileStatement(whileNode, retArr) {
		if (whileNode.type !== 'WhileStatement') {
			throw this.astErrorOutput('Invalid while statement', whileNode);
		}

		const iVariableName = this.getInternalVariableName('safeI');
		retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
		retArr.push('if (!');
		this.astGeneric(whileNode.test, retArr);
		retArr.push(') break;\n');
		this.astGeneric(whileNode.body, retArr);
		retArr.push('}\n');

		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *do while* loop
	 * @param {Object} doWhileNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the parsed webgl string
	 */
	astDoWhileStatement(doWhileNode, retArr) {
		if (doWhileNode.type !== 'DoWhileStatement') {
			throw this.astErrorOutput('Invalid while statement', doWhileNode);
		}

		const iVariableName = this.getInternalVariableName('safeI');
		retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
		this.astGeneric(doWhileNode.body, retArr);
		retArr.push('if (!');
		this.astGeneric(doWhileNode.test, retArr);
		retArr.push(') break;\n');
		retArr.push('}\n');

		return retArr;
	}


	/**
	 * @desc Parses the abstract syntax tree for *Assignment* Expression
	 * @param {Object} assNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astAssignmentExpression(assNode, retArr) {
		if (assNode.operator === '%=') {
			this.astGeneric(assNode.left, retArr);
			retArr.push('=');
			retArr.push('mod(');
			this.astGeneric(assNode.left, retArr);
			retArr.push(',');
			this.astGeneric(assNode.right, retArr);
			retArr.push(')');
		} else {
			const leftType = this.getType(assNode.left);
			const rightType = this.getType(assNode.right);
			this.astGeneric(assNode.left, retArr);
			retArr.push(assNode.operator);
			if (leftType !== 'Integer' && rightType === 'Integer') {
				retArr.push('float(');
				this.astGeneric(assNode.right, retArr);
				retArr.push(')');
			} else {
				this.astGeneric(assNode.right, retArr);
			}
			return retArr;
		}
	}

	/**
	 * @desc Parses the abstract syntax tree for *Block* statement
	 * @param {Object} bNode - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astBlockStatement(bNode, retArr) {
		if (this.isState('loop-body')) {
			this.pushState('block-body'); // this prevents recursive removal of braces
			for (let i = 0; i < bNode.body.length; i++) {
				this.astGeneric(bNode.body[i], retArr);
			}
			this.popState('block-body');
		} else {
			retArr.push('{\n');
			for (let i = 0; i < bNode.body.length; i++) {
				this.astGeneric(bNode.body[i], retArr);
			}
			retArr.push('}\n');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *Variable Declaration*
	 * @param {Object} varDecNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astVariableDeclaration(varDecNode, retArr) {
		if (varDecNode.kind === 'var') {
			this.varWarn();
		}
		const declarations = varDecNode.declarations;
		if (!declarations || !declarations[0] || !declarations[0].init) {
			throw this.astErrorOutput('Unexpected expression', varDecNode);
		}
		const result = [];
		const firstDeclaration = declarations[0];
		const init = firstDeclaration.init;
		const actualType = this.getType(init);
		const inForLoopInit = this.isState('in-for-loop-init');
		let type = inForLoopInit ? 'Integer' : actualType;
		if (type === 'LiteralInteger') {
			// We had the choice to go either float or int, choosing float
			type = 'Number';
		}
		const markupType = typeMap[type];
		if (!markupType) {
			throw this.astErrorOutput(`Markup type ${ markupType } not handled`, varDecNode);
		}
		let dependencies = this.getDependencies(firstDeclaration.init);
		const initResult = [];
		if (actualType === 'Integer' && type === 'Integer' && !inForLoopInit) {
			this.declarations[firstDeclaration.id.name] = Object.freeze({
				type: 'Number',
				dependencies,
				isSafe: this.isSafeDependencies(dependencies),
			});
			initResult.push('float ');
			initResult.push(`user_${firstDeclaration.id.name}=`);
			initResult.push('float(');
			this.astGeneric(init, initResult);
			initResult.push(')');
		} else {
			this.declarations[firstDeclaration.id.name] = Object.freeze({
				type,
				dependencies,
				isSafe: this.isSafeDependencies(dependencies),
			});
			initResult.push(`${markupType} `);
			initResult.push(`user_${firstDeclaration.id.name}=`);
			if (actualType === 'Number' && type === 'Integer') {
				initResult.push('int(');
				this.astGeneric(init, initResult);
				initResult.push(')');
			} else {
				this.astGeneric(init, initResult);
			}
		}
		result.push(initResult.join(''));

		// first declaration is done, now add multiple statements
		let lastType = type;
		for (let i = 1; i < declarations.length; i++) {
			const declaration = declarations[i];
			const nextResult = [];
			if (!inForLoopInit) {
				let possibleNewType = this.getType(declaration.init);
				if (possibleNewType === 'LiteralInteger') {
					possibleNewType = 'Number';
				}
				if (possibleNewType !== lastType) {
					nextResult.push(';');
					nextResult.push(typeMap[possibleNewType], ' ');
					lastType = possibleNewType;
				} else {
					nextResult.push(',');
				}
			} else {
				nextResult.push(',');
			}
			dependencies = this.getDependencies(declaration);
			this.declarations[declaration.id.name] = Object.freeze({
				type: lastType,
				dependencies: dependencies,
				isSafe: this.isSafeDependencies(dependencies),
			});
			this.astGeneric(declaration, nextResult);
			result.push(nextResult.join(''));
		}

		retArr.push(result.join(''));
		if (!inForLoopInit) {
			retArr.push(';');
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *If* Statement
	 * @param {Object} ifNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astIfStatement(ifNode, retArr) {
		retArr.push('if (');
		this.astGeneric(ifNode.test, retArr);
		retArr.push(')');
		if (ifNode.consequent.type === 'BlockStatement') {
			this.astGeneric(ifNode.consequent, retArr);
		} else {
			retArr.push(' {\n');
			this.astGeneric(ifNode.consequent, retArr);
			retArr.push('\n}\n');
		}

		if (ifNode.alternate) {
			retArr.push('else ');
			if (ifNode.alternate.type === 'BlockStatement') {
				this.astGeneric(ifNode.alternate, retArr);
			} else {
				retArr.push(' {\n');
				this.astGeneric(ifNode.alternate, retArr);
				retArr.push('\n}\n');
			}
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *This* expression
	 * @param {Object} tNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astThisExpression(tNode, retArr) {
		retArr.push('this');
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *Member* Expression
	 * @param {Object} mNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astMemberExpression(mNode, retArr) {
		const {
			property,
			name,
			signature,
			origin,
			type,
			xProperty,
			yProperty,
			zProperty
		} = this.getMemberExpressionDetails(mNode);
		switch (signature) {
			case 'this.thread.value':
				if (name !== 'x' && name !== 'y' && name !== 'z') {
					throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
				}
				retArr.push(`threadId.${name}`);
				return retArr;
			case 'this.output.value':
				switch (name) {
					case 'x':
						if (this.isState('casting-to-integer')) {
							retArr.push(this.output[0]);
						} else {
							retArr.push(this.output[0], '.0');
						}
						break;
					case 'y':
						if (this.isState('casting-to-integer')) {
							retArr.push(this.output[1]);
						} else {
							retArr.push(this.output[1], '.0');
						}
						break;
					case 'z':
						if (this.isState('casting-to-integer')) {
							retArr.push(this.output[2]);
						} else {
							retArr.push(this.output[2], '.0');
						}
						break;
					default:
						throw this.astErrorOutput('Unexpected expression', mNode);
				}
				return retArr;
			case 'value':
				throw this.astErrorOutput('Unexpected expression', mNode);
			case 'value[]':
			case 'value[][]':
			case 'value[][][]':
			case 'value[][][][]':
			case 'value.value':
				if (origin === 'Math') {
					retArr.push(Math[name]);
					return retArr;
				}
				switch (property) {
					case 'r':
						retArr.push(`user_${ name }.r`);
						return retArr;
					case 'g':
						retArr.push(`user_${ name }.g`);
						return retArr;
					case 'b':
						retArr.push(`user_${ name }.b`);
						return retArr;
					case 'a':
						retArr.push(`user_${ name }.a`);
						return retArr;
				}
				break;
			case 'this.constants.value':
			case 'this.constants.value[]':
			case 'this.constants.value[][]':
			case 'this.constants.value[][][]':
			case 'this.constants.value[][][][]':
				break;
			case 'fn()[]':
				this.astCallExpression(mNode.object, retArr);
				retArr.push('[');
				retArr.push(this.memberExpressionPropertyMarkup(property));
				retArr.push(']');
				return retArr;
			case '[][]':
				this.astArrayExpression(mNode.object, retArr);
				retArr.push('[');
				retArr.push(this.memberExpressionPropertyMarkup(property));
				retArr.push(']');
				return retArr;
			default:
				throw this.astErrorOutput('Unexpected expression', mNode);
		}

		// handle simple types
		switch (type) {
			case 'Number':
			case 'Integer':
			case 'Float':
				retArr.push(`${ origin }_${ name}`);
				return retArr;
			case 'Boolean':
				retArr.push(`bool(${ origin }_${ name})`);
				return retArr;
		}

		// handle more complex types
		// argument may have come from a parent
		let synonymName = this.getKernelArgumentName(name);

		const markupName = `${origin}_${synonymName || name}`;

		switch (type) {
			case 'Array(2)':
			case 'Array(3)':
			case 'Array(4)':
				// Get from local vec4
				this.astGeneric(mNode.object, retArr);
				retArr.push('[');
				retArr.push(this.memberExpressionPropertyMarkup(xProperty));
				retArr.push(']');
				break;
			case 'HTMLImageArray':
				retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
				this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
				retArr.push(')');
				break;
			case 'ArrayTexture(1)':
				retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
				this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
				retArr.push(')');
				break;
			case 'ArrayTexture(2)':
				retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
				this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
				retArr.push(')');
				break;
			case 'ArrayTexture(3)':
				retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
				this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
				retArr.push(')');
				break;
			case 'ArrayTexture(4)':
			case 'HTMLImage':
				retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
				this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
				retArr.push(')');
				break;
			case 'NumberTexture':
			case 'Array':
			case 'Array2D':
			case 'Array3D':
			case 'Array4D':
			case 'Input':

				if (this.precision === 'single') {
					// bitRatio is always 4 here, javascript doesn't yet have 8 or 16 bit support
					// TODO: make 8 or 16 bit work anyway!
					retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
					this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
					retArr.push(')');
				} else {
					const bitRatio = (origin === 'user' ?
						this.lookupFunctionArgumentBitRatio(this.name, name) :
						this.constantBitRatios[name]
					);
					switch (bitRatio) {
						case 1:
							retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
							break;
						case 2:
							retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
							break;
						case 4:
						case 0:
							retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
							break;
						default:
							throw new Error(`unhandled bit ratio of ${ bitRatio}`);
					}
					this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
					retArr.push(')');
				}
				break;
			case 'MemoryOptimizedNumberTexture':
				retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
				this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
				retArr.push(')');
				break;
			default:
				throw new Error(`unhandled member expression "${ type }"`);
		}
		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *call* expression
	 * @param {Object} ast - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns  {Array} the append retArr
	 */
	astCallExpression(ast, retArr) {
		if (!ast.callee) {
			// Failure, unknown expression
			throw this.astErrorOutput(
				'Unknown CallExpression',
				ast
			);
		}

		// Get the full function call, unrolled
		let functionName = this.astMemberExpressionUnroll(ast.callee);
		const isMathFunction = functionName.indexOf(jsMathPrefix) === 0;

		// Its a math operator, remove the prefix
		if (isMathFunction) {
			functionName = functionName.slice(jsMathPrefix.length);
		}

		// Its a local function, remove this
		if (functionName.indexOf(localPrefix) === 0) {
			functionName = functionName.slice(localPrefix.length);
		}

		// if this if grows to more than one, lets use a switch
		if (functionName === 'atan2') {
			functionName = 'atan';
		}

		// Register the function into the called registry
		if (this.calledFunctions.indexOf(functionName) < 0) {
			this.calledFunctions.push(functionName);
		}

		if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
			for (let i = 0; i < this.plugins.length; i++) {
				const plugin = this.plugins[i];
				if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
					retArr.push(plugin.functionReplace);
					return retArr;
				}
			}
		}

		// track the function was called
		if (this.onFunctionCall) {
			this.onFunctionCall(this.name, functionName);
		}

		// Call the function
		retArr.push(functionName);

		// Open arguments space
		retArr.push('(');

		// Add the arguments
		if (isMathFunction) {
			for (let i = 0; i < ast.arguments.length; ++i) {
				const argument = ast.arguments[i];
				const argumentType = this.getType(argument);
				if (i > 0) {
					retArr.push(', ');
				}

				switch (argumentType) {
					case 'Integer':
						this.pushState('casting-to-float');
						retArr.push('float(');
						this.astGeneric(argument, retArr);
						retArr.push(')');
						this.popState('casting-to-float');
						break;
					default:
						this.astGeneric(argument, retArr);
						break;
				}
			}
		} else {
			const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
			for (let i = 0; i < ast.arguments.length; ++i) {
				const argument = ast.arguments[i];
				let targetType = targetTypes[i];
				if (i > 0) {
					retArr.push(', ');
				}
				const argumentType = this.getType(argument);
				if (!targetType) {
					this.triggerImplyArgumentType(functionName, i, argumentType, this);
					targetType = argumentType;
				}
				switch (argumentType) {
					case 'Number':
					case 'Float':
						if (targetType === 'Integer') {
							retArr.push('int(');
							this.astGeneric(argument, retArr);
							retArr.push(')');
							continue;
						} else if (targetType === 'Number' || targetType === 'Float') {
							this.astGeneric(argument, retArr);
							continue;
						} else if (targetType === 'LiteralInteger') {
							this.pushState('casting-to-float');
							this.astGeneric(argument, retArr);
							this.popState('casting-to-float');
							continue;
						}
						break;
					case 'Integer':
						if (targetType === 'Number' || targetType === 'Float') {
							retArr.push('float(');
							this.astGeneric(argument, retArr);
							retArr.push(')');
							continue;
						} else if (targetType === 'Integer') {
							this.astGeneric(argument, retArr);
							continue;
						}
						break;
					case 'LiteralInteger':
						if (targetType === 'Integer') {
							this.pushState('casting-to-integer');
							this.astGeneric(argument, retArr);
							this.popState('casting-to-integer');
							continue;
						} else if (targetType === 'Number' || targetType === 'Float') {
							this.pushState('casting-to-float');
							this.astGeneric(argument, retArr);
							this.popState('casting-to-float');
							continue;
						} else if (targetType === 'LiteralInteger') {
							this.astGeneric(argument, retArr);
							continue;
						}
						break;
					case 'Array(2)':
					case 'Array(3)':
					case 'Array(4)':
						if (targetType === argumentType) {
							this.astGeneric(argument, retArr);
							continue;
						}
						break;
					case 'Array':
					case 'Input':
						if (targetType === argumentType) {
							this.triggerTrackArgumentSynonym(this.name, argument.name, functionName, i);
							this.astGeneric(argument, retArr);
							continue;
						}
						break;
				}
				throw new Error(`Unhandled argument combination of ${ argumentType } and ${ targetType }`);
			}
		}
		// Close arguments space
		retArr.push(')');

		return retArr;
	}

	/**
	 * @desc Parses the abstract syntax tree for *Array* Expression
	 * @param {Object} arrNode - the AST object to parse
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astArrayExpression(arrNode, retArr) {
		const arrLen = arrNode.elements.length;

		retArr.push('vec' + arrLen + '(');
		for (let i = 0; i < arrLen; ++i) {
			if (i > 0) {
				retArr.push(', ');
			}
			const subNode = arrNode.elements[i];
			this.astGeneric(subNode, retArr)
		}
		retArr.push(')');

		return retArr;
	}

	memberExpressionXYZ(x, y, z, retArr) {
		if (z) {
			retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
		} else {
			retArr.push('0, ');
		}
		if (y) {
			retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
		} else {
			retArr.push('0, ');
		}
		retArr.push(this.memberExpressionPropertyMarkup(x));
		return retArr;
	}

	memberExpressionPropertyMarkup(property) {
		if (!property) {
			throw new Error('Property not set');
		}
		const type = this.getType(property);
		const result = [];
		if (type === 'Number') {
			this.pushState('casting-to-integer');
			result.push('int(');
			this.astGeneric(property, result);
			result.push(')');
			this.popState('casting-to-integer');
		} else if (type === 'LiteralInteger') {
			this.pushState('casting-to-integer');
			this.astGeneric(property, result);
			this.popState('casting-to-integer');
		} else {
			this.astGeneric(property, result);
		}
		return result.join('');
	}
}

const typeMap = {
	'Array': 'sampler2D',
	'Array(2)': 'vec2',
	'Array(3)': 'vec3',
	'Array(4)': 'vec4',
	'Array2D': 'sampler2D',
	'Array3D': 'sampler2D',
	'Boolean': 'bool',
	'Float': 'float',
	'Input': 'sampler2D',
	'Integer': 'int',
	'Number': 'float',
	'LiteralInteger': 'float',
	'NumberTexture': 'sampler2D',
	'MemoryOptimizedNumberTexture': 'sampler2D',
	'ArrayTexture(1)': 'sampler2D',
	'ArrayTexture(2)': 'sampler2D',
	'ArrayTexture(3)': 'sampler2D',
	'ArrayTexture(4)': 'sampler2D',
};

const operatorMap = {
	'===': '==',
	'!==': '!='
};

module.exports = {
	WebGLFunctionNode
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl/kernel-string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl/kernel-string.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	utils
} = __webpack_require__(/*! ../../utils */ "./node_modules/gpu.js/src/utils.js");
const {
	kernelRunShortcut
} = __webpack_require__(/*! ../../kernel-run-shortcut */ "./node_modules/gpu.js/src/kernel-run-shortcut.js");

function removeFnNoise(fn) {
	if (/^function /.test(fn)) {
		fn = fn.substring(9);
	}
	return fn.replace(/[_]typeof/g, 'typeof');
}

function removeNoise(str) {
	return str
		.replace(/^[A-Za-z23]+/, 'function')
		.replace(/[_]typeof/g, 'typeof');
}

function boolToString(value) {
	if (value) {
		return 'true';
	} else if (value === false) {
		return 'false';
	}
	return 'null';
}

function webGLKernelString(gpuKernel, name) {
	return `() => {
    ${ kernelRunShortcut.toString() };
    const utils = {
      allPropertiesOf: ${ removeNoise(utils.allPropertiesOf.toString()) },
      clone: ${ removeNoise(utils.clone.toString()) },
      splitArray: ${ removeNoise(utils.splitArray.toString()) },
      getVariableType: ${ removeNoise(utils.getVariableType.toString()) },
      getDimensions: ${ removeNoise(utils.getDimensions.toString()) },
      dimToTexSize: ${ removeNoise(utils.dimToTexSize.toString()) },
      closestSquareDimensions: ${ removeNoise(utils.closestSquareDimensions.toString()) },
      getMemoryOptimizedFloatTextureSize: ${ removeNoise(utils.getMemoryOptimizedFloatTextureSize.toString()) },
      getMemoryOptimizedPackedTextureSize: ${ removeNoise(utils.getMemoryOptimizedPackedTextureSize.toString()) },
      roundTo: ${ removeNoise(utils.roundTo.toString()) },
      flattenTo: ${ removeNoise(utils.flattenTo.toString()) },
      flatten2dArrayTo: ${ removeNoise(utils.flatten2dArrayTo.toString()) },
      flatten3dArrayTo: ${ removeNoise(utils.flatten3dArrayTo.toString()) },
      systemEndianness: ${ removeNoise(utils.getSystemEndianness.toString()) },
      isArray: ${ removeNoise(utils.isArray.toString()) }
    };
    const canvases = [];
    const maxTexSizes = {};
    let Texture = function() {};
    let Input = function() {}; 
    class ${ name || 'Kernel' } {
      constructor() {
        this.maxTexSize = null;
        this.argumentsLength = 0;
        this.constantsLength = 0;
        this.constantBitRatios = ${ gpuKernel.constantBitRatios ? JSON.stringify(gpuKernel.constantBitRatios) : 'null' };
        this.canvas = null;
        this.context = null;
        this.program = null;
        this.subKernels = null;
        this.subKernelNames = null;
        this.drawBuffersMap = ${ gpuKernel.drawBuffersMap ? JSON.stringify(gpuKernel.drawBuffersMap) : 'null' };
        this.endianness = '${ gpuKernel.endianness }';
        this.graphical = ${ boolToString(gpuKernel.graphical) };
        this.optimizeFloatMemory = ${ boolToString(gpuKernel.optimizeFloatMemory) };
        this.precision = "${ gpuKernel.precision }";
        // TODO: not sure how to handle
        this.floatOutputForce = ${ boolToString(gpuKernel.floatOutputForce) };
        this.hardcodeConstants = ${ boolToString(gpuKernel.hardcodeConstants) };
        this.pipeline = ${ boolToString(gpuKernel.pipeline) };
        this.argumentNames = ${ JSON.stringify(gpuKernel.argumentNames) };
        this.argumentTypes = ${ JSON.stringify(gpuKernel.argumentTypes) };
        this.argumentBitRatios = ${ JSON.stringify(gpuKernel.argumentBitRatios) };
       
        this.texSize = ${ JSON.stringify(Array.from(gpuKernel.texSize)) };
        this.output = ${ JSON.stringify(gpuKernel.output) };
        this.compiledFragmentShader = \`${ gpuKernel.compiledFragmentShader }\`;
		    this.compiledVertexShader = \`${ gpuKernel.compiledVertexShader }\`;
		    this.returnType = '${ gpuKernel.returnType }';
		    this.programUniformLocationCache = {};
		    this.textureCache = {};
		    this.subKernelOutputTextures = null;
		    this.extensions = {};
		    this.uniform1fCache = {};
		    this.uniform1iCache = {};
		    this.uniform2fCache = {};
		    this.uniform2fvCache = {};
		    this.uniform2ivCache = {};
		    this.uniform3fvCache = {};
		    this.uniform3ivCache = {};
      }
      getFragmentShader() { return this.compiledFragmentShader; }
      getVertexShader() { return this.compiledVertexShader; }
      validateSettings() {}
      initExtensions() {}
      setupArguments() {}
      setupConstants() {}
      setCanvas(canvas) { this.canvas = canvas; return this; }
      setContext(context) { this.context = context; return this; }
      setTexture(Type) { Texture = Type; }
      setInput(Type) { Input = Type; }
      ${ removeFnNoise(gpuKernel.getUniformLocation.toString()) }
      ${ removeFnNoise(gpuKernel.build.toString()) }
      translateSource() {}
      pickRenderStrategy() {}
		  ${ removeFnNoise(gpuKernel.run.toString()) }
		  ${ removeFnNoise(gpuKernel.addArgument.toString()) }
		  ${ removeFnNoise(gpuKernel.formatArrayTransfer.toString()) }
		  ${ removeFnNoise(gpuKernel.checkOutput.toString()) }
		  ${ removeFnNoise(gpuKernel.getArgumentTexture.toString()) }
		  ${ removeFnNoise(gpuKernel.getTextureCache.toString()) }
		  ${ removeFnNoise(gpuKernel.getOutputTexture.toString()) }
		  renderOutput() { ${ utils.getFunctionBodyFromString(removeFnNoise(gpuKernel.renderOutput.toString())) } }
		  ${ removeFnNoise(gpuKernel.readPackedPixelsToFloat32Array.toString()) }
		  ${ removeFnNoise(gpuKernel.readPackedPixelsToUint8Array.toString()) }
		  ${ removeFnNoise(gpuKernel.readFloatPixelsToFloat32Array.toString()) }
		  ${ removeFnNoise(gpuKernel.updateMaxTexSize.toString()) }
		  ${ removeFnNoise(gpuKernel._setupOutputTexture.toString()) }
		  ${ removeFnNoise(gpuKernel.detachTextureCache.toString()) }
		  ${ removeFnNoise(gpuKernel.setUniform1f.toString()) }
		  ${ removeFnNoise(gpuKernel.setUniform1i.toString()) }
		  ${ removeFnNoise(gpuKernel.setUniform2f.toString()) }
		  ${ removeFnNoise(gpuKernel.setUniform2fv.toString()) }
		  ${ removeFnNoise(gpuKernel.setUniform2iv.toString()) }
		  ${ removeFnNoise(gpuKernel.setUniform3fv.toString()) }
		  ${ removeFnNoise(gpuKernel.setUniform3iv.toString()) }
		  getReturnTextureType() { return "${ gpuKernel.getReturnTextureType() }"; }
    };
    return kernelRunShortcut(new ${ name || 'Kernel' }());
  };`;
}

module.exports = {
	webGLKernelString
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl/kernel.js":
/*!**********************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl/kernel.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	GLKernel
} = __webpack_require__(/*! ../gl-kernel */ "./node_modules/gpu.js/src/backend/gl-kernel.js");
const {
	FunctionBuilder
} = __webpack_require__(/*! ../function-builder */ "./node_modules/gpu.js/src/backend/function-builder.js");
const {
	WebGLFunctionNode
} = __webpack_require__(/*! ./function-node */ "./node_modules/gpu.js/src/backend/web-gl/function-node.js");
const {
	utils
} = __webpack_require__(/*! ../../utils */ "./node_modules/gpu.js/src/utils.js");
const {
	Texture
} = __webpack_require__(/*! ../../texture */ "./node_modules/gpu.js/src/texture.js");
const triangleNoise = __webpack_require__(/*! ../../plugins/triangle-noise */ "./node_modules/gpu.js/src/plugins/triangle-noise.js");
const {
	fragmentShader
} = __webpack_require__(/*! ./fragment-shader */ "./node_modules/gpu.js/src/backend/web-gl/fragment-shader.js");
const {
	vertexShader
} = __webpack_require__(/*! ./vertex-shader */ "./node_modules/gpu.js/src/backend/web-gl/vertex-shader.js");
const {
	webGLKernelString
} = __webpack_require__(/*! ./kernel-string */ "./node_modules/gpu.js/src/backend/web-gl/kernel-string.js");

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

const plugins = [triangleNoise];
const canvases = [];
const maxTexSizes = {};

/**
 * @desc Kernel Implementation for WebGL.
 * <p>This builds the shaders and runs them on the GPU,
 * the outputs the result back as float(enabled by default) and Texture.</p>
 *
 * @prop {Object} textureCache - webGl Texture cache
 * @prop {Object} threadDim - The thread dimensions, x, y and z
 * @prop {Object} programUniformLocationCache - Location of program variables in memory
 * @prop {Object} framebuffer - Webgl frameBuffer
 * @prop {Object} buffer - WebGL buffer
 * @prop {Object} program - The webGl Program
 * @prop {Object} functionBuilder - Function Builder instance bound to this Kernel
 * @prop {Boolean} pipeline - Set output type to FAST mode (GPU to GPU via Textures), instead of float
 * @prop {String} endianness - Endian information like Little-endian, Big-endian.
 * @prop {Array} argumentTypes - Types of parameters sent to the Kernel
 * @prop {number} argumentsLength - Number of parameters sent to the Kernel
 * @prop {String} compiledFragmentShader - Compiled fragment shader string
 * @prop {String} compiledVertexShader - Compiled Vertical shader string
 */
class WebGLKernel extends GLKernel {
	static get isSupported() {
		if (isSupported !== null) {
			return isSupported;
		}
		this.setupFeatureChecks();
		isSupported = this.isContextMatch(testContext);
		return isSupported;
	}

	static setupFeatureChecks() {
		if (typeof document !== 'undefined') {
			testCanvas = document.createElement('canvas');
		} else if (typeof OffscreenCanvas !== 'undefined') {
			testCanvas = new OffscreenCanvas(0, 0);
		}
		if (!testCanvas) return;
		testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
		if (!testContext || !testContext.getExtension) return;
		testExtensions = {
			OES_texture_float: testContext.getExtension('OES_texture_float'),
			OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
			OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
			WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
		};
		features = this.getFeatures();
	}

	static isContextMatch(context) {
		if (typeof WebGLRenderingContext !== 'undefined') {
			return context instanceof WebGLRenderingContext;
		}
		return false;
	}

	static getFeatures() {
		const isDrawBuffers = this.getIsDrawBuffers();
		return Object.freeze({
			isFloatRead: this.getIsFloatRead(),
			isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
			isTextureFloat: this.getIsTextureFloat(),
			isDrawBuffers,
			kernelMap: isDrawBuffers,
			channelCount: this.getChannelCount(),
		});
	}

	static getIsTextureFloat() {
		return Boolean(testExtensions.OES_texture_float);
	}

	static getIsDrawBuffers() {
		return Boolean(testExtensions.WEBGL_draw_buffers);
	}

	static getChannelCount() {
		return testExtensions.WEBGL_draw_buffers ? testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL : 1;
	}

	static get testCanvas() {
		return testCanvas;
	}

	static get testContext() {
		return testContext;
	}

	static get features() {
		return features;
	}

	static get fragmentShader() {
		return fragmentShader;
	}

	static get vertexShader() {
		return vertexShader;
	}

	constructor(source, settings) {
		super(source, settings);
		this.textureCache = {};
		this.threadDim = {};
		this.programUniformLocationCache = {};
		this.framebuffer = null;

		this.buffer = null;
		this.program = null;
		this.pipeline = settings.pipeline;
		this.endianness = utils.systemEndianness();
		this.extensions = {};
		this.subKernelOutputTextures = null;
		this.argumentsLength = 0;
		this.constantsLength = 0;
		this.compiledFragmentShader = null;
		this.compiledVertexShader = null;
		this.fragShader = null;
		this.vertShader = null;
		this.drawBuffersMap = null;
		this.outputTexture = null;
		this.maxTexSize = null;
		this.uniform1fCache = {};
		this.uniform1iCache = {};
		this.uniform2fCache = {};
		this.uniform2fvCache = {};
		this.uniform2ivCache = {};
		this.uniform3fvCache = {};
		this.uniform3ivCache = {};

		this.mergeSettings(source.settings || settings);
	}

	initCanvas() {
		if (typeof document !== 'undefined') {
			const canvas = document.createElement('canvas');
			// Default width and height, to fix webgl issue in safari
			canvas.width = 2;
			canvas.height = 2;
			return canvas;
		} else if (typeof OffscreenCanvas !== 'undefined') {
			return new OffscreenCanvas(0, 0);
		}
	}

	initContext() {
		const settings = {
			alpha: false,
			depth: false,
			antialias: false
		};
		return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
	}

	initPlugins(settings) {
		// default plugins
		const pluginsToUse = [];
		const {
			source
		} = this;
		if (typeof source === 'string') {
			for (let i = 0; i < plugins.length; i++) {
				const plugin = plugins[i];
				if (source.match(plugin.functionMatch)) {
					pluginsToUse.push(plugin);
				}
			}
		} else if (typeof source === 'object') {
			// `source` is from object, json
			if (settings.pluginNames) { //TODO: pluginNames, may not exist here
				for (let i = 0; i < plugins.length; i++) {
					const plugin = plugins[i];
					const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
					if (usePlugin) {
						pluginsToUse.push(plugin);
					}
				}
			}
		}
		return pluginsToUse;
	}

	initExtensions() {
		this.extensions = {
			OES_texture_float: this.context.getExtension('OES_texture_float'),
			OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
			OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
			WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
			WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
		};
	}

	validateSettings() {
		if (!this.validate) {
			this.texSize = utils.dimToTexSize({
				floatTextures: this.optimizeFloatMemory,
				floatOutput: this.precision === 'single',
			}, this.output, true);
			return;
		}

		const {
			features
		} = this.constructor;
		if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
			throw new Error('Float textures are not supported');
		} else if (this.precision === 'single' && this.floatOutputForce !== true && !features.isFloatRead) {
			throw new Error('Single precision not supported');
		} else if (!this.graphical && this.precision === null && features.isTextureFloat) {
			this.precision = features.isFloatRead ? 'single' : 'unsigned';
		}

		if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
			throw new Error('could not instantiate draw buffers extension');
		}

		if (this.fixIntegerDivisionAccuracy === null) {
			this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
		} else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
			this.fixIntegerDivisionAccuracy = false;
		}

		this.checkOutput();

		if (!this.output || this.output.length === 0) {
			if (arguments.length !== 1) {
				throw new Error('Auto output only supported for kernels with only one input');
			}

			const argType = utils.getVariableType(arguments[0]);
			if (argType === 'Array') {
				this.output = utils.getDimensions(argType);
			} else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
				this.output = arguments[0].output;
			} else {
				throw new Error('Auto output not supported for input type: ' + argType);
			}
		}

		if (this.graphical) {
			if (this.output.length !== 2) {
				throw new Error('Output must have 2 dimensions on graphical mode');
			}

			if (this.precision === 'precision') {
				this.precision = 'unsigned';
				console.warn('Cannot use graphical mode and single precision at the same time');
			}

			this.texSize = utils.clone(this.output);
			return;
		} else if (this.precision === null && features.isTextureFloat) {
			this.precision = 'single';
		}

		this.texSize = utils.dimToTexSize({
			floatTextures: this.floatTextures,
			floatOutput: this.precision === 'single'
		}, this.output, true);
	}

	updateMaxTexSize() {
		const {
			texSize,
			canvas
		} = this;
		if (this.maxTexSize === null) {
			let canvasIndex = canvases.indexOf(canvas);
			if (canvasIndex === -1) {
				canvasIndex = canvases.length;
				canvases.push(canvas);
				maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
			}
			this.maxTexSize = maxTexSizes[canvasIndex];
		}
		if (this.maxTexSize[0] < texSize[0]) {
			this.maxTexSize[0] = texSize[0];
		}
		if (this.maxTexSize[1] < texSize[1]) {
			this.maxTexSize[1] = texSize[1];
		}
	}

	// TODO: move channel checks to new place
	_oldtranslateSource() {
		const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
			fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
		});

		// need this line to automatically get returnType
		const translatedSource = functionBuilder.getPrototypeString('kernel');

		if (!this.returnType) {
			this.returnType = functionBuilder.getKernelResultType();
		}

		let requiredChannels = 0;
		const returnTypes = functionBuilder.getReturnTypes();
		for (let i = 0; i < returnTypes.length; i++) {
			switch (returnTypes[i]) {
				case 'Float':
				case 'Number':
				case 'Integer':
					requiredChannels++;
					break;
				case 'Array(2)':
					requiredChannels += 2;
					break;
				case 'Array(3)':
					requiredChannels += 3;
					break;
				case 'Array(4)':
					requiredChannels += 4;
					break;
			}
		}

		if (features && requiredChannels > features.channelCount) {
			throw new Error('Too many channels!');
		}

		return this.translatedSource = translatedSource;
	}

	build() {
		this.initExtensions();
		this.validateSettings();
		this.setupConstants();
		this.setupArguments(arguments);
		this.updateMaxTexSize();
		this.translateSource();
		this.pickRenderStrategy();
		const texSize = this.texSize;
		const gl = this.context;
		const canvas = this.canvas;
		gl.enable(gl.SCISSOR_TEST);
		if (this.pipeline && this.precision === 'single') {
			gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
			canvas.width = this.maxTexSize[0];
			canvas.height = this.maxTexSize[1];
		} else {
			gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
			canvas.width = this.maxTexSize[0];
			canvas.height = this.maxTexSize[1];
		}
		const threadDim = this.threadDim = Array.from(this.output);
		while (threadDim.length < 3) {
			threadDim.push(1);
		}

		const compiledVertexShader = this.getVertexShader(arguments);
		const vertShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertShader, compiledVertexShader);
		gl.compileShader(vertShader);
		this.vertShader = vertShader;

		const compiledFragmentShader = this.getFragmentShader(arguments);
		const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragShader, compiledFragmentShader);
		gl.compileShader(fragShader);
		this.fragShader = fragShader;

		if (this.debug) {
			console.log('GLSL Shader Output:');
			console.log(compiledFragmentShader);
		}

		if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
			throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
		}
		if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
			throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
		}

		const program = this.program = gl.createProgram();
		gl.attachShader(program, vertShader);
		gl.attachShader(program, fragShader);
		gl.linkProgram(program);
		this.framebuffer = gl.createFramebuffer();
		this.framebuffer.width = texSize[0];
		this.framebuffer.height = texSize[1];

		const vertices = new Float32Array([-1, -1,
			1, -1, -1, 1,
			1, 1
		]);
		const texCoords = new Float32Array([
			0, 0,
			1, 0,
			0, 1,
			1, 1
		]);

		const texCoordOffset = vertices.byteLength;

		let buffer = this.buffer;
		if (!buffer) {
			buffer = this.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
		} else {
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		}

		gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
		gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

		const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
		gl.enableVertexAttribArray(aPosLoc);
		gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
		const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
		gl.enableVertexAttribArray(aTexCoordLoc);
		gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

		for (let p in this.constants) {
			const value = this.constants[p];
			const type = utils.getVariableType(value);
			if (type === 'Float' || type === 'Integer' || type === 'Boolean') {
				continue;
			}
			gl.useProgram(this.program);
			this.addConstant(this.constants[p], type, p);
		}

		if (!this.immutable) {
			this._setupOutputTexture();
			if (
				this.subKernels !== null &&
				this.subKernels.length > 0
			) {
				this._setupSubOutputTextures(this.subKernels.length);
			}
		}
	}

	translateSource() {
		const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
			fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
		});
		this.translatedSource = functionBuilder.getPrototypeString('kernel');
		if (!this.graphical && !this.returnType) {
			this.returnType = functionBuilder.getKernelResultType();
		}
	}

	run() {
		if (this.program === null) {
			this.build.apply(this, arguments);
		}
		const argumentNames = this.argumentNames;
		const argumentTypes = this.argumentTypes;
		const texSize = this.texSize;
		const gl = this.context;

		gl.useProgram(this.program);
		gl.scissor(0, 0, texSize[0], texSize[1]);

		if (!this.hardcodeConstants) {
			this.setUniform3iv('uOutputDim', this.threadDim);
			this.setUniform2iv('uTexSize', texSize);
		}

		this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

		this.argumentsLength = 0;
		for (let texIndex = 0; texIndex < argumentNames.length; texIndex++) {
			this.addArgument(arguments[texIndex], argumentTypes[texIndex], argumentNames[texIndex]);
		}

		if (this.plugins) {
			for (let i = 0; i < this.plugins.length; i++) {
				const plugin = this.plugins[i];
				if (plugin.onBeforeRun) {
					plugin.onBeforeRun(this);
				}
			}
		}

		if (this.graphical) {
			if (this.pipeline) {
				gl.bindRenderbuffer(gl.RENDERBUFFER, null);
				gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
				if (!this.outputTexture || this.immutable) {
					this._setupOutputTexture();
				}
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				return new Texture({
					texture: this.outputTexture,
					size: texSize,
					dimensions: this.threadDim,
					output: this.output,
					context: this.context,
					gpu: this.gpu,
					type: this.getReturnTextureType(),
				});
			}
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			return;
		}

		gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
		if (this.immutable) {
			this._setupOutputTexture();
		}

		if (this.subKernels !== null) {
			if (this.immutable) {
				this.subKernelOutputTextures = [];
				this._setupSubOutputTextures(this.subKernels.length);
			}
			this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
		}

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

		if (this.subKernelOutputTextures !== null) {
			if (this.subKernels !== null) {
				const output = {
					result: this.renderOutput(),
				};
				if (this.pipeline) {
					for (let i = 0; i < this.subKernels.length; i++) {
						output[this.subKernels[i].property] = new Texture({
							texture: this.subKernelOutputTextures[i],
							size: texSize,
							dimensions: this.threadDim,
							output: this.output,
							context: this.context,
							gpu: this.gpu,
							type: this.getReturnTextureType(),
						});
					}
				} else {
					for (let i = 0; i < this.subKernels.length; i++) {
						output[this.subKernels[i].property] = new Texture({
							texture: this.subKernelOutputTextures[i],
							size: texSize,
							dimensions: this.threadDim,
							output: this.output,
							context: this.context,
							gpu: this.gpu,
							type: this.getReturnTextureType(),
						}).toArray();
					}
				}
				return output;
			}
		}

		return this.renderOutput();
	}

	/**
	 * @desc Helper function to return webGl function's output.
	 * Since the program runs on GPU, we need to get the
	 * output of the program back to CPU and then return them.
	 * *Note*: This should not be called directly.
	 *
	 * @returns {Object|Array} result
	 */
	// renderOutput() {
	// 	const texSize = this.texSize;
	// 	const gl = this.context;
	// 	const threadDim = this.threadDim;
	// 	const output = this.output;
	// 	if (this.pipeline) {
	// 		return new Texture({
	// 			texture: this.outputTexture,
	// 			size: texSize,
	// 			dimensions: this.threadDim,
	// 			output,
	// 			context: this.context,
	// 			gpu: this.gpu,
	// 			type: this.getReturnTextureType(),
	// 		});
	// 	} else {
	// 		let result;
	// 		if (this.precision === 'single') {
	// 			const w = texSize[0];
	// 			const h = Math.ceil(texSize[1] / 4);
	// 			result = new Float32Array(w * h * 4);
	// 			gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
	// 		} else {
	// 			const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
	// 			gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, bytes);
	// 			result = new Float32Array(bytes.buffer);
	// 		}
	// 		result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);
	//
	// 		if (output.length === 1) {
	// 			return result;
	// 		} else if (output.length === 2) {
	// 			return utils.splitArray(result, output[0]);
	// 		} else if (output.length === 3) {
	// 			const cube = utils.splitArray(result, output[0] * output[1]);
	// 			return cube.map(function(x) {
	// 				return utils.splitArray(x, output[0]);
	// 			});
	// 		}
	// 	}
	// }

	/**
	 * @desc This return defined outputTexture, which is setup in .build(), or if immutable, is defined in .run()
	 * @returns {Object} Output Texture Cache
	 */
	getOutputTexture() {
		return this.outputTexture;
	}

	/**
	 * @desc Setup and replace output texture
	 */
	_setupOutputTexture() {
		const gl = this.context;
		const texSize = this.texSize;
		const texture = this.outputTexture = this.context.createTexture();
		gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentNames.length);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		// if (this.precision === 'single') {
		// 	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
		// } else {
		// 	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		// }
		if (this.precision === 'single') {
			if (this.pipeline) {
				// TODO: investigate if webgl1 can handle gl.RED usage in gl.texImage2D, otherwise, simplify the below
				switch (this.returnType) {
					case 'Number':
					case 'Float':
					case 'Integer':
						if (this.optimizeFloatMemory) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
						} else {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
						}
						break;
					case 'Array(2)':
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
						break;
					case 'Array(3)':
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
						break;
					case 'Array(4)':
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
						break;
					default:
						if (!this.graphical) {
							throw new Error('Unhandled return type');
						}
				}
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
			}
		} else {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		}
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
	}

	/**
	 * @desc Setup and replace sub-output textures
	 */
	_setupSubOutputTextures(length) {
		const gl = this.context;
		const texSize = this.texSize;
		const drawBuffersMap = this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
		const textures = this.subKernelOutputTextures = [];
		for (let i = 0; i < length; i++) {
			const texture = this.context.createTexture();
			textures.push(texture);
			drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
			gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentNames.length + i);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			if (this.precision === 'single') {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			}
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
		}
	}

	/**
	 * @desc This uses *getTextureCache** to get the Texture Cache of the argument supplied
	 * @param {String} name - Name of the argument
	 */
	getArgumentTexture(name) {
		return this.getTextureCache(`ARGUMENT_${name}`);
	}

	/**
	 * @desc Returns the Texture Cache of the supplied parameter (can be kernel, sub-kernel or argument)
	 * @param {String} name - Name of the subkernel, argument, or kernel.
	 * @returns {Object} Texture cache
	 */
	getTextureCache(name) {
		if (this.textureCache.hasOwnProperty(name)) {
			return this.textureCache[name];
		}
		return this.textureCache[name] = this.context.createTexture();
	}

	/**
	 * @desc removes a texture from the kernel's cache
	 * @param {String} name - Name of texture
	 */
	detachTextureCache(name) {
		delete this.textureCache[name];
	}

	setUniform1f(name, value) {
		if (this.uniform1fCache.hasOwnProperty(name)) {
			const cache = this.uniform1fCache[name];
			if (value === cache) {
				return;
			}
		}
		this.uniform1fCache[name] = value;
		const loc = this.getUniformLocation(name);
		this.context.uniform1f(loc, value);
	}

	setUniform1i(name, value) {
		if (this.uniform1iCache.hasOwnProperty(name)) {
			const cache = this.uniform1iCache[name];
			if (value === cache) {
				return;
			}
		}
		this.uniform1iCache[name] = value;
		const loc = this.getUniformLocation(name);
		this.context.uniform1i(loc, value);
	}

	setUniform2f(name, value1, value2) {
		if (this.uniform2fCache.hasOwnProperty(name)) {
			const cache = this.uniform2fCache[name];
			if (
				value1 === cache[0] &&
				value2 === cache[1]
			) {
				return;
			}
		}
		this.uniform2fCache[name] = [value1, value2];
		const loc = this.getUniformLocation(name);
		this.context.uniform2f(loc, value1, value2);
	}

	setUniform2fv(name, value) {
		if (this.uniform2fvCache.hasOwnProperty(name)) {
			const cache = this.uniform2fvCache[name];
			if (
				value[0] === cache[0] &&
				value[1] === cache[1]
			) {
				return;
			}
		}
		this.uniform2fvCache[name] = value;
		const loc = this.getUniformLocation(name);
		this.context.uniform2fv(loc, value);
	}

	setUniform2iv(name, value) {
		if (this.uniform2ivCache.hasOwnProperty(name)) {
			const cache = this.uniform2ivCache[name];
			if (
				value[0] === cache[0] &&
				value[1] === cache[1]
			) {
				return;
			}
		}
		this.uniform2ivCache[name] = value;
		const loc = this.getUniformLocation(name);
		this.context.uniform2iv(loc, value);
	}

	setUniform3fv(name, value) {
		if (this.uniform3fvCache.hasOwnProperty(name)) {
			const cache = this.uniform3fvCache[name];
			if (
				value[0] === cache[0] &&
				value[1] === cache[1] &&
				value[2] === cache[2]
			) {
				return;
			}
		}
		this.uniform3fvCache[name] = value;
		const loc = this.getUniformLocation(name);
		this.context.uniform3fv(loc, value);
	}

	setUniform3iv(name, value) {
		if (this.uniform3ivCache.hasOwnProperty(name)) {
			const cache = this.uniform3ivCache[name];
			if (
				value[0] === cache[0] &&
				value[1] === cache[1] &&
				value[2] === cache[2]
			) {
				return;
			}
		}
		this.uniform3ivCache[name] = value;
		const loc = this.getUniformLocation(name);
		this.context.uniform3iv(loc, value);
	}

	/**
	 * @desc Return WebGlUniformLocation for various variables
	 * related to webGl program, such as user-defined variables,
	 * as well as, dimension sizes, etc.
	 */
	getUniformLocation(name) {
		if (this.programUniformLocationCache.hasOwnProperty(name)) {
			return this.programUniformLocationCache[name];
		}
		return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
	}

	/**
	 * @desc Generate Shader artifacts for the kernel program.
	 * The final object contains HEADER, KERNEL, MAIN_RESULT, and others.
	 *
	 * @param {Array} args - The actual parameters sent to the Kernel
	 * @returns {Object} An object containing the Shader Artifacts(CONSTANTS, HEADER, KERNEL, etc.)
	 */
	_getFragShaderArtifactMap(args) {
		return {
			HEADER: this._getHeaderString(),
			LOOP_MAX: this._getLoopMaxString(),
			PLUGINS: this._getPluginsString(),
			CONSTANTS: this._getConstantsString(),
			DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
			ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
			DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
			MAIN_CONSTANTS: this._getMainConstantsString(),
			MAIN_ARGUMENTS: this._getMainArgumentsString(args),
			KERNEL: this.getKernelString(),
			MAIN_RESULT: this.getMainResultString()
		};
	}

	/**
	 * @desc Adds kernel parameters to the Argument Texture,
	 * binding it to the webGl instance, etc.
	 *
	 * @param {Array|Texture|Number} value - The actual argument supplied to the kernel
	 * @param {String} type - Type of the argument
	 * @param {String} name - Name of the argument
	 */
	addArgument(value, type, name) {
		const gl = this.context;
		const argumentTexture = this.getArgumentTexture(name);
		if (value instanceof Texture) {
			type = value.type;
		}

		switch (type) {
			case 'Array':
			case 'Array(2)':
			case 'Array(3)':
			case 'Array(4)':
			case 'Array2D':
			case 'Array3D':
				{
					const dim = utils.getDimensions(value, true);
					const bitRatio = this.argumentBitRatios[this.argumentsLength];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						const valuesFlat = this.formatArrayTransfer(value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					}

					break;
				}
			case 'Integer':
				{
					this.setUniform1i(`user_${name}`, value);
					break;
				}
			case 'Float':
			case 'Number':
				{
					this.setUniform1f(`user_${name}`, value);
					break;
				}
			case 'Input':
				{
					const input = value;
					const dim = utils.getDimensions(input, true);
					const bitRatio = this.argumentBitRatios[this.argumentsLength];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						const valuesFlat = this.formatArrayTransfer(input.value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(input.value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					}
					break;
				}
			case 'HTMLImage':
				{
					const inputImage = value;
					const dim = [inputImage.width, inputImage.height, 1];
					const size = [inputImage.width, inputImage.height];

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
					gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					// Upload the image into the texture.
					const mipLevel = 0; // the largest mip
					const internalFormat = gl.RGBA; // format we want in the texture
					const srcFormat = gl.RGBA; // format of data we are supplying
					const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
					gl.texImage2D(gl.TEXTURE_2D,
						mipLevel,
						internalFormat,
						srcFormat,
						srcType,
						inputImage);
					this.setUniform3iv(`user_${name}Dim`, dim);
					this.setUniform2iv(`user_${name}Size`, size);
					this.setUniform1i(`user_${name}`, this.argumentsLength);
					break;
				}
			case 'ArrayTexture(1)':
			case 'ArrayTexture(2)':
			case 'ArrayTexture(3)':
			case 'ArrayTexture(4)':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`argument ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

					this.setUniform3iv(`user_${name}Dim`, dim);
					this.setUniform2iv(`user_${name}Size`, size);
					this.setUniform1i(`user_${name}`, this.argumentsLength);
					break;
				}
			case 'MemoryOptimizedNumberTexture':
			case 'NumberTexture':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`argument ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

					this.setUniform3iv(`user_${name}Dim`, dim);
					this.setUniform2iv(`user_${name}Size`, size);
					this.setUniform1i(`user_${name}`, this.argumentsLength);
					break;
				}
			case 'Boolean':
				{
					this.setUniform1i(`user_${name}`, value ? 1 : 0);
					break;
				}
			default:
				throw new Error('Argument type not supported: ' + value);
		}
		this.argumentsLength++;
	}

	/**
	 * @desc Adds kernel parameters to the Argument Texture,
	 * binding it to the context, etc.
	 *
	 * @param {Array|Texture|Number} value - The actual argument supplied to the kernel
	 * @param {String} type - Type of the argument
	 * @param {String} name - Name of the argument
	 */
	addConstant(value, type, name) {
		const gl = this.context;
		const constantTexture = this.getArgumentTexture(name);
		if (value instanceof Texture) {
			type = value.type;
		}
		switch (type) {
			case 'Array':
			case 'Array(2)':
			case 'Array(3)':
			case 'Array(4)':
			case 'Array2D':
			case 'Array3D':
				{
					const dim = utils.getDimensions(value, true);
					const bitRatio = this.constantBitRatios[name];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						const valuesFlat = this.formatArrayTransfer(value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.constantsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.constantsLength);
					}

					break;
				}
			case 'Input':
				{
					const input = value;
					const dim = utils.getDimensions(input, true);
					const bitRatio = this.constantBitRatios[name];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						const valuesFlat = this.formatArrayTransfer(input.value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.constantsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(input.value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.argumentsLength);
					}
					break;
				}
			case 'HTMLImage':
				{
					const inputImage = value;
					const dim = [inputImage.width, inputImage.height, 1];
					const size = [inputImage.width, inputImage.height];

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
					gl.bindTexture(gl.TEXTURE_2D, constantTexture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					// Upload the image into the texture.
					const mipLevel = 0; // the largest mip
					const internalFormat = gl.RGBA; // format we want in the texture
					const srcFormat = gl.RGBA; // format of data we are supplying
					const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
					gl.texImage2D(gl.TEXTURE_2D,
						mipLevel,
						internalFormat,
						srcFormat,
						srcType,
						inputImage);
					this.setUniform3iv(`constants_${name}Dim`, dim);
					this.setUniform2iv(`constants_${name}Size`, size);
					this.setUniform1i(`constants_${name}`, this.constantsLength);
					break;
				}
			case 'ArrayTexture(1)':
			case 'ArrayTexture(2)':
			case 'ArrayTexture(3)':
			case 'ArrayTexture(4)':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`constant ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

					this.setUniform3iv(`constants_${name}Dim`, dim);
					this.setUniform2iv(`constants_${name}Size`, size);
					this.setUniform1i(`constants_${name}`, this.constantsLength);
					break;
				}
			case 'MemoryOptimizedNumberTexture':
			case 'NumberTexture':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`constant ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);
					this.setUniform3iv(`constants_${name}Dim`, dim);
					this.setUniform2iv(`constants_${name}Size`, size);
					this.setUniform1i(`constants_${name}`, this.constantsLength);
					break;
				}
			case 'Integer':
			case 'Float':
			case 'Boolean':
			default:
				throw new Error('constant type not supported: ' + value);
		}
		this.constantsLength++;
	}

	/**
	 * @desc Adds kernel parameters to the Argument Texture,
	 * binding it to the context, etc.
	 *
	 * @param {Array|Float32Array|Uint16Array} value - The actual argument supplied to the kernel
	 * @param {Number} length - the expected total length of the output array
	 * @param {Object} [Type]
	 * @returns {Float32Array|Uint16Array|Uint8Array} flattened array to transfer
	 */
	formatArrayTransfer(value, length, Type) {
		if (this.floatTextures) {
			// length *= 4;
		}
		if (utils.isArray(value[0]) || this.optimizeFloatMemory) {
			// not already flat
			const valuesFlat = new Float32Array(length);
			utils.flattenTo(value, valuesFlat);
			return valuesFlat;
		} else {
			switch (value.constructor) {
				case Uint8Array:
				case Int8Array:
				case Uint16Array:
				case Int16Array:
				case Float32Array:
				case Int32Array:
					const valuesFlat = new(Type || value.constructor)(length);
					utils.flattenTo(value, valuesFlat);
					return valuesFlat;
				default:
					{
						const valuesFlat = new Float32Array(length);
						utils.flattenTo(value, valuesFlat);
						return valuesFlat;
					}
			}
		}
	}

	/**
	 * @desc Get the header string for the program.
	 * This returns an empty string if no sub-kernels are defined.
	 *
	 * @returns {String} result
	 */
	_getHeaderString() {
		return (
			this.subKernels !== null ?
			'#extension GL_EXT_draw_buffers : require\n' :
			''
		);
	}

	/**
	 * @desc Get the maximum loop size String.
	 * @returns {String} result
	 */
	_getLoopMaxString() {
		return (
			this.loopMaxIterations ?
			` ${parseInt(this.loopMaxIterations)};\n` :
			' 1000;\n'
		);
	}

	_getPluginsString() {
		if (!this.plugins) return '\n';
		return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
	}

	/**
	 * @desc Generate transpiled glsl Strings for constant parameters sent to a kernel
	 * They can be defined by *hardcodeConstants*
	 *
	 * @returns {String} result
	 */
	_getConstantsString() {
		const result = [];
		const {
			threadDim,
			texSize
		} = this;
		if (this.hardcodeConstants) {
			result.push(
				`ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
				`ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
			);
		} else {
			result.push(
				'uniform ivec3 uOutputDim',
				'uniform ivec2 uTexSize'
			);
		}

		return utils.linesToString(result);
	}

	/**
	 * @desc Get texture coordinate string for the program
	 * @returns {String} result
	 */
	_getTextureCoordinate() {
		const subKernels = this.subKernels;
		if (subKernels === null || subKernels.length < 1) {
			return 'varying vec2 vTexCoord;\n';
		} else {
			return 'out vec2 vTexCoord;\n';
		}
	}

	/**
	 * @desc Get Decode32 endianness string for little-endian and big-endian
	 * @returns {String} result
	 */
	_getDecode32EndiannessString() {
		return (
			this.endianness === 'LE' ?
			'' :
			'  texel.rgba = texel.abgr;\n'
		);
	}

	/**
	 * @desc Get Encode32 endianness string for little-endian and big-endian
	 * @returns {String} result
	 */
	_getEncode32EndiannessString() {
		return (
			this.endianness === 'LE' ?
			'' :
			'  texel.rgba = texel.abgr;\n'
		);
	}

	/**
	 * @desc if fixIntegerDivisionAccuracy provide method to replace /
	 * @returns {String} result
	 */
	_getDivideWithIntegerCheckString() {
		return this.fixIntegerDivisionAccuracy ?
			`float div_with_int_check(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x)/int(y));
  }
  return x / y;
}` :
			'';
	}

	/**
	 * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel
	 * @param {Array} args - The actual parameters sent to the Kernel
	 * @returns {String} result
	 */
	_getMainArgumentsString(args) {
		const result = [];
		const {
			argumentTypes,
			argumentNames,
			hardcodeConstants,
			optimizeFloatMemory,
			precision,
		} = this;
		for (let i = 0; i < argumentNames.length; i++) {
			const value = args[i];
			const name = argumentNames[i];
			const type = argumentTypes[i];
			if (hardcodeConstants) {
				switch (type) {
					case 'Array':
					case 'NumberTexture':
					case 'MemoryOptimizedNumberTexture':
					case 'ArrayTexture(1)':
					case 'ArrayTexture(2)':
					case 'ArrayTexture(3)':
					case 'ArrayTexture(4)':
					case 'Input':
					case 'HTMLImage':
						const dim = utils.getDimensions(value, true);
						const size = utils.dimToTexSize({
							floatTextures: optimizeFloatMemory,
							floatOutput: precision === 'single',
						}, dim);

						result.push(
							`uniform sampler2D user_${name}`,
							`ivec2 user_${name}Size = ivec2(${size[0]}, ${size[1]})`,
							`ivec3 user_${name}Dim = ivec3(${dim[0]}, ${dim[1]}, ${dim[2]})`,
						);
						break;
					case 'Integer':
						result.push(`float user_${name} = ${value}.0`);
						break;
					case 'Float':
					case 'Number':
						result.push(`float user_${name} = ${ Number.isInteger(value) ? value + '.0' : value }`);
						break;
					default:
						throw new Error(`Argument type ${type} not supported in WebGL`);
				}
			} else {
				switch (type) {
					case 'Array':
					case 'NumberTexture':
					case 'MemoryOptimizedNumberTexture':
					case 'ArrayTexture(1)':
					case 'ArrayTexture(2)':
					case 'ArrayTexture(3)':
					case 'ArrayTexture(4)':
					case 'Input':
					case 'HTMLImage':
						result.push(
							`uniform sampler2D user_${name}`,
							`uniform ivec2 user_${name}Size`,
							`uniform ivec3 user_${name}Dim`,
						);
						break;
					case 'Integer':
						result.push(`uniform int user_${name}`);
						break;
					case 'Float':
					case 'Number':
						result.push(`uniform float user_${name}`);
						break;
					case 'Boolean':
						result.push(`uniform int user_${name}`);
						break;
					default:
						throw new Error(`Argument type ${type} not supported in WebGL`);
				}
			}
		}
		return utils.linesToString(result);
	}

	_getMainConstantsString() {
		const result = [];
		const {
			constants
		} = this;
		if (constants) {
			for (let name in constants) {
				if (!constants.hasOwnProperty(name)) continue;
				let value = constants[name];
				let type = utils.getVariableType(value);
				switch (type) {
					case 'Integer':
						result.push('const int constants_' + name + ' = ' + parseInt(value));
						break;
					case 'Float':
						result.push('const float constants_' + name + ' = ' + parseFloat(value));
						break;
					case 'Array':
					case 'Input':
					case 'HTMLImage':
					case 'ArrayTexture(1)':
					case 'ArrayTexture(2)':
					case 'ArrayTexture(3)':
					case 'ArrayTexture(4)':
					case 'NumberTexture':
						result.push(
							`uniform sampler2D constants_${name}`,
							`uniform ivec2 constants_${name}Size`,
							`uniform ivec3 constants_${name}Dim`,
						);
						break;
					case 'Boolean':
						result.push('const bool constants_' + name + ' = ' + (value ? 'true' : 'false'));
						break;
					default:
						throw new Error(`Unsupported constant ${name} type ${type}`);
				}
			}
		}
		return utils.linesToString(result);
	}

	/**
	 * @desc Get Kernel program string (in *glsl*) for a kernel.
	 * @returns {String} result
	 */
	getKernelString() {
		let kernelResultDeclaration;
		switch (this.returnType) {
			case 'Array(2)':
				kernelResultDeclaration = 'vec2 kernelResult';
				break;
			case 'Array(3)':
				kernelResultDeclaration = 'vec3 kernelResult';
				break;
			case 'Array(4)':
				kernelResultDeclaration = 'vec4 kernelResult';
				break;
			case 'LiteralInteger':
			case 'Float':
			case 'Number':
			case 'Integer':
				kernelResultDeclaration = 'float kernelResult';
				break;
			default:
				if (this.graphical) {
					kernelResultDeclaration = 'float kernelResult';
				} else {
					throw new Error(`unrecognized output type "${ this.returnType }"`);
				}
		}

		const result = [];
		const subKernels = this.subKernels;
		if (subKernels !== null) {
			result.push(
				kernelResultDeclaration
			);
			for (let i = 0; i < subKernels.length; i++) {
				result.push(
					`float subKernelResult_${ subKernels[i].name } = 0.0`
				);
			}
		} else {
			result.push(
				kernelResultDeclaration
			);
		}

		return utils.linesToString(result) + this.translatedSource;
	}

	getMainResultGraphical() {
		return utils.linesToString([
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  gl_FragColor = actualColor',
		]);
	}

	getMainResultPackedPixels() {
		switch (this.returnType) {
			case 'LiteralInteger':
			case 'Number':
			case 'Integer':
			case 'Float':
				return utils.linesToString(this.getMainResultKernelPackedPixels()) +
					utils.linesToString(this.getMainResultSubKernelPackedPixels());
			default:
				throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
		}
	}

	getMainResultKernelPackedPixels() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  gl_FragData[0] = encode32(kernelResult)'
		];
	}

	getMainResultSubKernelPackedPixels() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; i++) {
			result.push(
				`  gl_FragData[${i + 1}] = encode32(subKernelResult_${this.subKernels[i].name})`
			);
		}
		return result;
	}

	getMainResultMemoryOptimizedFloats() {
		const result = [
			'  index *= 4',
		];

		switch (this.returnType) {
			case 'Number':
			case 'Integer':
			case 'Float':
				const channels = ['r', 'g', 'b', 'a'];
				for (let i = 0; i < channels.length; i++) {
					const channel = channels[i];
					this.getMainResultKernelMemoryOptimizedFloats(result, channel);
					this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
					if (i + 1 < channels.length) {
						result.push('  index += 1');
					}
				}
				break;
			default:
				throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
		}

		return utils.linesToString(result);
	}

	getMainResultKernelMemoryOptimizedFloats(result, channel) {
		result.push(
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			`  gl_FragData[0].${channel} = kernelResult`,
		);
	}

	getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; i++) {
			result.push(
				`  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`,
			);
		}
	}

	getMainResultKernelNumberTexture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  gl_FragData[0][0] = kernelResult',
		];
	}

	getMainResultSubKernelNumberTexture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}`,
			);
		}
		return result;
	}

	getMainResultKernelArray2Texture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  gl_FragData[0][0] = kernelResult[0]',
			'  gl_FragData[0][1] = kernelResult[1]',
		];
	}

	getMainResultSubKernelArray2Texture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
				`  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
			);
		}
		return result;
	}

	getMainResultKernelArray3Texture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  gl_FragData[0][0] = kernelResult[0]',
			'  gl_FragData[0][1] = kernelResult[1]',
			'  gl_FragData[0][2] = kernelResult[2]',
		];
	}

	getMainResultSubKernelArray3Texture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
				`  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
				`  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
			);
		}
		return result;
	}

	getMainResultKernelArray4Texture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  gl_FragData[0] = kernelResult',
		];
	}

	getMainResultSubKernelArray4Texture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`,
			);
		}
		return result;
	}

	/**
	 * @desc Get main result string with checks for precision, graphical, subKernelsResults, etc.
	 * @returns {String} result
	 */
	_getMainResultString() {
		const {
			subKernels,
			precision,
			floatTextures,
			graphical,
			pipeline
		} = this;
		const result = [];

		if (precision === 'single') {
			result.push('  index *= 4');
		}

		if (graphical) {
			result.push(
				'  threadId = indexTo3D(index, uOutputDim)',
				'  kernel()',
				'  gl_FragColor = actualColor',
			);
		} else if (precision === 'single') {
			const channels = ['r', 'g', 'b', 'a'];

			for (let i = 0; i < channels.length; ++i) {
				result.push('  threadId = indexTo3D(index, uOutputDim)');
				result.push('  kernel()');

				if (subKernels) {
					result.push(`  gl_FragData[0].${channels[i]} = kernelResult`);

					for (let j = 0; j < subKernels.length; ++j) {
						result.push(`  gl_FragData[${j + 1}].${channels[i]} = subKernelResult_${subKernels[j].name}`);
					}
				} else {
					result.push(`  gl_FragColor.${channels[i]} = kernelResult`);
				}

				if (i < channels.length - 1) {
					result.push('  index += 1');
				}
			}
		} else if (subKernels !== null) {
			result.push('  threadId = indexTo3D(index, uOutputDim)');
			result.push('  kernel()');
			result.push('  gl_FragData[0] = encode32(kernelResult)');
			for (let i = 0; i < subKernels.length; i++) {
				result.push(`  gl_FragData[${i + 1}] = encode32(subKernelResult_${subKernels[i].name})`);
			}
		} else {
			result.push(
				'  threadId = indexTo3D(index, uOutputDim)',
				'  kernel()',
				'  gl_FragColor = encode32(kernelResult)',
			);
		}

		return utils.linesToString(result);
	}

	/**
	 * @param {String} src - Shader string
	 * @param {Object} map - Variables/Constants associated with shader
	 */
	replaceArtifacts(src, map) {
		return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z])*)__;\n/g, (match, artifact) => {
			if (map.hasOwnProperty(artifact)) {
				return map[artifact];
			}
			throw `unhandled artifact ${artifact}`;
		});
	}

	/**
	 * @desc Get the fragment shader String.
	 * If the String hasn't been compiled yet,
	 * then this method compiles it as well
	 *
	 * @param {Array} args - The actual parameters sent to the Kernel
	 * @returns {string} Fragment Shader string
	 */
	getFragmentShader(args) {
		if (this.compiledFragmentShader !== null) {
			return this.compiledFragmentShader;
		}
		return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
	}

	/**
	 * @desc Get the vertical shader String
	 * @param {Array|IArguments} args - The actual parameters sent to the Kernel
	 * @returns {string} Vertical Shader string
	 */
	getVertexShader(args) {
		if (this.compiledVertexShader !== null) {
			return this.compiledVertexShader;
		}
		return this.compiledVertexShader = this.constructor.vertexShader;
	}

	/**
	 * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.
	 */
	toString() {
		return webGLKernelString(this);
	}

	destroy(removeCanvasReferences) {
		if (this.outputTexture) {
			this.context.deleteTexture(this.outputTexture);
		}
		if (this.buffer) {
			this.context.deleteBuffer(this.buffer);
		}
		if (this.framebuffer) {
			this.context.deleteFramebuffer(this.framebuffer);
		}
		if (this.vertShader) {
			this.context.deleteShader(this.vertShader);
		}
		if (this.fragShader) {
			this.context.deleteShader(this.fragShader);
		}
		if (this.program) {
			this.context.deleteProgram(this.program);
		}

		const keys = Object.keys(this.textureCache);

		for (let i = 0; i < keys.length; i++) {
			const name = keys[i];
			this.context.deleteTexture(this.textureCache[name]);
		}

		if (this.subKernelOutputTextures) {
			for (let i = 0; i < this.subKernelOutputTextures.length; i++) {
				this.context.deleteTexture(this.subKernelOutputTextures[i]);
			}
		}
		if (removeCanvasReferences) {
			const idx = canvases.indexOf(this.canvas);
			if (idx >= 0) {
				canvases[idx] = null;
				maxTexSizes[idx] = null;
			}
		}
		this.destroyExtensions();
		delete this.context;
		delete this.canvas;
	}

	destroyExtensions() {
		this.extensions.OES_texture_float = null;
		this.extensions.OES_texture_float_linear = null;
		this.extensions.OES_element_index_uint = null;
		this.extensions.WEBGL_draw_buffers = null;
	}

	static destroyContext(context) {
		const extension = context.getExtension('WEBGL_lose_context');
		if (extension) {
			extension.loseContext();
		}
	}

	toJSON() {
		const json = super.toJSON();
		json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
		return json;
	}
}

module.exports = {
	WebGLKernel
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl/vertex-shader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl/vertex-shader.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const vertexShader = `precision highp float;
precision highp int;
precision highp sampler2D;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
	vertexShader
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl2/fragment-shader.js":
/*!********************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl2/fragment-shader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const fragmentShader = `#version 300 es
__HEADER__;
precision highp float;
precision highp int;
precision highp sampler2D;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
	int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 encode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0 - exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent * 0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + (texDim.x * (xyz.y + (texDim.y * xyz.z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + (texDim.x * (xyz.y + (texDim.y * xyz.z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + (texDim.x * (xyz.y + (texDim.y * xyz.z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  ivec3 xyz = ivec3(x, y, z);
  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
	fragmentShader
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl2/function-node.js":
/*!******************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl2/function-node.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	WebGLFunctionNode
} = __webpack_require__(/*! ../web-gl/function-node */ "./node_modules/gpu.js/src/backend/web-gl/function-node.js");

/**
 * @class WebGL2FunctionNode
 * @desc [INTERNAL] Takes in a function node, and does all the AST voodoo required to toString its respective webGL code.
 * @extends WebGLFunctionNode
 * @returns the converted webGL function string
 */
class WebGL2FunctionNode extends WebGLFunctionNode {

	/**
	 * @desc Parses the abstract syntax tree for *identifier* expression
	 * @param {Object} idtNode - An ast Node
	 * @param {Array} retArr - return array string
	 * @returns {Array} the append retArr
	 */
	astIdentifierExpression(idtNode, retArr) {
		if (idtNode.type !== 'Identifier') {
			throw this.astErrorOutput(
				'IdentifierExpression - not an Identifier',
				idtNode
			);
		}

		const type = this.getType(idtNode);

		if (idtNode.name === 'Infinity') {
			retArr.push('intBitsToFloat(2139095039)');
		} else if (type === 'Boolean') {
			if (this.argumentNames.indexOf(idtNode.name) > -1) {
				retArr.push(`bool(user_${idtNode.name})`);
			} else {
				retArr.push(`user_${idtNode.name}`);
			}
		} else {
			const userArgumentName = this.getKernelArgumentName(idtNode.name);
			if (userArgumentName) {
				retArr.push(`user_${userArgumentName}`);
			} else {
				retArr.push(`user_${idtNode.name}`);
			}
		}

		return retArr;
	}
}

module.exports = {
	WebGL2FunctionNode
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl2/kernel.js":
/*!***********************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl2/kernel.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	WebGLKernel
} = __webpack_require__(/*! ../web-gl/kernel */ "./node_modules/gpu.js/src/backend/web-gl/kernel.js");
const {
	WebGL2FunctionNode
} = __webpack_require__(/*! ./function-node */ "./node_modules/gpu.js/src/backend/web-gl2/function-node.js");
const {
	FunctionBuilder
} = __webpack_require__(/*! ../function-builder */ "./node_modules/gpu.js/src/backend/function-builder.js");
const {
	utils
} = __webpack_require__(/*! ../../utils */ "./node_modules/gpu.js/src/utils.js");
const {
	Texture
} = __webpack_require__(/*! ../../texture */ "./node_modules/gpu.js/src/texture.js");
const {
	fragmentShader
} = __webpack_require__(/*! ./fragment-shader */ "./node_modules/gpu.js/src/backend/web-gl2/fragment-shader.js");
const {
	vertexShader
} = __webpack_require__(/*! ./vertex-shader */ "./node_modules/gpu.js/src/backend/web-gl2/vertex-shader.js");

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

class WebGL2Kernel extends WebGLKernel {
	static get isSupported() {
		if (isSupported !== null) {
			return isSupported;
		}
		this.setupFeatureChecks();
		isSupported = this.isContextMatch(testContext);
		return isSupported;
	}

	static setupFeatureChecks() {
		if (typeof document !== 'undefined') {
			testCanvas = document.createElement('canvas');
		} else if (typeof OffscreenCanvas !== 'undefined') {
			testCanvas = new OffscreenCanvas(0, 0);
		}
		if (!testCanvas) return;
		testContext = testCanvas.getContext('webgl2');
		if (!testContext || !testContext.getExtension) return;
		testExtensions = {
			EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
			OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
		};
		features = this.getFeatures();
	}

	static isContextMatch(context) {
		// from global
		if (typeof WebGL2RenderingContext !== 'undefined') {
			return context instanceof WebGL2RenderingContext;
		}
		return false;
	}

	static getFeatures() {
		return Object.freeze({
			isFloatRead: this.getIsFloatRead(),
			isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
			kernelMap: true,
			isTextureFloat: true,
		});
	}

	static getIsTextureFloat() {
		return true;
	}

	static getIsIntegerDivisionAccurate() {
		return super.getIsIntegerDivisionAccurate();
	}

	static get testCanvas() {
		return testCanvas;
	}

	static get testContext() {
		return testContext;
	}

	static get features() {
		return features;
	}

	static get fragmentShader() {
		return fragmentShader;
	}
	static get vertexShader() {
		return vertexShader;
	}

	initContext() {
		const settings = {
			alpha: false,
			depth: false,
			antialias: false
		};
		const context = this.canvas.getContext('webgl2', settings);
		return context;
	}

	initExtensions() {
		this.extensions = {
			EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
			OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
		};
	}

	validateSettings() {
		if (!this.validate) {
			this.texSize = utils.dimToTexSize({
				floatTextures: this.optimizeFloatMemory,
				floatOutput: this.precision === 'single',
			}, this.output, true);
			return;
		}

		const features = this.constructor.features;
		if (this.precision === 'single' && this.floatOutputForce !== true && !features.isFloatRead) {
			throw new Error('Float texture outputs are not supported');
		} else if (!this.graphical && this.precision === null) {
			this.precision = features.isFloatRead ? 'single' : 'unsigned';
		}

		if (this.fixIntegerDivisionAccuracy === null) {
			this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
		} else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
			this.fixIntegerDivisionAccuracy = false;
		}

		this.checkOutput();

		if (!this.output || this.output.length === 0) {
			if (arguments.length !== 1) {
				throw new Error('Auto output only supported for kernels with only one input');
			}

			const argType = utils.getVariableType(arguments[0]);
			switch (argType) {
				case 'Array':
					this.output = utils.getDimensions(argType);
					break;
				case 'NumberTexture':
				case 'MemoryOptimizedNumberTexture':
				case 'ArrayTexture(1)':
				case 'ArrayTexture(2)':
				case 'ArrayTexture(3)':
				case 'ArrayTexture(4)':
					this.output = arguments[0].output;
					break;
				default:
					throw new Error('Auto output not supported for input type: ' + argType);
			}
		}

		if (this.graphical) {
			if (this.output.length !== 2) {
				throw new Error('Output must have 2 dimensions on graphical mode');
			}

			if (this.precision === 'single') {
				console.warn('Cannot use graphical mode and single precision at the same time');
				this.precision = 'unsigned';
			}

			this.texSize = utils.clone(this.output);
			return;
		} else if (!this.graphical && this.precision === null && features.isTextureFloat) {
			this.precision = 'single';
		}

		this.texSize = utils.dimToTexSize({
			floatTextures: !this.optimizeFloatMemory,
			floatOutput: this.precision === 'single',
		}, this.output, true);

		if (this.precision === 'single' || this.floatOutputForce) {
			this.context.getExtension('EXT_color_buffer_float');
		}
	}

	translateSource() {
		const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
			fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
		});
		this.translatedSource = functionBuilder.getPrototypeString('kernel');
		if (!this.graphical && !this.returnType) {
			this.returnType = functionBuilder.getKernelResultType();
		}
	}

	run() {
		if (this.program === null) {
			this.build.apply(this, arguments);
		}
		const {
			argumentNames,
			argumentTypes,
			texSize
		} = this;
		const gl = this.context;

		gl.useProgram(this.program);
		gl.scissor(0, 0, texSize[0], texSize[1]);

		if (!this.hardcodeConstants) {
			this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
			this.setUniform2iv('uTexSize', texSize);
		}

		this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

		this.argumentsLength = 0;
		for (let texIndex = 0; texIndex < argumentNames.length; texIndex++) {
			this.addArgument(arguments[texIndex], argumentTypes[texIndex], argumentNames[texIndex]);
		}

		if (this.plugins) {
			for (let i = 0; i < this.plugins.length; i++) {
				const plugin = this.plugins[i];
				if (plugin.onBeforeRun) {
					plugin.onBeforeRun(this);
				}
			}
		}

		if (this.graphical) {
			if (this.pipeline) {
				gl.bindRenderbuffer(gl.RENDERBUFFER, null);
				gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
				if (!this.outputTexture || this.immutable) {
					this._setupOutputTexture();
				}
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				return new Texture({
					texture: this.outputTexture,
					size: texSize,
					dimensions: this.threadDim,
					output: this.output,
					context: this.context,
					gpu: this.gpu,
					type: this.getReturnTextureType(),
				});
			}
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			return;
		}

		gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
		if (this.immutable) {
			this._setupOutputTexture();
		}

		if (this.subKernels !== null) {
			if (this.immutable) {
				this.subKernelOutputTextures = [];
				this._setupSubOutputTextures(this.subKernels.length);
			}
			gl.drawBuffers(this.drawBuffersMap);
		}

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

		if (this.subKernelOutputTextures !== null) {
			if (this.subKernels !== null) {
				const output = {
					result: this.renderOutput()
				};
				if (this.pipeline) {
					for (let i = 0; i < this.subKernels.length; i++) {
						output[this.subKernels[i].property] = new Texture({
							texture: this.subKernelOutputTextures[i],
							size: texSize,
							dimensions: this.threadDim,
							output: this.output,
							context: this.context,
							gpu: this.gpu,
							type: this.getReturnTextureType(),
						});
					}
				} else {
					for (let i = 0; i < this.subKernels.length; i++) {
						output[this.subKernels[i].property] = new Texture({
							texture: this.subKernelOutputTextures[i],
							size: texSize,
							dimensions: this.threadDim,
							output: this.output,
							context: this.context,
							gpu: this.gpu,
							type: this.getReturnTextureType(),
						}).toArray();
					}
				}
				return output;
			}
		}

		return this.renderOutput();
	}

	drawBuffers() {
		this.context.drawBuffers(this.drawBuffersMap);
	}

	getOutputTexture() {
		return this.outputTexture;
	}

	_setupOutputTexture() {
		const {
			texSize
		} = this;
		const gl = this.context;
		const texture = this.outputTexture = gl.createTexture();
		gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentNames.length);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		if (this.precision === 'single') {
			if (this.pipeline) {
				switch (this.returnType) {
					case 'Number':
					case 'Float':
					case 'Integer':
						if (this.optimizeFloatMemory) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
						} else {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, texSize[0], texSize[1], 0, gl.RED, gl.FLOAT, null);
						}
						break;
					case 'Array(2)':
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, texSize[0], texSize[1], 0, gl.RG, gl.FLOAT, null);
						break;
					case 'Array(3)':
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB32F, texSize[0], texSize[1], 0, gl.RGB, gl.FLOAT, null);
						break;
					case 'Array(4)':
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
						break;
					default:
						throw new Error('Unhandled return type');
				}
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
			}
		} else {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		}
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
	}

	_setupSubOutputTextures(length) {
		const {
			texSize
		} = this;
		const gl = this.context;
		const drawBuffersMap = this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
		const textures = this.subKernelOutputTextures = [];
		for (let i = 0; i < length; i++) {
			const texture = this.context.createTexture();
			textures.push(texture);
			drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
			gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentNames.length + i);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			// TODO: upgrade this
			if (this.precision === 'single') {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			}
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
		}
	}


	/**
	 * @desc Adds kernel parameters to the Argument Texture,
	 * binding it to the context, etc.
	 *
	 * @param {Array|Texture|Number|Input} value - The actual argument supplied to the kernel
	 * @param {String} type - Type of the argument
	 * @param {String} name - Name of the argument
	 */
	addArgument(value, type, name) {
		const gl = this.context;
		const argumentTexture = this.getArgumentTexture(name);
		if (value instanceof Texture) {
			type = value.type;
		}
		switch (type) {
			case 'Array':
			case 'Array(2)':
			case 'Array(3)':
			case 'Array(4)':
			case 'Array2D':
			case 'Array3D':
				{
					const dim = utils.getDimensions(value, true);
					const bitRatio = this.argumentBitRatios[this.argumentsLength];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						const valuesFlat = this.formatArrayTransfer(value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					}
					break;
				}
			case 'Integer':
			case 'Float':
			case 'Number':
				{
					this.setUniform1f(`user_${name}`, value);
					break;
				}
			case 'Input':
				{
					const input = value;
					const dim = utils.getDimensions(input, true);
					const bitRatio = this.argumentBitRatios[this.argumentsLength];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						const valuesFlat = this.formatArrayTransfer(input.value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(input.value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`user_${name}Dim`, dim);
							this.setUniform2iv(`user_${name}Size`, textureSize);
						}
						this.setUniform1i(`user_${name}`, this.argumentsLength);
					}
					break;
				}
			case 'HTMLImage':
				{
					const inputImage = value;
					const dim = [inputImage.width, inputImage.height, 1];
					const size = [inputImage.width, inputImage.height];

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
					gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					// Upload the image into the texture.
					const mipLevel = 0; // the largest mip
					const internalFormat = gl.RGBA; // format we want in the texture
					const srcFormat = gl.RGBA; // format of data we are supplying
					const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
					gl.texImage2D(gl.TEXTURE_2D,
						mipLevel,
						internalFormat,
						srcFormat,
						srcType,
						inputImage);
					this.setUniform3iv(`user_${name}Dim`, dim);
					this.setUniform2iv(`user_${name}Size`, size);
					this.setUniform1i(`user_${name}`, this.argumentsLength);
					break;
				}
			case 'HTMLImageArray':
				{
					const inputImages = value;
					const dim = [inputImages[0].width, inputImages[0].height, inputImages.length];
					const size = [inputImages[0].width, inputImages[0].height];

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
					gl.bindTexture(gl.TEXTURE_2D_ARRAY, argumentTexture);
					gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					// Upload the images into the texture.
					const mipLevel = 0; // the largest mip
					const internalFormat = gl.RGBA; // format we want in the texture
					const width = inputImages[0].width;
					const height = inputImages[0].height;
					const textureDepth = inputImages.length;
					const border = 0;
					const srcFormat = gl.RGBA; // format of data we are supplying
					const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
					gl.texImage3D(
						gl.TEXTURE_2D_ARRAY,
						mipLevel,
						internalFormat,
						width,
						height,
						textureDepth,
						border,
						srcFormat,
						srcType,
						null
					);
					for (let i = 0; i < inputImages.length; i++) {
						const xOffset = 0;
						const yOffset = 0;
						const imageDepth = 1;
						gl.texSubImage3D(
							gl.TEXTURE_2D_ARRAY,
							mipLevel,
							xOffset,
							yOffset,
							i,
							inputImages[i].width,
							inputImages[i].height,
							imageDepth,
							srcFormat,
							srcType,
							inputImages[i]
						);
					}
					this.setUniform3iv(`user_${name}Dim`, dim);
					this.setUniform2iv(`user_${name}Size`, size);
					this.setUniform1i(`user_${name}`, this.argumentsLength);
					break;
				}
			case 'ArrayTexture(1)':
			case 'ArrayTexture(2)':
			case 'ArrayTexture(3)':
			case 'ArrayTexture(4)':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`argument ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

					this.setUniform3iv(`user_${name}Dim`, dim);
					this.setUniform2iv(`user_${name}Size`, size);
					this.setUniform1i(`user_${name}`, this.argumentsLength);
					break;
				}
			case 'MemoryOptimizedNumberTexture':
			case 'NumberTexture':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`argument ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

					this.setUniform3iv(`user_${name}Dim`, dim);
					this.setUniform2iv(`user_${name}Size`, size);
					this.setUniform1i(`user_${name}`, this.argumentsLength);
					break;
				}
			case 'Boolean':
				{
					this.setUniform1i(`user_${name}`, value ? 1 : 0);
					break;
				}
			default:
				throw new Error('Argument type not supported: ' + value);
		}
		this.argumentsLength++;
	}

	_getMainConstantsString() {
		const result = [];
		if (this.constants) {
			for (let name in this.constants) {
				if (!this.constants.hasOwnProperty(name)) continue;
				let value = this.constants[name];
				let type = utils.getVariableType(value);
				switch (type) {
					case 'Integer':
						result.push('const int constants_' + name + ' = ' + parseInt(value));
						break;
					case 'Float':
						result.push('const float constants_' + name + ' = ' + parseFloat(value));
						break;
					case 'Array':
					case 'Input':
					case 'HTMLImage':
					case 'ArrayTexture(1)':
					case 'ArrayTexture(2)':
					case 'ArrayTexture(3)':
					case 'ArrayTexture(4)':
					case 'NumberTexture':
						result.push(
							`uniform highp sampler2D constants_${ name }`,
							`uniform highp ivec2 constants_${ name }Size`,
							`uniform highp ivec3 constants_${ name }Dim`,
						);
						break;
					case 'HTMLImageArray':
						result.push(
							`uniform highp sampler2DArray constants_${ name }`,
							`uniform highp ivec2 constants_${ name }Size`,
							`uniform highp ivec3 constants_${ name }Dim`,
						);
						break;
					case 'Boolean':
						result.push('const bool constants_' + name + ' = ' + (value ? 'true' : 'false'));
						break;
					default:
						throw new Error(`Unsupported constant ${ name } type ${ type }`);
				}
			}
		}
		return utils.linesToString(result);
	}

	/**
	 * @desc Adds kernel parameters to the Argument Texture,
	 * binding it to the context, etc.
	 *
	 * @param {Array|Texture|Number} value - The actual argument supplied to the kernel
	 * @param {String} type - Type of the argument
	 * @param {String} name - Name of the argument
	 */
	addConstant(value, type, name) {
		const gl = this.context;
		const constantTexture = this.getArgumentTexture(name);
		if (value instanceof Texture) {
			type = value.type;
		}
		switch (type) {
			case 'Array':
			case 'Array(2)':
			case 'Array(3)':
			case 'Array(4)':
			case 'Array2D':
			case 'Array3D':
				{
					const dim = utils.getDimensions(value, true);
					const bitRatio = this.constantBitRatios[name];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						const valuesFlat = this.formatArrayTransfer(value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.constantsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.constantsLength);
					}
				}
				break;
			case 'Input':
				{
					const input = value;
					const dim = utils.getDimensions(input, true);
					const bitRatio = this.constantBitRatios[name];
					if (this.precision === 'single') {
						const textureSize = utils.getMemoryOptimizedFloatTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						const length = textureSize[0] * textureSize[1] * bitRatio;
						// TODO: better handle 16 and 8 bit?
						// const ext = gl.getExtension('OES_texture_half_float');
						const valuesFlat = this.formatArrayTransfer(input.value, length, Float32Array);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, textureSize[0], textureSize[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.constantsLength);
					} else {
						const textureSize = utils.getMemoryOptimizedPackedTextureSize(dim, bitRatio);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, constantTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						const length = textureSize[0] * textureSize[1] * (4 / bitRatio);
						const valuesFlat = this.formatArrayTransfer(input.value, length);
						const buffer = new Uint8Array(valuesFlat.buffer);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize[0], textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);

						if (!this.hardcodeConstants) {
							this.setUniform3iv(`constants_${name}Dim`, dim);
							this.setUniform2iv(`constants_${name}Size`, textureSize);
						}
						this.setUniform1i(`constants_${name}`, this.argumentsLength);
					}
					break;
				}
			case 'HTMLImage':
				{
					const inputImage = value;
					const dim = [inputImage.width, inputImage.height, 1];
					const size = [inputImage.width, inputImage.height];

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
					gl.bindTexture(gl.TEXTURE_2D, constantTexture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					// Upload the image into the texture.
					const mipLevel = 0; // the largest mip
					const internalFormat = gl.RGBA; // format we want in the texture
					const srcFormat = gl.RGBA; // format of data we are supplying
					const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
					gl.texImage2D(gl.TEXTURE_2D,
						mipLevel,
						internalFormat,
						srcFormat,
						srcType,
						inputImage);
					this.setUniform3iv(`constants_${name}Dim`, dim);
					this.setUniform2iv(`constants_${name}Size`, size);
					this.setUniform1i(`constants_${name}`, this.constantsLength);
					break;
				}
			case 'HTMLImageArray':
				{
					const inputImages = value;
					const dim = [inputImages[0].width, inputImages[0].height, inputImages.length];
					const size = [inputImages[0].width, inputImages[0].height];

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
					gl.bindTexture(gl.TEXTURE_2D_ARRAY, constantTexture);
					gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					// Upload the images into the texture.
					const mipLevel = 0; // the largest mip
					const internalFormat = gl.RGBA; // format we want in the texture
					const width = inputImages[0].width;
					const height = inputImages[0].height;
					const textureDepth = inputImages.length;
					const border = 0;
					const srcFormat = gl.RGBA; // format of data we are supplying
					const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
					gl.texImage3D(
						gl.TEXTURE_2D_ARRAY,
						mipLevel,
						internalFormat,
						width,
						height,
						textureDepth,
						border,
						srcFormat,
						srcType,
						null
					);
					for (let i = 0; i < inputImages.length; i++) {
						const xOffset = 0;
						const yOffset = 0;
						const imageDepth = 1;
						gl.texSubImage3D(
							gl.TEXTURE_2D_ARRAY,
							mipLevel,
							xOffset,
							yOffset,
							i,
							inputImages[i].width,
							inputImages[i].height,
							imageDepth,
							srcFormat,
							srcType,
							inputImages[i]
						);
					}
					this.setUniform3iv(`constants_${name}Dim`, dim);
					this.setUniform2iv(`constants_${name}Size`, size);
					this.setUniform1i(`constants_${name}`, this.constantsLength);
					break;
				}
			case 'ArrayTexture(1)':
			case 'ArrayTexture(2)':
			case 'ArrayTexture(3)':
			case 'ArrayTexture(4)':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`constant ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

					this.setUniform3iv(`constants_${name}Dim`, dim);
					this.setUniform2iv(`constants_${name}Size`, size);
					this.setUniform1i(`constants_${name}`, this.constantsLength);
					break;
				}
			case 'MemoryOptimizedNumberTexture':
			case 'NumberTexture':
				{
					const inputTexture = value;
					if (inputTexture.context !== this.context) {
						throw new Error(`constant ${ name} (${ type }) must be from same context`);
					}
					const dim = inputTexture.dimensions;
					const size = inputTexture.size;

					gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
					gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

					this.setUniform3iv(`constants_${name}Dim`, dim);
					this.setUniform2iv(`constants_${name}Size`, size);
					this.setUniform1i(`constants_${name}`, this.constantsLength);
					break;
				}
			case 'Integer':
			case 'Float':
			default:
				throw new Error('constant type not supported: ' + value);
		}
		this.constantsLength++;
	}

	/**
	 *
	 * @desc Get the header string for the program.
	 * This returns an empty string if no sub-kernels are defined.
	 *
	 * @returns {String} result
	 */
	_getHeaderString() {
		return '';
	}

	/**
	 * @desc Get texture coordinate string for the program
	 * @returns {String} result
	 */
	_getTextureCoordinate() {
		const subKernels = this.subKernels;
		if (subKernels === null || subKernels.length < 1) {
			return 'in highp vec2 vTexCoord;\n';
		} else {
			return 'out highp vec2 vTexCoord;\n';
		}
	}

	/**
	 * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel
	 * @param {Array} args - The actual parameters sent to the Kernel
	 * @returns {String} result
	 */
	_getMainArgumentsString(args) {
		const result = [];
		const argumentTypes = this.argumentTypes;
		const argumentNames = this.argumentNames;
		for (let i = 0; i < argumentNames.length; i++) {
			const value = args[i];
			const name = argumentNames[i];
			const type = argumentTypes[i];
			if (this.hardcodeConstants) {
				switch (type) {
					case 'Array':
					case 'NumberTexture':
					case 'MemoryOptimizedNumberTexture':
					case 'ArrayTexture(1)':
					case 'ArrayTexture(2)':
					case 'ArrayTexture(3)':
					case 'ArrayTexture(4)':
					case 'Input':
					case 'HTMLImage':
						const dim = utils.getDimensions(value, true);
						const size = utils.dimToTexSize({
							floatTextures: this.optimizeFloatMemory,
							floatOutput: this.precision === 'single'
						}, dim);

						result.push(
							`uniform highp sampler2D user_${ name }`,
							`highp ivec2 user_${ name }Size = ivec2(${ size[0] }, ${ size[1] })`,
							`highp ivec3 user_${ name }Dim = ivec3(${ dim[0] }, ${ dim[1]}, ${ dim[2] })`,
						);
						break;
					case 'Integer':
						result.push(`highp float user_${ name } = ${ value }.0`);
						break;
					case 'Float':
					case 'Number':
						result.push(`highp float user_${ name } = ${ Number.isInteger(value) ? value + '.0' : value }`);
						break;
					case 'Boolean':
						result.push(`uniform int user_${name}`);
						break;
					default:
						throw new Error(`Argument type ${type} not supported in WebGL2`);
				}
			} else {
				switch (type) {
					case 'Array':
					case 'NumberTexture':
					case 'MemoryOptimizedNumberTexture':
					case 'ArrayTexture(1)':
					case 'ArrayTexture(2)':
					case 'ArrayTexture(3)':
					case 'ArrayTexture(4)':
					case 'Input':
					case 'HTMLImage':
						result.push(
							`uniform highp sampler2D user_${ name }`,
							`uniform highp ivec2 user_${ name }Size`,
							`uniform highp ivec3 user_${ name }Dim`
						);
						break;
					case 'HTMLImageArray':
						result.push(
							`uniform highp sampler2DArray user_${ name }`,
							`uniform highp ivec2 user_${ name }Size`,
							`uniform highp ivec3 user_${ name }Dim`
						);
						break;
					case 'Integer':
					case 'Float':
					case 'Number':
						result.push(`uniform float user_${ name }`);
						break;
					case 'Boolean':
						result.push(`uniform int user_${name}`);
						break;
					default:
						throw new Error(`Argument type ${type} not supported in WebGL2`);
				}
			}
		}
		return utils.linesToString(result);
	}

	/**
	 * @desc Get Kernel program string (in *glsl*) for a kernel.
	 * @returns {String} result
	 */
	getKernelString() {
		let kernelResultDeclaration;
		switch (this.returnType) {
			case 'Array(2)':
				kernelResultDeclaration = 'vec2 kernelResult';
				break;
			case 'Array(3)':
				kernelResultDeclaration = 'vec3 kernelResult';
				break;
			case 'Array(4)':
				kernelResultDeclaration = 'vec4 kernelResult';
				break;
			case 'LiteralInteger':
			case 'Float':
			case 'Number':
			case 'Integer':
				kernelResultDeclaration = 'float kernelResult';
				break;
			default:
				if (this.graphical) {
					kernelResultDeclaration = 'float kernelResult';
				} else {
					throw new Error(`unrecognized output type "${ this.returnType }"`);
				}
		}

		const result = [];
		const subKernels = this.subKernels;
		if (subKernels !== null) {
			result.push(
				kernelResultDeclaration,
				'layout(location = 0) out vec4 data0'
			);
			for (let i = 0; i < subKernels.length; i++) {
				result.push(
					`float subKernelResult_${ subKernels[i].name } = 0.0`,
					`layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
				);
			}
		} else {
			result.push(
				'out vec4 data0',
				kernelResultDeclaration
			);
		}

		return utils.linesToString(result) + this.translatedSource;
	}

	getMainResultGraphical() {
		return utils.linesToString([
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  data0 = actualColor',
		]);
	}

	getMainResultPackedPixels() {
		switch (this.returnType) {
			case 'LiteralInteger':
			case 'Number':
			case 'Integer':
			case 'Float':
				return utils.linesToString(this.getMainResultKernelPackedPixels()) +
					utils.linesToString(this.getMainResultSubKernelPackedPixels());
			default:
				throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
		}
	}

	getMainResultKernelPackedPixels() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  data0 = encode32(kernelResult)'
		];
	}

	getMainResultSubKernelPackedPixels() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; i++) {
			result.push(
				`  data${i + 1} = encode32(subKernelResult_${this.subKernels[i].name})`
			);
		}
		return result;
	}

	getMainResultMemoryOptimizedFloats() {
		const result = [
			'  index *= 4',
		];

		switch (this.returnType) {
			case 'Number':
			case 'Integer':
			case 'Float':
				const channels = ['r', 'g', 'b', 'a'];
				for (let i = 0; i < channels.length; i++) {
					const channel = channels[i];
					this.getMainResultKernelMemoryOptimizedFloats(result, channel);
					this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
					if (i + 1 < channels.length) {
						result.push('  index += 1');
					}
				}
				break;
			default:
				throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
		}

		return utils.linesToString(result);
	}

	getMainResultKernelMemoryOptimizedFloats(result, channel) {
		result.push(
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			`  data0.${channel} = kernelResult`,
		);
	}

	getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; i++) {
			result.push(
				`  data${i + 1}.${channel} = subKernelResult_${this.subKernels[i].name}`,
			);
		}
	}

	getMainResultKernelNumberTexture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  data0[0] = kernelResult',
		];
	}

	getMainResultSubKernelNumberTexture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  data${i + 1}[0] = subKernelResult_${this.subKernels[i].name}`,
			);
		}
		return result;
	}

	getMainResultKernelArray2Texture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  data0[0] = kernelResult[0]',
			'  data0[1] = kernelResult[1]',
		];
	}

	getMainResultSubKernelArray2Texture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  data${i + 1}[0] = subKernelResult_${this.subKernels[i].name}[0]`,
				`  data${i + 1}[1] = subKernelResult_${this.subKernels[i].name}[1]`,
			);
		}
		return result;
	}

	getMainResultKernelArray3Texture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  data0[0] = kernelResult[0]',
			'  data0[1] = kernelResult[1]',
			'  data0[2] = kernelResult[2]',
		];
	}

	getMainResultSubKernelArray3Texture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  data${i + 1}[0] = subKernelResult_${this.subKernels[i].name}[0]`,
				`  data${i + 1}[1] = subKernelResult_${this.subKernels[i].name}[1]`,
				`  data${i + 1}[2] = subKernelResult_${this.subKernels[i].name}[2]`,
			);
		}
		return result;
	}

	getMainResultKernelArray4Texture() {
		return [
			'  threadId = indexTo3D(index, uOutputDim)',
			'  kernel()',
			'  data0 = kernelResult',
		];
	}

	getMainResultSubKernelArray4Texture() {
		const result = [];
		if (!this.subKernels) return result;
		for (let i = 0; i < this.subKernels.length; ++i) {
			result.push(
				`  data${i + 1} = subKernelResult_${this.subKernels[i].name}`,
			);
		}
		return result;
	}

	/**
	 * @desc Get the fragment shader String.
	 * If the String hasn't been compiled yet,
	 * then this method compiles it as well
	 *
	 * @param {Array} args - The actual parameters sent to the Kernel
	 * @returns {string} Fragment Shader string
	 */
	getFragmentShader(args) {
		if (this.compiledFragmentShader !== null) {
			return this.compiledFragmentShader;
		}
		return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
	}

	/**
	 * @desc Get the vertical shader String
	 * @param {Array} args - The actual parameters sent to the Kernel
	 * @returns {string} Vertical Shader string
	 *
	 */
	getVertexShader(args) {
		if (this.compiledVertexShader !== null) {
			return this.compiledVertexShader;
		}
		return this.compiledVertexShader = this.constructor.vertexShader;
	}

	destroyExtensions() {
		this.extensions.EXT_color_buffer_float = null;
		this.extensions.OES_texture_float_linear = null;
	}

	toJSON() {
		const json = super.toJSON();
		json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
		return json;
	}
}

module.exports = {
	WebGL2Kernel
};

/***/ }),

/***/ "./node_modules/gpu.js/src/backend/web-gl2/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/gpu.js/src/backend/web-gl2/vertex-shader.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const vertexShader = `#version 300 es
precision highp float;
precision highp int;
precision highp sampler2D;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
	vertexShader
};

/***/ }),

/***/ "./node_modules/gpu.js/src/gpu.js":
/*!****************************************!*\
  !*** ./node_modules/gpu.js/src/gpu.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const gpuMock = __webpack_require__(/*! gpu-mock.js */ "./node_modules/gpu-mock.js/index.js");
const {
	utils
} = __webpack_require__(/*! ./utils */ "./node_modules/gpu.js/src/utils.js");
const {
	CPUKernel
} = __webpack_require__(/*! ./backend/cpu/kernel */ "./node_modules/gpu.js/src/backend/cpu/kernel.js");
const {
	HeadlessGLKernel
} = __webpack_require__(/*! ./backend/headless-gl/kernel */ "./node_modules/gpu.js/src/backend/headless-gl/kernel.js");
const {
	WebGL2Kernel
} = __webpack_require__(/*! ./backend/web-gl2/kernel */ "./node_modules/gpu.js/src/backend/web-gl2/kernel.js");
const {
	WebGLKernel
} = __webpack_require__(/*! ./backend/web-gl/kernel */ "./node_modules/gpu.js/src/backend/web-gl/kernel.js");
const {
	kernelRunShortcut
} = __webpack_require__(/*! ./kernel-run-shortcut */ "./node_modules/gpu.js/src/kernel-run-shortcut.js");


/**
 *
 * @type {Kernel[]}
 */
const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];

/**
 *
 * @type {string[]}
 */
const kernelTypes = ['gpu', 'cpu'];

const internalKernels = {
	'headlessgl': HeadlessGLKernel,
	'webgl2': WebGL2Kernel,
	'webgl': WebGLKernel,
};

let validate = true;

/**
 * The GPU.js library class which manages the GPU context for the creating kernels
 */
class GPU {
	static disableValidation() {
		validate = false;
	}

	static enableValidation() {
		validate = true;
	}

	static get isGPUSupported() {
		return kernelOrder.some(Kernel => Kernel.isSupported);
	}

	/**
	 *
	 * @returns {boolean}
	 */
	static get isKernelMapSupported() {
		return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
	}

	/**
	 * @desc TRUE is platform supports OffscreenCanvas
	 */
	static get isOffscreenCanvasSupported() {
		return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
	}

	/**
	 * @desc TRUE if platform supports WebGL
	 */
	static get isWebGLSupported() {
		return WebGLKernel.isSupported;
	}

	/**
	 * @desc TRUE if platform supports WebGL2
	 */
	static get isWebGL2Supported() {
		return WebGL2Kernel.isSupported;
	}

	/**
	 * @desc TRUE if platform supports HeadlessGL
	 */
	static get isHeadlessGLSupported() {
		return HeadlessGLKernel.isSupported;
	}

	/**
	 *
	 * @desc TRUE if platform supports Canvas
	 */
	static get isCanvasSupported() {
		return typeof HTMLCanvasElement !== 'undefined';
	}

	/**
	 * @desc TRUE if platform supports HTMLImageArray}
	 */
	static get isGPUHTMLImageArraySupported() {
		return WebGL2Kernel.isSupported;
	}

	/**
	 * @desc TRUE if platform supports single precision}
	 * @returns {boolean}
	 */
	static get isSinglePrecisionSupported() {
		return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
	}

	/**
	 * Creates an instance of GPU.
	 * @param {IGPUSettings} [settings] - Settings to set mode, and other properties
	 */
	constructor(settings) {
		settings = settings || {};
		this.canvas = settings.canvas || null;
		this.context = settings.context || null;
		this.mode = settings.mode;
		if (this.mode === 'dev') return;
		this.Kernel = null;
		this.kernels = [];
		this.functions = [];
		this.nativeFunctions = [];
		this.chooseKernel();
		// add functions from settings
		if (settings.functions) {
			for (let i = 0; i < settings.functions.length; i++) {
				this.addFunction(settings.functions[i]);
			}
		}

		// add native functions from settings
		if (settings.nativeFunctions) {
			for (const p in settings.nativeFunctions) {
				this.addNativeFunction(p, settings.nativeFunctions[p]);
			}
		}
	}

	/**
	 * Choose kernel type and save on .Kernel property of GPU
	 */
	chooseKernel() {
		if (this.Kernel) return;

		let Kernel = null;

		if (this.context) {
			for (let i = 0; i < kernelOrder.length; i++) {
				const ExternalKernel = kernelOrder[i];
				if (ExternalKernel.isContextMatch(this.context)) {
					if (!ExternalKernel.isSupported) {
						throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
					}
					Kernel = ExternalKernel;
					break;
				}
			}
			if (Kernel === null) {
				throw new Error('unknown Context');
			}
		} else if (this.mode) {
			if (this.mode in internalKernels) {
				if (internalKernels[this.mode].isSupported) {
					Kernel = internalKernels[this.mode];
				}
			} else if (this.mode === 'gpu') {
				for (let i = 0; i < kernelOrder.length; i++) {
					if (kernelOrder[i].isSupported) {
						Kernel = kernelOrder[i];
						break;
					}
				}
			} else if (this.mode === 'cpu') {
				Kernel = CPUKernel;
			}
			if (!Kernel) {
				throw new Error(`A requested mode of "${this.mode}" and is not supported`);
			}
		} else {
			for (let i = 0; i < kernelOrder.length; i++) {
				if (kernelOrder[i].isSupported) {
					Kernel = kernelOrder[i];
					break;
				}
			}
			if (!Kernel) {
				Kernel = CPUKernel;
			}
		}

		if (!this.mode) {
			this.mode = Kernel.mode;
		}
		this.Kernel = Kernel;
	}

	/**
	 * @desc This creates a callable function object to call the kernel function with the argument parameter set
	 * @param {Function|String|object} source - The calling to perform the conversion
	 * @param {Object} [settings] - The parameter configuration object
	 * @returns {Kernel} callable function to run
	 */
	createKernel(source, settings) {
		if (typeof source === 'undefined') {
			throw new Error('Missing source parameter');
		}
		if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
			throw new Error('source parameter not a function');
		}

		if (this.mode === 'dev') {
			return gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
		}

		source = typeof source === 'function' ? source.toString() : source;
		const mergedSettings = Object.assign({
			context: this.context,
			canvas: this.canvas,
			functions: this.functions,
			nativeFunctions: this.nativeFunctions,
			gpu: this,
			validate,
			onRequestFallback: (args) => {
				const fallbackKernel = new CPUKernel(source, mergedSettings);
				return fallbackKernel.apply(fallbackKernel, args);
			}
		}, upgradeDeprecatedCreateKernelSettings(settings) || {});

		const kernel = kernelRunShortcut(new this.Kernel(source, mergedSettings));

		//if canvas didn't come from this, propagate from kernel
		if (!this.canvas) {
			this.canvas = kernel.canvas;
		}

		//if context didn't come from this, propagate from kernel
		if (!this.context) {
			this.context = kernel.context;
		}

		this.kernels.push(kernel);

		return kernel;
	}

	/**
	 *
	 * Create a super kernel which executes sub kernels
	 * and saves their output to be used with the next sub kernel.
	 * This can be useful if we want to save the output on one kernel,
	 * and then use it as an input to another kernel. *Machine Learning*
	 *
	 * @param {Object|Array} subKernels - Sub kernels for this kernel
	 * @param {Function} rootKernel - Root kernel
	 *
	 * @returns {Function} callable kernel function
	 *
	 * @example
	 * const megaKernel = gpu.createKernelMap({
	 *   addResult: function add(a, b) {
	 *     return a[this.thread.x] + b[this.thread.x];
	 *   },
	 *   multiplyResult: function multiply(a, b) {
	 *     return a[this.thread.x] * b[this.thread.x];
	 *   },
	 *  }, function(a, b, c) {
	 *       return multiply(add(a, b), c);
	 * });
	 *
	 * megaKernel(a, b, c);
	 *
	 * Note: You can also define subKernels as an array of functions.
	 * > [add, multiply]
	 *
	 */
	createKernelMap() {
		let fn;
		let settings;
		if (typeof arguments[arguments.length - 2] === 'function') {
			fn = arguments[arguments.length - 2];
			settings = arguments[arguments.length - 1];
		} else {
			fn = arguments[arguments.length - 1];
		}

		if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
			if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
				throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
			}
		}

		const kernel = this.createKernel(fn, upgradeDeprecatedCreateKernelSettings(settings));
		if (Array.isArray(arguments[0])) {
			const functions = arguments[0];
			for (let i = 0; i < functions.length; i++) {
				const source = functions[i].toString();
				const name = utils.getFunctionNameFromString(source);
				kernel.addSubKernel({
					name,
					source,
					property: i,
				});
			}
		} else {
			const functions = arguments[0];
			for (let p in functions) {
				if (!functions.hasOwnProperty(p)) continue;
				const source = functions[p].toString();
				const name = utils.getFunctionNameFromString(source);
				kernel.addSubKernel({
					name: name || p,
					source,
					property: p,
				});
			}
		}

		return kernel;
	}

	/**
	 *
	 * Combine different kernels into one super Kernel,
	 * useful to perform multiple operations inside one
	 * kernel without the penalty of data transfer between
	 * cpu and gpu.
	 *
	 * The number of kernel functions sent to this method can be variable.
	 * You can send in one, two, etc.
	 *
	 * @param {Function} subKernels - Kernel function(s) to combine.
	 * @param {Function} rootKernel - Root kernel to combine kernels into
	 *
	 * @example
	 * 	combineKernels(add, multiply, function(a,b,c){
	 *	 	return add(multiply(a,b), c)
	 *	})
	 *
	 * @returns {Function} Callable kernel function
	 *
	 */
	combineKernels() {
		const firstKernel = arguments[0];
		const combinedKernel = arguments[arguments.length - 1];
		if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
		const canvas = arguments[0].canvas;
		const context = arguments[0].context;
		const max = arguments.length - 1;
		for (let i = 0; i < max; i++) {
			arguments[i]
				.setCanvas(canvas)
				.setContext(context)
				.setPipeline(true);
		}

		return function() {
			const texture = combinedKernel.apply(this, arguments);
			if (texture.toArray) {
				return texture.toArray();
			}
			return texture;
		};
	}

	/**
	 * @desc Adds additional functions, that the kernel may call.
	 * @param {Function|String} source - Javascript function to convert
	 * @param {IFunctionSettings} [settings]
	 * @returns {GPU} returns itself
	 */
	addFunction(source, settings) {
		this.functions.push(utils.functionToIFunction(source, settings));
		return this;
	}

	/**
	 * @desc Adds additional native functions, that the kernel may call.
	 * @param {String} name - native function name, used for reverse lookup
	 * @param {String} source - the native function implementation, as it would be defined in it's entirety
	 * @param {object} [settings]
	 * @returns {GPU} returns itself
	 */
	addNativeFunction(name, source, settings) {
		if (this.kernels.length > 0) {
			throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
		}
		settings = settings || {};
		const {
			argumentTypes,
			argumentNames
		} = this.Kernel.nativeFunctionArguments(source) || {};
		this.nativeFunctions.push({
			name,
			source,
			settings,
			argumentTypes,
			argumentNames,
			returnType: settings.returnType || this.Kernel.nativeFunctionReturnType(source),
		});
		return this;
	}

	/**
	 * @desc Destroys all memory associated with gpu.js & the webGl if we created it
	 */
	destroy() {
		// perform on next run loop - for some reason we dont get lose context events
		// if webGl is created and destroyed in the same run loop.
		setTimeout(() => {
			for (let i = 0; i < this.kernels.length; i++) {
				this.kernels[i].destroy(true); // remove canvas if exists
			}
			this.kernels[0].kernel.constructor.destroyContext(this.context);
		}, 0);
	}
}


function upgradeDeprecatedCreateKernelSettings(settings) {
	if (!settings) {
		return;
	}
	const upgradedSettings = Object.assign({}, settings);

	if (settings.hasOwnProperty('floatOutput')) {
		utils.warnDeprecated('setting', 'floatOutput', 'precision');
		upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
	}
	if (settings.hasOwnProperty('outputToTexture')) {
		utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
		upgradedSettings.pipeline = Boolean(settings.outputToTexture);
	}
	if (settings.hasOwnProperty('outputImmutable')) {
		utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
		upgradedSettings.immutable = Boolean(settings.outputImmutable);
	}
	if (settings.hasOwnProperty('floatTextures')) {
		utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
		upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
	}
	return upgradedSettings;
}

module.exports = {
	GPU,
	kernelOrder,
	kernelTypes
};

/***/ }),

/***/ "./node_modules/gpu.js/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/gpu.js/src/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	GPU
} = __webpack_require__(/*! ./gpu */ "./node_modules/gpu.js/src/gpu.js");
const {
	alias
} = __webpack_require__(/*! ./alias */ "./node_modules/gpu.js/src/alias.js");
const {
	utils
} = __webpack_require__(/*! ./utils */ "./node_modules/gpu.js/src/utils.js");
const {
	Input,
	input
} = __webpack_require__(/*! ./input */ "./node_modules/gpu.js/src/input.js");
const {
	Texture
} = __webpack_require__(/*! ./texture */ "./node_modules/gpu.js/src/texture.js");
const {
	FunctionBuilder
} = __webpack_require__(/*! ./backend/function-builder */ "./node_modules/gpu.js/src/backend/function-builder.js");
const {
	FunctionNode
} = __webpack_require__(/*! ./backend/function-node */ "./node_modules/gpu.js/src/backend/function-node.js");
const {
	CPUFunctionNode
} = __webpack_require__(/*! ./backend/cpu/function-node */ "./node_modules/gpu.js/src/backend/cpu/function-node.js");
const {
	CPUKernel
} = __webpack_require__(/*! ./backend/cpu/kernel */ "./node_modules/gpu.js/src/backend/cpu/kernel.js");

const {
	HeadlessGLKernel
} = __webpack_require__(/*! ./backend/headless-gl/kernel */ "./node_modules/gpu.js/src/backend/headless-gl/kernel.js");

const {
	WebGLFunctionNode
} = __webpack_require__(/*! ./backend/web-gl/function-node */ "./node_modules/gpu.js/src/backend/web-gl/function-node.js");
const {
	WebGLKernel
} = __webpack_require__(/*! ./backend/web-gl/kernel */ "./node_modules/gpu.js/src/backend/web-gl/kernel.js");

const {
	WebGL2FunctionNode
} = __webpack_require__(/*! ./backend/web-gl2/function-node */ "./node_modules/gpu.js/src/backend/web-gl2/function-node.js");
const {
	WebGL2Kernel
} = __webpack_require__(/*! ./backend/web-gl2/kernel */ "./node_modules/gpu.js/src/backend/web-gl2/kernel.js");

const {
	GLKernel
} = __webpack_require__(/*! ./backend/gl-kernel */ "./node_modules/gpu.js/src/backend/gl-kernel.js");

const {
	Kernel
} = __webpack_require__(/*! ./backend/kernel */ "./node_modules/gpu.js/src/backend/kernel.js");

module.exports = {
	alias,
	CPUFunctionNode,
	CPUKernel,
	GPU,
	FunctionBuilder,
	FunctionNode,
	HeadlessGLKernel,
	Input,
	input,
	Texture,
	utils,
	WebGL2FunctionNode,
	WebGL2Kernel,
	WebGLFunctionNode,
	WebGLKernel,
	GLKernel,
	Kernel,
};

/***/ }),

/***/ "./node_modules/gpu.js/src/input.js":
/*!******************************************!*\
  !*** ./node_modules/gpu.js/src/input.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class Input {
	constructor(value, size) {
		this.value = value;
		this.size = new Int32Array(3);
		if (Array.isArray(size)) {
			for (let i = 0; i < this.size.length; i++) {
				this.size[i] = size[i] || 1;
			}
		} else {
			if (size.z) {
				this.size = new Int32Array([size.x, size.y, size.z]);
			} else if (size.y) {
				this.size = new Int32Array([size.x, size.y, 1]);
			} else {
				this.size = new Int32Array([size.x, 1, 1]);
			}
		}

		const [h, w, d] = this.size;
		if (this.value.length !== (h * w * d)) {
			throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
		}
	}
}

function input(value, size) {
	return new Input(value, size);
}

module.exports = {
	Input,
	input
};

/***/ }),

/***/ "./node_modules/gpu.js/src/kernel-run-shortcut.js":
/*!********************************************************!*\
  !*** ./node_modules/gpu.js/src/kernel-run-shortcut.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	utils
} = __webpack_require__(/*! ./utils */ "./node_modules/gpu.js/src/utils.js");

function kernelRunShortcut(kernel) {
	const shortcut = function() {
		return kernel.run.apply(kernel, arguments);
	};

	utils
		.allPropertiesOf(kernel)
		.forEach((key) => {
			if (key[0] === '_' && key[1] === '_') return;
			if (typeof kernel[key] === 'function') {
				if (key.substring(0, 3) === 'add' || key.substring(0, 3) === 'set') {
					shortcut[key] = function() {
						kernel[key].apply(kernel, arguments);
						return shortcut;
					};
				} else if (key === 'requestFallback') {
					const requestFallback = kernel[key].bind(kernel);
					shortcut[key] = () => {
						kernel = requestFallback();
					};
				} else {
					shortcut[key] = kernel[key].bind(kernel);
				}
			} else {
				shortcut.__defineGetter__(key, () => {
					return kernel[key];
				});
				shortcut.__defineSetter__(key, (value) => {
					kernel[key] = value;
				});
			}
		});

	shortcut.kernel = kernel;

	return shortcut;
}

module.exports = {
	kernelRunShortcut
};

/***/ }),

/***/ "./node_modules/gpu.js/src/plugins/triangle-noise.js":
/*!***********************************************************!*\
  !*** ./node_modules/gpu.js/src/plugins/triangle-noise.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const source = `

uniform highp float triangle_noise_seed;
highp float triangle_noise_shift = 0.000001;

//https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0;1[
float nrand( vec2 n )
{
	return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}
//note: remaps v to [0;1] in interval [a;b]
float remap( float a, float b, float v )
{
	return clamp( (v-a) / (b-a), 0.0, 1.0 );
}

float n4rand( vec2 n )
{
	float t = fract( triangle_noise_seed + triangle_noise_shift );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );	
	float nrnd2 = nrand( n + 0.13*t );
	float nrnd3 = nrand( n + 0.17*t );
	float result = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;
	triangle_noise_shift = result + 0.000001;
	return result;
}`;

const name = 'triangle-noise-noise';

const functionMatch = 'Math.random()';

const functionReplace = 'n4rand(vTexCoord)';

const functionReturnType = 'Number';

const onBeforeRun = (kernel) => {
	kernel.setUniform1f('triangle_noise_seed', Math.random());
};

/**
 *
 * @type IPlugin
 */
module.exports = {
	name,
	onBeforeRun,
	functionMatch,
	functionReplace,
	functionReturnType,
	source
};

/***/ }),

/***/ "./node_modules/gpu.js/src/texture.js":
/*!********************************************!*\
  !*** ./node_modules/gpu.js/src/texture.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @desc WebGl Texture implementation in JS
 * @param {ITextureSettings} settings
 */
class Texture {
	constructor(settings) {
		const {
			texture,
			size,
			dimensions,
			output,
			context,
			gpu,
			type = 'NumberTexture',
		} = settings;
		if (!output) throw new Error('settings property "output" required.');
		if (!context) throw new Error('settings property "context" required.');
		this.texture = texture;
		this.size = size;
		this.dimensions = dimensions;
		this.output = output;
		this.context = context;
		this.gpu = gpu;
		this.kernel = null;
		this.type = type;
	}

	/**
	 * @desc Converts the Texture into a JavaScript Array.
	 * @param {GPU} [gpu]
	 * @returns {Number[]|Number[][]|Number[][][]}
	 */
	toArray(gpu) {
		let {
			kernel
		} = this;
		if (kernel) return kernel(this);
		gpu = gpu || this.gpu;
		if (!gpu) throw new Error('settings property "gpu" or argument required.');
		kernel = gpu.createKernel(function(x) {
			return x[this.thread.z][this.thread.y][this.thread.x];
		}, {
			output: this.output,
			precision: this.getPrecision(),
			optimizeFloatMemory: this.type === 'MemoryOptimizedNumberTexture',
		});

		this.kernel = kernel;
		return kernel(this);
	}

	getPrecision() {
		switch (this.type) {
			case 'NumberTexture':
				return 'unsigned';
			case 'MemoryOptimizedNumberTexture':
			case 'ArrayTexture(1)':
			case 'ArrayTexture(2)':
			case 'ArrayTexture(3)':
			case 'ArrayTexture(4)':
				return 'single';
			default:
				throw new Error('Unknown texture type');
		}
	}

	/**
	 * @desc Deletes the Texture
	 */
	delete() {
		return this.context.deleteTexture(this.texture);
	}
}

module.exports = {
	Texture
};

/***/ }),

/***/ "./node_modules/gpu.js/src/utils.js":
/*!******************************************!*\
  !*** ./node_modules/gpu.js/src/utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
	Input
} = __webpack_require__(/*! ./input */ "./node_modules/gpu.js/src/input.js");
const {
	Texture
} = __webpack_require__(/*! ./texture */ "./node_modules/gpu.js/src/texture.js");

const FUNCTION_NAME = /function ([^(]*)/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;

/**
 *
 * @desc Various utility functions / snippets of code that GPU.JS uses internally.
 * This covers various snippets of code that is not entirely gpu.js specific (ie. may find uses elsewhere)
 */
const utils = {
	/**
	 *
	 * @desc Gets the system endianness, and cache it
	 * @returns {String} 'LE' or 'BE' depending on system architecture
	 * Credit: https://gist.github.com/TooTallNate/4750953
	 */
	systemEndianness() {
		return _systemEndianness;
	},
	getSystemEndianness() {
		const b = new ArrayBuffer(4);
		const a = new Uint32Array(b);
		const c = new Uint8Array(b);
		a[0] = 0xdeadbeef;
		if (c[0] === 0xef) return 'LE';
		if (c[0] === 0xde) return 'BE';
		throw new Error('unknown endianness');
	},

	/**
	 * @descReturn TRUE, on a JS function
	 * @param {Function} funcObj - Object to validate if its a function
	 * @returns	{Boolean} TRUE if the object is a JS function
	 */
	isFunction(funcObj) {
		return typeof(funcObj) === 'function';
	},

	/**
	 * @desc Return TRUE, on a valid JS function string
	 * Note: This does just a VERY simply sanity check. And may give false positives.
	 *
	 * @param {String} fn - String of JS function to validate
	 * @returns {Boolean} TRUE if the string passes basic validation
	 */
	isFunctionString(fn) {
		if (typeof fn === 'string') {
			return (fn
				.slice(0, 'function'.length)
				.toLowerCase() === 'function');
		}
		return false;
	},

	/**
	 * @desc Return the function name from a JS function string
	 * @param {String} funcStr - String of JS function to validate
	 * @returns {String} Function name string (if found)
	 */
	getFunctionNameFromString(funcStr) {
		return FUNCTION_NAME.exec(funcStr)[1].trim();
	},

	getFunctionBodyFromString(funcStr) {
		return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
	},

	/**
	 * @desc Return list of argument names extracted from a javascript function
	 * @param {String} fn - String of JS function to validate
	 * @returns {String[]}  Array representing all the parameter names
	 */
	getArgumentNamesFromString(fn) {
		const fnStr = fn.replace(STRIP_COMMENTS, '');
		let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
		if (result === null) {
			result = [];
		}
		return result;
	},

	/**
	 * @desc Returns a clone
	 * @param {Object} obj - Object to clone
	 * @returns {Object|Array} Cloned object
	 */
	clone(obj) {
		if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

		const temp = obj.constructor(); // changed

		for (let key in obj) {
			if (Object.prototype.hasOwnProperty.call(obj, key)) {
				obj.isActiveClone = null;
				temp[key] = utils.clone(obj[key]);
				delete obj.isActiveClone;
			}
		}

		return temp;
	},

	/**
	 * @desc Checks if is an array or Array-like object
	 * @param {Object} array - The argument object to check if is array
	 * @returns {Boolean}  true if is array or Array-like object
	 */
	isArray(array) {
		return !isNaN(array.length);
	},

	/**
	 * @desc Evaluate the argument type, to apply respective logic for it
	 * @param {Object} value - The argument object to evaluate type
	 * @returns {String}  Argument type Array/Number/Float/Texture/Unknown
	 */
	getVariableType(value) {
		if (utils.isArray(value)) {
			if (value[0].nodeName === 'IMG') {
				return 'HTMLImageArray';
			}
			return 'Array';
		} else if (typeof value === 'number') {
			if (Number.isInteger(value)) {
				return 'Integer';
			}
			return 'Float';
		} else if (typeof value === 'boolean') {
			return 'Boolean';
		} else if (value instanceof Texture) {
			return value.type;
		} else if (value instanceof Input) {
			return 'Input';
		} else if (value.nodeName === 'IMG') {
			return 'HTMLImage';
		} else {
			return 'Unknown';
		}
	},


	dimToTexSize(opt, dimensions, output) {
		let [w, h, d] = dimensions;
		let texelCount = (w || 1) * (h || 1) * (d || 1);

		if (opt.floatTextures && (!output || opt.precision === 'single')) {
			w = texelCount = Math.ceil(texelCount / 4);
		}
		// if given dimensions == a 2d image
		if (h > 1 && w * h === texelCount) {
			return new Int32Array([w, h]);
		}
		return utils.closestSquareDimensions(texelCount);
	},

	/**
	 *
	 * @param {Number} length
	 * @returns {TextureDimensions}
	 */
	closestSquareDimensions(length) {
		const sqrt = Math.sqrt(length);
		let high = Math.ceil(sqrt);
		let low = Math.floor(sqrt);
		while (high * low < length) {
			high--;
			low = Math.ceil(length / high);
		}
		return new Int32Array([low, Math.ceil(length / low)]);
	},

	/**
	 * A texture takes up four
	 * @param {OutputDimensions} dimensions
	 * @param {Number} bitRatio
	 * @returns {TextureDimensions}
	 */
	getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
		const [w, h, d] = dimensions;
		const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
		const texelCount = totalArea / bitRatio;
		return utils.closestSquareDimensions(texelCount);
	},

	/**
	 *
	 * @param dimensions
	 * @param bitRatio
	 * @returns {*|TextureDimensions}
	 */
	getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
		const [w, h, d] = dimensions;
		const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
		const texelCount = totalArea / (4 / bitRatio);
		return utils.closestSquareDimensions(texelCount);
	},

	roundTo(n, d) {
		return Math.floor((n + d - 1) / d) * d;
	},
	/**
	 * @desc Return the dimension of an array.
	 * @param {Array|String|Texture|Input} x - The array
	 * @param {Boolean} [pad] - To include padding in the dimension calculation
	 * @returns {OutputDimensions}
	 */
	getDimensions(x, pad) {
		let ret;
		if (utils.isArray(x)) {
			const dim = [];
			let temp = x;
			while (utils.isArray(temp)) {
				dim.push(temp.length);
				temp = temp[0];
			}
			ret = dim.reverse();
		} else if (x instanceof Texture) {
			ret = x.output;
		} else if (x instanceof Input) {
			ret = x.size;
		} else {
			throw new Error(`Unknown dimensions of ${x}`);
		}

		if (pad) {
			ret = Array.from(ret);
			while (ret.length < 3) {
				ret.push(1);
			}
		}

		return new Int32Array(ret);
	},

	/**
	 * Puts a nested 2d array into a one-dimensional target array
	 * @param {Array|*} array
	 * @param {Float32Array|Float64Array} target
	 */
	flatten2dArrayTo(array, target) {
		let offset = 0;
		for (let y = 0; y < array.length; y++) {
			target.set(array[y], offset);
			offset += array[y].length;
		}
	},

	/**
	 * Puts a nested 3d array into a one-dimensional target array
	 * @param {Array|*} array
	 * @param {Float32Array|Float64Array} target
	 */
	flatten3dArrayTo(array, target) {
		let offset = 0;
		for (let z = 0; z < array.length; z++) {
			for (let y = 0; y < array[z].length; y++) {
				target.set(array[z][y], offset);
				offset += array[z][y].length;
			}
		}
	},

	/**
	 * Puts a nested 1d, 2d, or 3d array into a one-dimensional target array
	 * @param {Float32Array|Uint16Array|Uint8Array} array
	 * @param {Float32Array} target
	 */
	flattenTo(array, target) {
		if (utils.isArray(array[0])) {
			if (utils.isArray(array[0][0])) {
				utils.flatten3dArrayTo(array, target);
			} else {
				utils.flatten2dArrayTo(array, target);
			}
		} else {
			target.set(array);
		}
	},

	/**
	 *
	 * @desc Splits an array into smaller arrays.
	 * Number of elements in one small chunk is given by `part`
	 *
	 * @param {Number[]} array - The array to split into chunks
	 * @param {Number} part - elements in one chunk
	 *
	 * @returns {Number[]} An array of smaller chunks
	 */
	splitArray(array, part) {
		const result = [];
		for (let i = 0; i < array.length; i += part) {
			result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
		}
		return result;
	},

	getAstString(source, ast) {
		const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
		const start = ast.loc.start;
		const end = ast.loc.end;
		const result = [];
		result.push(lines[start.line - 1].slice(start.column));
		for (let i = start.line; i < end.line - 1; i++) {
			result.push(lines[i]);
		}
		result.push(lines[end.line - 1].slice(0, end.column));
		return result.join('\n');
	},

	allPropertiesOf(obj) {
		const props = [];

		do {
			props.push.apply(props, Object.getOwnPropertyNames(obj));
		} while (obj = Object.getPrototypeOf(obj));

		return props;
	},

	/**
	 * @param {Array} lines - An Array of strings
	 * @returns {String} Single combined String, seperated by *\n*
	 */
	linesToString(lines) {
		if (lines.length > 0) {
			return lines.join(';\n') + ';\n';
		} else {
			return '\n';
		}
	},
	warnDeprecated(type, oldName, newName) {
		if (newName) {
			console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
		} else {
			console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
		}
	},
	/**
	 *
	 * @param {String|Function} source
	 * @param {IFunctionSettings} [settings]
	 * @returns {IFunction}
	 */
	functionToIFunction(source, settings) {
		settings = settings || {};
		if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
		const sourceString = typeof source === 'string' ? source : source.toString();

		let argumentTypes = [];

		if (Array.isArray(settings.argumentTypes)) {
			argumentTypes = settings.argumentTypes;
		} else if (typeof settings.argumentTypes === 'object') {
			argumentTypes = utils.getArgumentNamesFromString(sourceString)
				.map(name => settings.argumentTypes[name]) || [];
		} else {
			argumentTypes = settings.argumentTypes || [];
		}

		return {
			source: sourceString,
			argumentTypes,
			returnType: settings.returnType || null,
		};
	}
};

const _systemEndianness = utils.getSystemEndianness();

module.exports = {
	utils
};

/***/ }),

/***/ "./src/matrix.js":
/*!***********************!*\
  !*** ./src/matrix.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gpu = __webpack_require__(/*! gpu.js */ "./node_modules/gpu.js/src/index.js");

var _curry = _interopRequireDefault(__webpack_require__(/*! fun.js/src/curry */ "./node_modules/fun.js/src/curry.js"));

var _map = _interopRequireDefault(__webpack_require__(/*! fun.js/src/map */ "./node_modules/fun.js/src/map.js"));

var _fold = _interopRequireDefault(__webpack_require__(/*! fun.js/src/fold */ "./node_modules/fun.js/src/fold.js"));

var _equals = _interopRequireDefault(__webpack_require__(/*! fun.js/src/equals */ "./node_modules/fun.js/src/equals.js"));

var _concat = _interopRequireDefault(__webpack_require__(/*! util/concat */ "./src/util/concat.js"));

var _empty = _interopRequireDefault(__webpack_require__(/*! util/empty */ "./src/util/empty.js"));

var _dot = _interopRequireDefault(__webpack_require__(/*! util/dot */ "./src/util/dot.js"));

var _identity = _interopRequireDefault(__webpack_require__(/*! util/identity */ "./src/util/identity.js"));

var _transpose = _interopRequireDefault(__webpack_require__(/*! util/transpose */ "./src/util/transpose.js"));

var _generate = _interopRequireDefault(__webpack_require__(/*! util/generate */ "./src/util/generate.js"));

var _gpumap = _interopRequireDefault(__webpack_require__(/*! util/gpumap */ "./src/util/gpumap.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class Matrix
 * @classdesc Matrix applicative providing standard matrix operations
 * @summary The Matrix class should not be instantiated with the new keyword. Instead use the Matrix.of syntax to create a new Matrix. Unfortunatly jsdocs does not allow for the constructor to be hidden.
 * @hidecontructor
 * @see of
 * @example
 *
 * const m =  Matrix.of([[1,2],[2,3],[4,5]])
 *
 */
var Matrix = function Matrix(val) {
  this.__value = val;
  this.gpu = new _gpu.GPU();
};
/**
 * @memberOf Matrix
 * @static
 * @function of
 * @desc Creates a Matrix object and flattens the Matrix
 * @param val {array|function} An array of arrays
 * @returns {Matrix}
 * @example
 *
 * const m =  Matrix.of([[1,2],[2,3],[4,5]])
 *
 */


Matrix.of = function (val) {
  if (val instanceof Matrix) return val;

  if (this instanceof Matrix) {
    this.__value = val;
    return this;
  }

  return new Matrix(val);
};
/**
 * @memberOf Matrix
 * @property {string} type
 * @type {string}
 * @example
 *
 * const m =  Matrix.of([[1,2],[2,3],[4,5]])
 * m.type === 'Matrix'
 */


Matrix.prototype.type = 'Matrix';
/**
 * @memberOf Matrix
 * @property {number} precision
 * @type {number}
 * @example
 *
 * const m =  Matrix.of([[1,2],[2,3],[4,5]])
 * m.precision === 4
 */

Matrix.prototype.precision = 4;
/**
 * @memberOf Matrix
 * @instance
 * @member setPrecision
 * @param precision {number} Set the number of decimals for rounding
 * @example
 *
 * const m =  Matrix.of([[1,2],[2,3],[4,5]])
 * m.setPrecision(10)
 * m.precision === 10
 */

Matrix.prototype.setPrecision = function (precision) {
  this.precision = precision;
};
/**
 * @memberOf Matrix
 * @instance
 * @member isSymmetric
 * @returns {boolean}
 * @example
 *
 * const A = Matrix.of([[1, 1], [1, 1]])
 * true === A.isSymmetric()
 *
 */


Matrix.prototype.isSymmetric = function () {
  var a = this.__value;

  var b = Matrix.transpose(this).__value;

  return (0, _equals.default)(a, b);
};
/**
 * @memberOf Matrix
 * @instance
 * @member isSquare
 * @desc Boolean indicating whether this contains a square Matrix
 * @returns {boolean}
 * @example
 *
 * const A = Matrix.of([[1, 1], [1, 1]])
 * true === A.isSquare()
 *
 */


Matrix.prototype.isSquare = function () {
  return (0, _equals.default)(this.getCols(), this.getRows());
};
/**
 * @memberOf Matrix
 * @instance
 * @member isOrthogonal
 * @param M {Matrix|array}
 * @returns {boolean}
 * @example
 *
 * const result = [[-0.3092, -0.9510], [-0.9510, 0.3092]]
 * const A = Matrix.fromArray(result)
 * true  === A.isOrthogonal()
 */


Matrix.prototype.isOrthogonal = function () {
  var AxAt = this.dot(this.transpose());
  var I = this.identity();
  return (0, _equals.default)(AxAt, I);
};
/**
 * @memberOf Matrix
 * @instance
 * @member getCols
 * @returns {Number}
 * @example
 *
 * const A = Matrix.of([[1, 1], [1, 1]])
 * A.getCols()  === 2
 *
 */


Matrix.prototype.getCols = function () {
  return this.__value[0].length;
};
/**
 * @memberOf Matrix
 * @instance
 * @member equals
 * @param M {Matrix|array}
 * @returns {Boolean}
 * @example
 *
 * var a = [[1, 1], [1, 1]]
 * var A = Matrix.of(a)
 * var B = Matrix.of(a)
 * true  === A.equals(B)
 */


Matrix.prototype.equals = function (M) {
  return (0, _equals.default)(this.__value, M.__value || M);
};
/**
 * @memberOf Matrix
 * @instance
 * @member getRows
 * @returns {Number}
 * @example
 *
 * const A = Matrix.of([[1, 1], [1, 1]])
 * A.getRows()  // 2
 */


Matrix.prototype.getRows = function () {
  return this.__value.length;
};
/**
 * @memberOf Matrix
 * @instance
 * @member getShape
 * @returns {Array}
 * @example
 *
 * const A = Matrix.of([[1, 1], [1, 1]])
 * A.getShape()  // [2, 2]
 */


Matrix.prototype.getShape = function () {
  return [this.getRows(), this.getCols()];
};
/**
 * @memberOf Matrix
 * @instance
 * @member map
 * @description Maps over the rows of the matrix using a map function
 * @param f {function} An iterator function
 * @returns {Matrix}
 * @example
 *
 * const m = Matrix.of([[1, 1], [1, 1]])
 * m.map(x => x.map(y => y+ 1))
 * // [[2, 2], [2, 2]]
 *
 */


Matrix.prototype.map = function (f) {
  return Matrix.of((0, _map.default)(f)(this.__value));
};
/**
 * @memberOf Matrix
 * @static
 * @function map
 * @description Static function that maps over the rows of the matrix using a map function
 * @param f {function} An iterator function
 * @param M {Matrix|array} Matrix or array to map
 * @returns {Matrix}
 * @example
 *
 * const m = Matrix.map(x= > x.map(y => y+ 1), [[1, 1], [1, 1]])
 * // [[2, 2], [2, 2]]
 *
 */


Matrix.map = (0, _curry.default)(function (f, M) {
  return Matrix.of(M).map(f);
});
/**
 * @memberOf Matrix
 * @instance
 * @member map
 * @description Maps over the rows of the matrix using a map function
 * @param f {function} An iterator function
 * @returns {Matrix}
 * @example
 *
 * const m = Matrix.of([[1, 1], [1, 1]])
 * m.map(x => x.map(y => y+ 1))
 * // [[2, 2], [2, 2]]
 *
 */

Matrix.prototype.gpumap = function (f) {
  var res = (0, _gpumap.default)(this.gpu, f, this.__value);
  return Matrix.of(res);
};
/**
 * @memberOf Matrix
 * @static
 * @function map
 * @description Static function that maps over the rows of the matrix using a map function
 * @param f {function} An iterator function
 * @param M {Matrix|array} Matrix or array to map
 * @returns {Matrix}
 * @example
 *
 * const m = Matrix.map(x= > x.map(y => y+ 1), [[1, 1], [1, 1]])
 * // [[2, 2], [2, 2]]
 *
 */


Matrix.gpumap = (0, _curry.default)(function (f, M) {
  return Matrix.of(M).gpumap(f);
});
/**
 * @memberOf Matrix
 * @instance
 * @member fold
 * @description Reduce the matrix rows using a reduce function
 * @param f {function} A reduce/fold function
 * @returns {Matrix}
 * @example
 *
 * // Flatten Matrix
 * Matrix.of([[1, 1], [1, 1]]).fold((prev, next) => prev.concat(next))
 * // [1, 1, 1, 1]
 */

Matrix.prototype.fold = function (f) {
  return Matrix.of((0, _fold.default)(f, [])(this.__value));
};
/**
 * @memberOf Matrix
 * @static
 * @function fold
 * @description Static function to reduce the matrix rows using a reduce function
 * @param f {function} A reduce/fold function
 * @param M {Matrix} The Matrix to reduce
 * @returns {Matrix}
 * @example

 * // Sum of all matrix values
 * const reducer = (prev, next) => Number(prev) + next.reduce((acc, x) => acc + x, 0)
 * const A = Matrix.of([[1, 1], [1, 1]]
 * Matrix.fold(reducer, A)
 * // 4
 */


Matrix.fold = (0, _curry.default)(function (f, M) {
  return Matrix.of(M).fold(f);
});
/**
 * @memberOf Matrix
 * @instance
 * @member ap
 * @description Applies a Matrix to a function
 * @param M {Matrix}
 * @returns {Matrix}
 * @example
 *
 * const f = x => x.reduce((prev, next) => prev + next)
 * const A = Matrix.of([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
 * Matrix.of(f).ap(M)
 * // [[6], [15], [24]
 */

Matrix.prototype.ap = function (M) {
  return Matrix.of(M).map(this.__value);
};
/**
 * @memberOf Matrix
 * @static
 * @function ap
 * @description Applies a Matrix to a function
 * @param f {function}
 * @param M {Matrix|array}
 * @returns {Matrix}
 * @example
 *
 * const f = x => x.reduce((prev, next) => prev + next)
 * Matrix.ap(f, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
 * // [[6], [15], [24]
 */


Matrix.ap = (0, _curry.default)(function (f, M) {
  return Matrix.of(f).ap(M);
});
/**
 * @memberOf Matrix
 * @instance
 * @member concat
 * @description Concatenates 2 Matrices using a function as operator
 * @param M {Matrix}
 * @returns {Matrix}
 * @example
 *
 * const a = [[0, 1, 1], [2, 3, 4]]
 * const b = [[2, 2, 2], [3, 3, 3]]
 * const A = Matrix.of(a)
 * const B = Matrix.of(b)
 * const M = A.concat(B)
 * // [[0, 1, 1, 2, 2, 2], [2, 3, 4, 3, 3, 3]]
 *
 */

Matrix.prototype.concat = function (M) {
  var f = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _concat.default;
  return Matrix.of(this).map(f(M));
};
/**
 * @memberOf Matrix
 * @static
 * @function concat
 * @description Concatenates 2 Matrices using a function as operator
 * @param A {Matrix}
 * @param B {Matrix}
 * @returns {Matrix}
 * @example
 *
 * const a = [[0, 1, 1], [2, 3, 4]]
 * const b = [[2, 2, 2], [3, 3, 3]]
 * const A = Matrix.of(a)
 * const B = Matrix.of(b)
 * const M = Matrix.concat(A, B)
 * // [[0, 1, 1, 2, 2, 2], [2, 3, 4, 3, 3, 3]]
 *
 */


Matrix.concat = (0, _curry.default)(function (A, B) {
  var f = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _concat.default;
  return Matrix.of(A).map(f(B));
});
/**
 * @memberOf Matrix
 * @instance
 * @member empty
 * @description Return an empty Matrix from an existing Matrix
 * @returns {Matrix}
 */

Matrix.prototype.empty = function () {
  return Matrix.of(this).map(_empty.default);
};
/**
 * @memberOf Matrix
 * @static
 * @function empty
 * @description Return an empty Matrix from an existing Matrix
 * @param rows {number}
 * @param cols {number}
 * @returns {Matrix}
 */


Matrix.empty = (0, _curry.default)(function () {
  var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var cols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var m = (0, _generate.default)(rows, cols); // Array.apply(null, Array(rows)).map(x => Array.apply(null, Array(cols)))

  return Matrix.of(m).map(_empty.default);
}); // #### #### #### //

/**
 * @memberOf Matrix
 * @instance
 * @member identity
 * @desc Returns an identity matrix
 * @returns {Matrix}
 * @example
 *
 * const a = [[1, 2, 3], [4, 5, 6]]
 * const A = Matrix.of(a)
 * const Aidentity = A.identity()
 * // [[1, 0, 0], [0, 1, 0]]
 *
*/

Matrix.prototype.identity = function () {
  return Matrix.of(_identity.default).ap(this);
};
/**
 * @memberOf Matrix
 * @static
 * @function identity
 * @desc Returns an identity matrix
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.identity(3, 2)
 * // [[1, 0, 0], [0, 1, 0]]
 *
 */


Matrix.identity = function (rows, cols) {
  var m = (0, _generate.default)(rows, cols); // Array.apply(null, Array(rows)).map(x => Array.apply(null, Array(cols)))

  return Matrix.of(_identity.default).ap(m);
};
/**
 * @memberOf Matrix
 * @instance
 * @member combine
 * @see Matrix.concat
 * @param M
 * @returns {Matrix}
 */


Matrix.prototype.combine = function (M) {
  return Matrix.of(this).concat(Matrix.of(M), _concat.default);
};
/**
 * @memberOf Matrix
 * @static
 * @function combine
 * @see Matrix.concat
 * @param M
 * @returns {Matrix}
 */


Matrix.combine = function (A, B) {
  return Matrix.of(A).concat(Matrix.of(B), _concat.default);
};
/**
 * @memberOf Matrix
 * @instance
 * @member dot
 * @description Returns the dot product between 2 matrices
 * @param M
 * @param f
 * @returns {Matrix}
 * @example
 *
 * // Create matrix
 * const m = Matrix.of([[1, 2], [3, 4]])
 *
 * // Generate identity matrix
 * const I  = m.identity() // [[1, 0], [0, 1]]
 *
 * if(m.dot(I).equals(m)) {
 *    console.log('Dot product with identity matrix returns the same matrix')
 * }
 *
 */


Matrix.prototype.dot = function (M) {
  return Matrix.of(this).concat(Matrix.of(M), (0, _dot.default)(this.precision));
};
/**
 * @memberOf Matrix
 * @static
 * @function dot
 * @description Returns the dot product between 2 matrices
 * @param M
 * @returns {Matrix}
 * @example
 * const a = [[1, 2, 3], [4, 5, 6]]
 * const b = [[7, 8], [9, 10], [11, 12]]
 *
 * const A = Matrix.of(a)
 * const B = Matrix.of(b)
 *
 * Matrix.dot(A, B) // [[58, 64], [139, 154]]
 *
 */


Matrix.dot = function (A, B) {
  return Matrix.of(A).dot(Matrix.of(B));
};
/**
 * @memberOf Matrix
 * @instance
 * @member fill
 * @desc Fill up an empty matrix with the provided map function
 * @param f
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[1,2,3], [3,2,1], [4,5,6]]).fill(x => 42)
 * // [[42,42,42], [42,42,42], [42,42,42]]
 *
 */


Matrix.prototype.fill = function (f) {
  return Matrix.of(this).map((0, _map.default)(function (x) {
    return f(x);
  }));
};
/**
 * @memberOf Matrix
 * @instance
 * @member zeros
 * @desc Fill up an empty matrix with zeros
 * @returns {Matrix}
 *
 * @example
 *
 * const A = Matrix.of([[1,2,3], [3,2,1], [4,5,6]]).zeros()
 * // [[0,0,0], [0,0,0], [0,0,0]]
 *
 */


Matrix.prototype.zeros = function () {
  return Matrix.of(this).fill(function (x) {
    return 0;
  });
};
/**
 * @memberOf Matrix
 * @function zeros
 * @desc Fill up an empty matrix with zeros
 * @param rows {number} Defines the rows of the matrix
 * @param cols {number} Defines the columns of the matrix
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.zeros(3, 3)
 * // [[0,0,0], [0,0,0], [0,0,0]]
 *
 */


Matrix.zeros = function (rows, cols) {
  var m = (0, _generate.default)(rows, cols);
  return Matrix.of(m).fill(function (x) {
    return 0;
  });
};
/**
 * @memberOf Matrix
 * @instance
 * @member ones
 * @desc Fill up an empty matrix with ones
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[1,2,3], [3,2,1], [4,5,6]]).ones()
 * // [[1,1,1], [1,1,1], [1,1,1]]
 *
 */


Matrix.prototype.ones = function () {
  return Matrix.of(this).fill(function (x) {
    return 1;
  });
};
/**
 * @memberOf Matrix
 * @function ones
 * @desc Fill up an empty matrix with ones
 * @param rows {number} Defines the rows of the matrix
 * @param cols {number} Defines the columns of the matrix
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.ones(1, 1)
 * // [[1,1,1], [1,1,1], [1,1,1]]
 *
 */


Matrix.ones = function (rows, cols) {
  var m = (0, _generate.default)(rows, cols);
  return Matrix.of(m).fill(function (x) {
    return 1;
  });
};
/**
 * @memberOf Matrix
 * @instance
 * @member random
 * @desc Fill up an empty matrix with random values
 * @param {function} [f = e => Math.random() * 2 - 1]
 * @returns {Matrix}
 */


Matrix.prototype.random = function () {
  var f = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (e) {
    return Math.random() * 2 - 1;
  };
  return Matrix.of(this).fill(f);
};
/**
 * @memberOf Matrix
 * @function random
 * @desc Fill up an empty matrix with random numbers
 * @param f {function} Function which returns random values. Default random values are between -1 and 1
 * @param rows {number} Defines the rows of the matrix
 * @param cols {number} Defines the columns of the matrix
 * @returns {Matrix}
 */


Matrix.random = function () {
  var f = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (e) {
    return Math.random() * 2 - 1;
  };
  var rows = arguments[1];
  var cols = arguments[2];
  var m = (0, _generate.default)(rows, cols);
  return Matrix.of(m).fill(f);
};
/**
 * @memberOf Matrix
 * @instance
 * @member toArray
 * @desc Returns the array from the matrix
 * @returns {Array}
 */


Matrix.prototype.toArray = function () {
  return this.__value.map(function (row) {
    return row.map(function (col) {
      return col;
    });
  });
};
/**
 * @memberOf Matrix
 * @instance
 * @member clone
 * @desc Returns a clone of the matrix
 * @returns {Matrix}
 */


Matrix.prototype.clone = function () {
  return Matrix.fromArray(this.__value);
};
/**
 * @memberOf Matrix
 * @instance
 * @member fromArray
 * @desc Returns a Matrix from an array
 * @returns {Array}
 */


Matrix.fromArray = function (arr) {
  return Matrix.of((0, _map.default)(function (row) {
    return (0, _map.default)(function (col) {
      return col;
    })(row);
  })(arr));
};
/**
 * @memberOf Matrix
 * @instance
 * @member transpose
 * @desc Returns a transposed Matrix
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([-1, 2], [3, 4], [-8, 2])
 * const b = A.transpose().toArray()
 * // returns [[-1, 3,-8], [2, 4, 2]]
 */


Matrix.prototype.transpose = function () {
  return Matrix.of((0, _fold.default)(_transpose.default, [], this.__value));
};
/**
 * @memberOf Matrix
 * @function transpose
 * @desc Returns a transposed Matrix
 * @param M {Matrix|array} A Matrix or a matrix array
 * @returns {Matrix}
 * @example
 *
 * const a = [-1, 2], [3, 4], [-8, 2]
 * const b = Matrix.transpose(a).toArray()
 * // returns [[-1, 3,-8], [2, 4, 2]]
 */


Matrix.transpose = function (M) {
  return Matrix.of(M).transpose();
};
/**
 * @memberOf Matrix
 * @member add
 * @instance
 * @param M {Matrix|number} Add a Matrix or a number
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[5, 4]])
 * A.add(1) // [[6, 5]]
 * const B = Matrix.of([[5, 5]])
 * B.add(B) // [[10, 10]]
 *
 */


Matrix.prototype.add = function (M) {
  if (M instanceof Matrix) {
    if (this.getCols() !== M.getCols() || this.getRows() !== M.getRows()) {
      throw new Error('Matrices do not match, cannot add');
    }

    return this.map(function (row, idx) {
      return (0, _map.default)(function (val, jdx) {
        return val + M.__value[idx][jdx];
      })(row);
    });
  } else {
    return this.map((0, _map.default)(function (x) {
      return x + M;
    }));
  }
};
/**
 * @memberOf Matrix
 * @member subtract
 * @instance
 * @param M {Matrix|number} Subtract a Matrix or a number
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[5, 4]])
 * A.subtract(1) // [[4, 2]]
 * const B = Matrix.of([[5, 5]])
 * B.subtract(B) // [[0, 0]]
 *
 */


Matrix.prototype.subtract = function (M) {
  if (M instanceof Matrix) {
    if (this.getCols() !== M.getCols() || this.getRows() !== M.getRows()) {
      throw new Error('Matrices do not match, cannot subtract');
    }

    return this.map(function (row, idx) {
      return (0, _map.default)(function (val, jdx) {
        return val - M.__value[idx][jdx];
      })(row);
    });
  } else {
    return this.map((0, _map.default)(function (x) {
      return x - M;
    }));
  }
};
/**
 * @memberOf Matrix
 * @member multiply
 * @instance
 * @desc Mutliply a scalar or a mtraix with a matrix. Throws an error if the multiplication is not possible.
 * @param M {Matrix|number}
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[5, 4]])
 * A.multiply(2) // [[10, 8]]
 * const B = Matrix.of([[5, 5]])
 * B.multiply(B) // [[25, 25]]
 *
 */


Matrix.prototype.multiply = function (M) {
  if (M instanceof Matrix) {
    if (this.getCols() !== M.getCols() || this.getRows() !== M.getRows()) {
      console.log('Use static method \'dot\' to do matrix multiplication');
      throw new Error('Matrices do not match, cannot create hadamard product');
    }

    return this.map(function (row, idx) {
      return (0, _map.default)(function (col, jdx) {
        return col * M.__value[idx][jdx];
      })(row);
    });
  } else {
    return this.map((0, _map.default)(function (x) {
      return x * M;
    }));
  }
};
/**
 * @memberOf Matrix
 * @member additiveinverse
 * @instance
 * @desc Function that returns the matrix obtained by changing the sign of every matrix element. The additive inverse of matrix A is written –A.
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[5,-5], [-4, 4]])
 * const minusA = A.additiveinverse()
 * // [[-5, 5], [4, -4]]
 */


Matrix.prototype.additiveinverse = function () {
  return Matrix.of(this).multiply(-1);
};
/**
 * @memberOf Matrix
 * @member hadamard
 * @instance
 * @see multiply
 * @param M
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[5, 4]])
 * A.hadamard(2) // [[10, 8]]
 * const B = Matrix.of([[5, 5]])
 * B.hadamard(B) // [[25, 25]]

 */


Matrix.prototype.hadamard = function (M) {
  return Matrix.of(this).multiply(M);
};
/**
 * @memberOf Matrix
 * @instance
 * @member lu
 * @desc Calculates LU decomposition of the current Matrix
 * @returns {Matrix[]}
 * @example
 *
 * const result = [[3, -7, -2, 2], [-3, 5, 1, 0], [6, -4, 0, -5], [-9, 5, -5, 12]]
 * const A = Matrix.fromArray(result)
 * const lu = A.lu()
 * // L.__value = [ [ 1, 0, 0, 0 ], [ -1, 1, 0, 0 ], [ 2, -5, 1, 0 ], [ -3, 8, 3, 1 ] ]
 * // U.__value =  [ [ 3, -7, -2, 2 ], [ 0, -2, -1, 2 ], [ 0, 0, -1, 1 ], [ 0, 0, 0, -1 ] ]
 * Matrix.dot(lu[0], lu[1]) // returns clone of A
 *
 */


Matrix.prototype.lu = function () {
  var n = this.getRows();
  var tol = 1e-6;
  var A = this.clone();
  var L = this.zeros();
  var U = this.zeros();

  for (var k = 0; k < n; ++k) {
    if (Math.abs(A.__value[k][k]) < tol) throw Error('Cannot proceed without a row exchange');
    L.__value[k][k] = 1;

    for (var i = k + 1; i < n; ++i) {
      L.__value[i][k] = A.__value[i][k] / A.__value[k][k];

      for (var j = k + 1; j < n; ++j) {
        A.__value[i][j] = A.__value[i][j] - L.__value[i][k] * A.__value[k][j];
      }
    }

    for (var l = k; l < n; ++l) {
      U.__value[k][l] = A.__value[k][l];
    }
  }

  return [L, U];
};
/**
 * @memberOf Matrix
 * @instance
 * @member rref
 * @returns {Matrix|array}
 * @example
 *
 * var A = Matrix.of([[-1, 1], [-1, 0], [0, -1], [-1, -2]])
 * A.rref() //  [ [ 1, 0 ], [ -0, 1 ], [ 0, 0 ], [ 0, 0 ] ]
 */


Matrix.prototype.rref = function () {
  var lead = 0;
  var resultMatrix = this.clone();

  for (var r = 0; r < this.getRows(); ++r) {
    if (this.getCols() <= lead) {
      return resultMatrix;
    }

    var i = r;

    while (resultMatrix.__value[i][lead] === 0) {
      ++i;

      if (this.getRows() === i) {
        i = r;
        ++lead;

        if (this.getCols() === lead) {
          return resultMatrix;
        }
      }
    }

    var tmp = resultMatrix.__value[i];
    resultMatrix.__value[i] = resultMatrix.__value[r];
    resultMatrix.__value[r] = tmp;
    var val = resultMatrix.__value[r][lead];

    for (var j = 0; j < this.getCols(); ++j) {
      resultMatrix.__value[r][j] /= val;
    }

    for (var _i = 0; _i < this.getRows(); ++_i) {
      if (_i === r) continue;
      val = resultMatrix.__value[_i][lead];

      for (var _j = 0; _j < this.getCols(); ++_j) {
        resultMatrix.__value[_i][_j] -= val * resultMatrix.__value[r][_j];
      }
    }

    lead++;
  }

  return resultMatrix;
};
/**
 * @memberOf Matrix
 * @instance
 * @member solve
 * @param b
 * @returns {Array}
 * @example
 *
 * // Solve xA = b
 * // 5x + y  = 7
 * // 3x - 4y = 18
 * // Solution for x and y:
 * // x = 2
 * // y = -3
 *
 * const A = Matrix.of([[5, 1], [3, -4]])
 * const solveA = A.solve([7, 18]) // [2, -3]
 *
 */


Matrix.prototype.solve = function (b) {
  var A = this.clone();
  var LU = A.lu();
  var L = LU[0];
  var U = LU[1];
  var n = this.getRows();
  var s = 0;
  var c = [];
  var x = [];

  for (var k = 0; k < n; ++k) {
    for (var j = 0; j < k; ++j) {
      s = s + L.__value[k][j] * c[j];
    }

    c[k] = b[k] - s;
    s = 0;
  }

  for (var a = n - 1; a > -1; --a) {
    var t = 0;

    for (var _b = a + 1; _b < n; ++_b) {
      t = t + U.__value[a][_b] * x[_b];
    }

    x[a] = (c[a] - t) / U.__value[a][a];
  }

  return x;
};
/**
 * @memberOf Matrix
 * @member inverse
 * @instance
 * @returns {Matrix}
 * @example
 *
 * const A = Matrix.of([[1, 1], [2, 4]]).inverse()
 * // [ [ 2, -0.5 ], [ -1, 0.5 ] ]
 *
 */


Matrix.prototype.inverse = function () {
  var A = this.clone();
  var I = A.identity();
  var Inv = A.concat(I).rref();

  var result = Inv.__value.reduce(function (result, x, idx) {
    var half = x.length / 2;
    result.push(x.slice(half, x.length));
    return result;
  }, []);

  return Matrix.of(result);
};
/**
 * @memberOf Matrix
 * @member rank
 * @instance
 * @returns {Number}
 */


Matrix.prototype.rank = function () {
  var rref = this.rref();
  var result = 0;

  for (var i = 0; i < rref.getCols(); ++i) {
    result += rref.__value[i][i];
  }

  return result;
};
/**
 * @memberOf Matrix
 * @member dimension
 * @instance
 * @see rank
 * @returns {Number}
 */


Matrix.prototype.dimension = function () {
  return this.rank();
};
/**
 * @memberOf Matrix
 * @member diag
 * @instance
 * @desc Returns an array containing the values on the diagonal
 * @returns {Array}
 * @example
 *
 * const diag1 = Matrix.ones(3, 3).diag()
 * // [1, 1, 1]
 *
 * const diag0 = Matrix.zeros(5, 5).diag()
 * // [0, 0, 0, 0, 0]
 *
 */


Matrix.prototype.diag = function () {
  return (0, _fold.default)(function (acc, x, idx) {
    return acc.concat(x[idx]);
  })([])(this.__value);
};
/**
 * @memberOf Matrix
 * @function diag
 * @desc Returns an array containing the values on the diagonal
 * @param M {Matrix|Array} Matrix from which to return the diagonal
 * @returns {Array}
 * @example
 *
 * const diag1 = Matrix.diag([[2, 1], [1, 5]])
 * // [2, 5]
 *
 */


Matrix.diag = function (M) {
  return Matrix.of(M).diag();
};
/**
 * @memberOf Matrix
 * @member diagproduct
 * @instance
 * @desc Returns the product of the values on the diagonal
 * @returns {Number}
 * @example
 *
 * const diag1 = Matrix.ones(3, 3).diagproduct()
 * // 1
 *
 * const diag0 = Matrix.zeros(5, 5).diagproduct()
 * // 0
 *
 */


Matrix.prototype.diagproduct = function () {
  return (0, _fold.default)(function (acc, x, idx) {
    acc *= x[idx];
    return acc;
  })(1)(this.__value);
};
/**
 * @memberOf Matrix
 * @function diagproduct
 * @desc Returns the product of the values on the diagonal
 * @param M {Matrix|Array} Matrix from which to return the diagonal
 * @returns {Number}
 * @example
 *
 * const diag1 = Matrix.diagproduct([[2, 1], [1, 5]])
 * // 10
 *
 */


Matrix.diagproduct = function (M) {
  return Matrix.of(M).diagproduct();
};
/**
 * @memberOf Matrix
 * @member sum
 * @instance
 * @desc Returns the sum of the values in the Matrix
 * @returns {Number}
 * @example
 *
 * const diag1 = Matrix.ones(3, 3).sum()
 * // 9
 *
 * const diag0 = Matrix.zeros(5, 5).sum()
 * // 0
 *
 */


Matrix.prototype.sum = function () {
  return (0, _fold.default)(function (acc, x) {
    acc += (0, _fold.default)(function (prev, next) {
      return prev + next;
    })(0)(x);
    return acc;
  })(0)(this.__value);
};
/**
 * @memberOf Matrix
 * @function sum
 * @desc Returns the sum of the values in the Matrix
 * @param M {Matrix|Array} Matrix from which to return the diagonal
 * @returns {Number}
 * @example
 *
 * const diag1 = Matrix.sum([[2, 1], [1, 5]])
 * // 9
 *
 */


Matrix.sum = function (M) {
  return Matrix.of(M).sum();
};
/**
 * @memberOf Matrix
 * @member kronecker
 * @instance
 * @desc The Kronecker product is an operation on two matrices of arbitrary size resulting in a block matrix.
 * @param M {Matrix} The right side Matrix of the product (this ⊗ M)
 * @returns {Matrix}
 */


Matrix.prototype.kronecker = function (M) {
  var m = this.getRows();
  var n = this.getCols();
  var p = M.getRows();
  var q = M.getCols();
  var left = this.__value;
  var right = M.__value;
  var frame = (0, _generate.default)(m * p, n * q);

  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      for (var k = 0; k < p; k++) {
        for (var l = 0; l < q; l++) {
          frame[p * i + k][q * j + l] = left[i][j] * right[k][l];
        }
      }
    }
  }

  return Matrix.of(frame);
};
/**
 * @memberOf Matrix
 * @function kronecker
 * @desc The Kronecker product is an operation on two matrices of arbitrary size resulting in a block matrix.
 * @param A {Matrix} The left side Matrix of the product (A ⊗ B)
 * @param B {Matrix} The right side Matrix of the product (A ⊗ B)
 * @returns {Matrix}
 */


Matrix.kronecker = function (A, B) {
  return Matrix.of(A).kronecker(B);
};

var _default = Matrix;
exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "./src/util/concat.js":
/*!****************************!*\
  !*** ./src/util/concat.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _curry = _interopRequireDefault(__webpack_require__(/*! fun.js/src/curry */ "./node_modules/fun.js/src/curry.js"));

var _concat = _interopRequireDefault(__webpack_require__(/*! fun.js/src/concat */ "./node_modules/fun.js/src/concat.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @function concat
 * @param M {Matrix}
 * @param m {Array}
 * @param idx {number}
 * @returns {Array}
 */
var _default = (0, _curry.default)(function (M, m, idx) {
  return (0, _concat.default)(m, M.__value[idx]);
});

exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "./src/util/dot.js":
/*!*************************!*\
  !*** ./src/util/dot.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _curry = _interopRequireDefault(__webpack_require__(/*! fun.js/src/curry */ "./node_modules/fun.js/src/curry.js"));

var _fold = _interopRequireDefault(__webpack_require__(/*! fun.js/src/fold */ "./node_modules/fun.js/src/fold.js"));

var _map = _interopRequireDefault(__webpack_require__(/*! fun.js/src/map */ "./node_modules/fun.js/src/map.js"));

var _round = _interopRequireDefault(__webpack_require__(/*! ./round */ "./src/util/round.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @function dot
 * @param B {Matrix}
 * @param a {Array}
 * @returns {Array}
 */
var _default = (0, _curry.default)(function (decimals, B, a) {
  return (0, _map.default)(function (item, i) {
    return (0, _fold.default)(function (acc, x, j) {
      acc += (0, _round.default)(x * B.__value[j][i], decimals);
      return acc;
    }, 0)(a);
  })(B.__value[0]);
});

exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "./src/util/empty.js":
/*!***************************!*\
  !*** ./src/util/empty.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _curry = _interopRequireDefault(__webpack_require__(/*! fun.js/src/curry */ "./node_modules/fun.js/src/curry.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _curry.default)(function (m) {
  return [];
});

exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "./src/util/generate.js":
/*!******************************!*\
  !*** ./src/util/generate.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @function generate
 * @desc Generator function for a matrix array, values are set to undefined
 * @param rows {number}
 * @param cols {number}
 * @returns {any[][]}
 */
var _default = function _default(rows, cols) {
  return Array.apply(null, Array(rows)).map(function (x) {
    return Array.apply(null, Array(cols));
  });
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "./src/util/gpumap.js":
/*!****************************!*\
  !*** ./src/util/gpumap.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gpumap;

// import curry from 'fun.js/src/curry'
function gpumap(gpu, f, matrix) {
  return gpu.createKernel(f).setOutput([matrix.length, matrix[0].length])(matrix);
}

module.exports = exports["default"];

/***/ }),

/***/ "./src/util/identity.js":
/*!******************************!*\
  !*** ./src/util/identity.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _map = _interopRequireDefault(__webpack_require__(/*! fun.js/src/map */ "./node_modules/fun.js/src/map.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @function identity
 * @desc Creates an identiy matrix from an empty array
 * @param m {Array}
 * @param idx {number}
 * @return {Matrix}
 */
var _default = function _default(m, idx) {
  return (0, _map.default)(function (rows, jdx) {
    return (idx === jdx) * 1;
  })(m);
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "./src/util/round.js":
/*!***************************!*\
  !*** ./src/util/round.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = round;

/**
 * @function round
 * @param value {number}
 * @param decimals {number}
 * @returns {Number}
 */
function round(value, decimals) {
  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
}

module.exports = exports["default"];

/***/ }),

/***/ "./src/util/transpose.js":
/*!*******************************!*\
  !*** ./src/util/transpose.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _map = _interopRequireDefault(__webpack_require__(/*! fun.js/src/map */ "./node_modules/fun.js/src/map.js"));

var _curry = _interopRequireDefault(__webpack_require__(/*! fun.js/src/curry */ "./node_modules/fun.js/src/curry.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @function transpose
 * @desc Transposes a array of arrays using the Matrix.map function
 * @param m {Array}
 * @param idx {number}
 * @return {Matrix}
 */
var _default = (0, _curry.default)(function (prev, next) {
  return (0, _map.default)(function (item, i) {
    return (prev[i] || []).concat(next[i]);
  })(next);
});

exports.default = _default;
module.exports = exports["default"];

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5tanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL19wcml2YXRlL2N1cnJ5MS5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvYW5kLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9hcnJheS9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL2FycmF5L2VxdWFscy5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvYXJyYXkvZm9sZC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvYXJyYXkvaXMuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL2FycmF5L21hcC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvYm9vbGVhbi9pcy5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvY29uY2F0LmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9jdXJyeS5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvZGF0ZS9pcy5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvZW1wdHkuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvZXhpc3RzLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9mb2xkLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9pZGVudGljYWwuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL2lzLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9pdGVyYXRvci9pcy5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvaXRlcmF0b3IvbWFwLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9tYXAuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL21hcC9tYXAuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL25vdC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvbnVtYmVyL2lzLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9udW1iZXIvaXNOYW4uanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL29iamVjdC9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL29iamVjdC9mb2xkLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9vYmplY3QvaXMuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9mdW4uanMvc3JjL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9vYmplY3QvbWFwLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9vci5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvc3RyaW5nL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2Z1bi5qcy9zcmMvc3RyaW5nL2lzLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy9zdHJpbmcvbWFwLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZnVuLmpzL3NyYy90eXBlLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ2wvYnJvd3Nlcl9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS1tb2NrLmpzL2luZGV4LmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9hbGlhcy5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS5qcy9zcmMvYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZS5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS5qcy9zcmMvYmFja2VuZC9jcHUva2VybmVsLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS5qcy9zcmMvYmFja2VuZC9jcHUva2VybmVsLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9iYWNrZW5kL2Z1bmN0aW9uLWJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL2JhY2tlbmQvZnVuY3Rpb24tbm9kZS5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS5qcy9zcmMvYmFja2VuZC9nbC1rZXJuZWwuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL2JhY2tlbmQvaGVhZGxlc3MtZ2wva2VybmVsLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9iYWNrZW5kL2tlcm5lbC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS5qcy9zcmMvYmFja2VuZC93ZWItZ2wvZnJhZ21lbnQtc2hhZGVyLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9iYWNrZW5kL3dlYi1nbC9mdW5jdGlvbi1ub2RlLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9iYWNrZW5kL3dlYi1nbC9rZXJuZWwtc3RyaW5nLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9iYWNrZW5kL3dlYi1nbC9rZXJuZWwuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL2JhY2tlbmQvd2ViLWdsL3ZlcnRleC1zaGFkZXIuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL2JhY2tlbmQvd2ViLWdsMi9mcmFnbWVudC1zaGFkZXIuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL2JhY2tlbmQvd2ViLWdsMi9mdW5jdGlvbi1ub2RlLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9iYWNrZW5kL3dlYi1nbDIva2VybmVsLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9iYWNrZW5kL3dlYi1nbDIvdmVydGV4LXNoYWRlci5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS5qcy9zcmMvZ3B1LmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vbm9kZV9tb2R1bGVzL2dwdS5qcy9zcmMvaW5wdXQuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL2tlcm5lbC1ydW4tc2hvcnRjdXQuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL3BsdWdpbnMvdHJpYW5nbGUtbm9pc2UuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL3RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL25vZGVfbW9kdWxlcy9ncHUuanMvc3JjL3V0aWxzLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9zcmMvbWF0cml4LmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9zcmMvdXRpbC9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL3NyYy91dGlsL2RvdC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vc3JjL3V0aWwvZW1wdHkuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL3NyYy91dGlsL2dlbmVyYXRlLmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9zcmMvdXRpbC9ncHVtYXAuanMiLCJ3ZWJwYWNrOi8vQGFzdHVhbmF4L2Z1bm1hdHJpeC8uL3NyYy91dGlsL2lkZW50aXR5LmpzIiwid2VicGFjazovL0Bhc3R1YW5heC9mdW5tYXRyaXgvLi9zcmMvdXRpbC9yb3VuZC5qcyIsIndlYnBhY2s6Ly9AYXN0dWFuYXgvZnVubWF0cml4Ly4vc3JjL3V0aWwvdHJhbnNwb3NlLmpzIl0sIm5hbWVzIjpbIk1hdHJpeCIsInZhbCIsIl9fdmFsdWUiLCJncHUiLCJvZiIsInByb3RvdHlwZSIsInR5cGUiLCJwcmVjaXNpb24iLCJzZXRQcmVjaXNpb24iLCJpc1N5bW1ldHJpYyIsImEiLCJiIiwidHJhbnNwb3NlIiwiaXNTcXVhcmUiLCJnZXRDb2xzIiwiZ2V0Um93cyIsImlzT3J0aG9nb25hbCIsIkF4QXQiLCJkb3QiLCJJIiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJlcXVhbHMiLCJNIiwiZ2V0U2hhcGUiLCJtYXAiLCJmIiwiZ3B1bWFwIiwicmVzIiwiZm9sZCIsImFwIiwiY29uY2F0IiwiQSIsIkIiLCJlbXB0eSIsInJvd3MiLCJjb2xzIiwibSIsImNvbWJpbmUiLCJmaWxsIiwieCIsInplcm9zIiwib25lcyIsInJhbmRvbSIsImUiLCJNYXRoIiwidG9BcnJheSIsInJvdyIsImNvbCIsImNsb25lIiwiZnJvbUFycmF5IiwiYXJyIiwiYWRkIiwiRXJyb3IiLCJpZHgiLCJqZHgiLCJzdWJ0cmFjdCIsIm11bHRpcGx5IiwiY29uc29sZSIsImxvZyIsImFkZGl0aXZlaW52ZXJzZSIsImhhZGFtYXJkIiwibHUiLCJuIiwidG9sIiwiTCIsIlUiLCJrIiwiYWJzIiwiaSIsImoiLCJsIiwicnJlZiIsImxlYWQiLCJyZXN1bHRNYXRyaXgiLCJyIiwidG1wIiwic29sdmUiLCJMVSIsInMiLCJjIiwidCIsImludmVyc2UiLCJJbnYiLCJyZXN1bHQiLCJyZWR1Y2UiLCJoYWxmIiwicHVzaCIsInNsaWNlIiwicmFuayIsImRpbWVuc2lvbiIsImRpYWciLCJhY2MiLCJkaWFncHJvZHVjdCIsInN1bSIsInByZXYiLCJuZXh0Iiwia3JvbmVja2VyIiwicCIsInEiLCJsZWZ0IiwicmlnaHQiLCJmcmFtZSIsImRlY2ltYWxzIiwiaXRlbSIsIkFycmF5IiwiYXBwbHkiLCJtYXRyaXgiLCJjcmVhdGVLZXJuZWwiLCJzZXRPdXRwdXQiLCJyb3VuZCIsInZhbHVlIiwiTnVtYmVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLFdBQVcsb0JBQW9CLGFBQWEsb0JBQW9CLE1BQU0sY0FBYztBQUNoSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVUsR0FBRyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsS0FBSyxRQUFRLHlCQUF5QjtBQUMvRDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Qsc0JBQXNCO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhDQUE4QyxlQUFlO0FBQzdEOztBQUVBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFD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Q0E7QUFDQSxFOzs7Ozs7Ozs7OztBQzdpQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFz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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUN0NURBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsMEZBQXlCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUMsSUFBSTtBQUNKLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLElBQUk7QUFDSix3QkFBd0IsYUFBYTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBTyxDQUFDLDRFQUFrQjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsbUZBQWlCO0FBQzdCO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDakM7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBTyxDQUFDLHVEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQywyREFBZTtBQUMzQjtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsdUZBQW1CO0FBQy9CO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQyxtRkFBaUI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQUEsU0FBZ0Isa0JBQUksVUFBQ1EsSUFBRCxFQUFPbkMsQ0FBUDtBQUFBLFdBQWEsQ0FBQzBCLElBQUksQ0FBQzFCLENBQUQsQ0FBSixJQUFXLEVBQVosRUFBZ0J0QyxNQUFoQixDQUF1QmlFLElBQUksQ0FBQzNCLENBQUQsQ0FBM0IsQ0FBYjtBQUFBLEdBQUosRUFBa0QyQixJQUFsRCxDQUFoQjtBQUFBLENBQU4sQyIsImZpbGUiOiJAYXN0dWFuYXgvZnVubWF0cml4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJAYXN0dWFuYXgvZnVubWF0cml4XCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkBhc3R1YW5heC9mdW5tYXRyaXhcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQGFzdHVhbmF4L2Z1bm1hdHJpeFwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9tYXRyaXguanNcIik7XG4iLCIvLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgNjogXCJlbnVtXCIsXG4gIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxufTtcblxuLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG52YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG52YXIga2V5d29yZHMgPSB7XG4gIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG59O1xuXG52YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cbi8vIEdlbmVyYXRlZCBieSBgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxuXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YmRcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmZWZcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdiOVxcdWE3ZjctXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjVcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2YyLVxcdTFjZjRcXHUxY2Y3LVxcdTFjZjlcXHUxZGMwLVxcdTFkZjlcXHUxZGZiLVxcdTFkZmZcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG5ub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG4vLyBUaGVzZSBhcmUgYSBydW4tbGVuZ3RoIGFuZCBvZmZzZXQgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbi8vID4weGZmZmYgY29kZSBwb2ludHMgdGhhdCBhcmUgYSB2YWxpZCBwYXJ0IG9mIGlkZW50aWZpZXJzLiBUaGVcbi8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbi8vIG9mZnNldCB0byB0aGUgbmV4dCByYW5nZSwgYW5kIHRoZW4gYSBzaXplIG9mIHRoZSByYW5nZS4gVGhleSB3ZXJlXG4vLyBnZW5lcmF0ZWQgYnkgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbW1hLXNwYWNpbmdcbnZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLDExLDIsMjUsMiwxOCwyLDEsMiwxNCwzLDEzLDM1LDEyMiw3MCw1MiwyNjgsMjgsNCw0OCw0OCwzMSwxNCwyOSw2LDM3LDExLDI5LDMsMzUsNSw3LDIsNCw0MywxNTcsMTksMzUsNSwzNSw1LDM5LDksNTEsMTU3LDMxMCwxMCwyMSwxMSw3LDE1Myw1LDMsMCwyLDQzLDIsMSw0LDAsMywyMiwxMSwyMiwxMCwzMCw2NiwxOCwyLDEsMTEsMjEsMTEsMjUsNzEsNTUsNywxLDY1LDAsMTYsMywyLDIsMiwyOCw0MywyOCw0LDI4LDM2LDcsMiwyNywyOCw1MywxMSwyMSwxMSwxOCwxNCwxNywxMTEsNzIsNTYsNTAsMTQsNTAsMTQsMzUsNDc3LDI4LDExLDAsOSwyMSwxOTAsNTIsNzYsNDQsMzMsMjQsMjcsMzUsMzAsMCwxMiwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDg1LDYsMiwwLDIsMywyLDE0LDIsOSw4LDQ2LDM5LDcsMywxLDMsMjEsMiw2LDIsMSwyLDQsNCwwLDE5LDAsMTMsNCwxNTksNTIsMTksMyw1NCw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDg2LDI2LDIzMCw0MywxMTcsNjMsMzIsMCwyNTcsMCwxMSwzOSw4LDAsMjIsMCwxMiwzOSwzLDMsMjAsMCwzNSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDI3MCw5MjEsMTAzLDExMCwxOCwxOTUsMjc0OSwxMDcwLDQwNTAsNTgyLDg2MzQsNTY4LDgsMzAsMTE0LDI5LDE5LDQ3LDE3LDMsMzIsMjAsNiwxOCw2ODksNjMsMTI5LDY4LDEyLDAsNjcsMTIsNjUsMSwzMSw2MTI5LDE1LDc1NCw5NDg2LDI4Niw4MiwzOTUsMjMwOSwxMDYsNiwxMiw0LDgsOCw5LDU5OTEsODQsMiw3MCwyLDEsMywwLDMsMSwzLDMsMiwxMSwyLDAsMiw2LDIsNjQsMiwzLDMsNywyLDYsMiwyNywyLDMsMiw0LDIsMCw0LDYsMiwzMzksMywyNCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDcsNDE0OSwxOTYsNjAsNjcsMTIxMywzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxMCw0Miw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MV07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDU3NCwzLDksOSw1MjUsMTAsMTc2LDIsNTQsMTQsMzIsOSwxNiwzLDQ2LDEwLDU0LDksNywyLDM3LDEzLDIsOSw2LDEsNDUsMCwxMywyLDQ5LDEzLDksMyw0LDksODMsMTEsNywwLDE2MSwxMSw2LDksNywzLDU2LDEsMiw2LDMsMSwzLDIsMTAsMCwxMSwxLDMsNiw0LDQsMTkzLDE3LDEwLDksNSwwLDgyLDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDI0MywxNCwxNjYsOSwyODAsOSw0MSw2LDIsMyw5LDAsMTAsMTAsNDcsMTUsNDA2LDcsMiw3LDE3LDksNTcsMjEsMiwxMywxMjMsNSw0LDAsMiwxLDIsNiwyLDAsOSw5LDQ5LDQsMiwxLDIsNCw5LDksMzMwLDMsMTkzMDYsOSwxMzUsNCw2MCw2LDI2LDksMTAxNiw0NSwxNywzLDE5NzIzLDEsNTMxOSw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMjIxNCw2LDExMCw2LDYsOSw3OTI0ODcsMjM5XTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcylcbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgaWYgKGNvZGUgPCA0OCkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKVxufVxuXG4vLyAjIyBUb2tlbiB0eXBlc1xuXG4vLyBUaGUgYXNzaWdubWVudCBvZiBmaW5lLWdyYWluZWQsIGluZm9ybWF0aW9uLWNhcnJ5aW5nIHR5cGUgb2JqZWN0c1xuLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4vLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuLy8gQWxsIHRva2VuIHR5cGUgdmFyaWFibGVzIHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSwgdG8gbWFrZSB0aGVtXG4vLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb25zIGFuZCBkaXZpc2lvbnMuIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBjYW5cbi8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuLy9cbi8vIFRoZSBgc3RhcnRzRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgdG9rZW4gZW5kcyBhXG4vLyBgeWllbGRgIGV4cHJlc3Npb24uIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBlaXRoZXIgY2FuXG4vLyBkaXJlY3RseSBzdGFydCBhbiBleHByZXNzaW9uIChsaWtlIGEgcXVvdGF0aW9uIG1hcmspIG9yIGNhblxuLy8gY29udGludWUgYW4gZXhwcmVzc2lvbiAobGlrZSB0aGUgYm9keSBvZiBhIHN0cmluZykuXG4vL1xuLy8gYGlzTG9vcGAgbWFya3MgYSBrZXl3b3JkIGFzIHN0YXJ0aW5nIGEgbG9vcCwgd2hpY2ggaXMgaW1wb3J0YW50XG4vLyB0byBrbm93IHdoZW4gcGFyc2luZyBhIGxhYmVsLCBpbiBvcmRlciB0byBhbGxvdyBvciBkaXNhbGxvd1xuLy8gY29udGludWUganVtcHMgdG8gdGhhdCBsYWJlbC5cblxudmFyIFRva2VuVHlwZSA9IGZ1bmN0aW9uIFRva2VuVHlwZShsYWJlbCwgY29uZikge1xuICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wIHx8IG51bGw7XG4gIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG59O1xuXG5mdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG59XG52YXIgYmVmb3JlRXhwciA9IHtiZWZvcmVFeHByOiB0cnVlfTtcbnZhciBzdGFydHNFeHByID0ge3N0YXJ0c0V4cHI6IHRydWV9O1xuXG4vLyBNYXAga2V5d29yZCBuYW1lcyB0byB0b2tlbiB0eXBlcy5cblxudmFyIGtleXdvcmRzJDEgPSB7fTtcblxuLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICByZXR1cm4ga2V5d29yZHMkMVtuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbn1cblxudmFyIHR5cGVzID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2VuIHR5cGVzLlxuICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICBicmFjZUw6IG5ldyBUb2tlblR5cGUoXCJ7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcGFyZW5SOiBuZXcgVG9rZW5UeXBlKFwiKVwiKSxcbiAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgY29sb246IG5ldyBUb2tlblR5cGUoXCI6XCIsIGJlZm9yZUV4cHIpLFxuICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gIGludmFsaWRUZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcImludmFsaWRUZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gIGRvbGxhckJyYWNlTDogbmV3IFRva2VuVHlwZShcIiR7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG5cbiAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgLy9cbiAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAvL1xuICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCIhL35cIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBsb2dpY2FsT1I6IGJpbm9wKFwifHxcIiwgMSksXG4gIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gIGJpdHdpc2VPUjogYmlub3AoXCJ8XCIsIDMpLFxuICBiaXR3aXNlWE9SOiBiaW5vcChcIl5cIiwgNCksXG4gIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgZXF1YWxpdHk6IGJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgcmVsYXRpb25hbDogYmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBtb2R1bG86IGJpbm9wKFwiJVwiLCAxMCksXG4gIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICBzdGFyc3RhcjogbmV3IFRva2VuVHlwZShcIioqXCIsIHtiZWZvcmVFeHByOiB0cnVlfSksXG5cbiAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgX2lmOiBrdyhcImlmXCIpLFxuICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgX3RyeToga3coXCJ0cnlcIiksXG4gIF92YXI6IGt3KFwidmFyXCIpLFxuICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF93aXRoOiBrdyhcIndpdGhcIiksXG4gIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiksXG4gIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbn07XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG52YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSwgZWNtYTIwMTlTdHJpbmcpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8ICghZWNtYTIwMTlTdHJpbmcgJiYgKGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjkpKVxufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxudmFyIHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5cbnZhciByZWYgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGhhc093blByb3BlcnR5ID0gcmVmLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gcmVmLnRvU3RyaW5nO1xuXG4vLyBDaGVja3MgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuXG5mdW5jdGlvbiBoYXMob2JqLCBwcm9wTmFtZSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxufVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbik7IH0pO1xuXG4vLyBUaGVzZSBhcmUgdXNlZCB3aGVuIGBvcHRpb25zLmxvY2F0aW9uc2AgaXMgb24sIGZvciB0aGVcbi8vIGBzdGFydExvY2AgYW5kIGBlbmRMb2NgIHByb3BlcnRpZXMuXG5cbnZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICB0aGlzLmxpbmUgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiA9IGNvbDtcbn07XG5cblBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmUsIHRoaXMuY29sdW1uICsgbilcbn07XG5cbnZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICB0aGlzLmVuZCA9IGVuZDtcbiAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxufTtcblxuLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3Vcbi8vIHdhbnQgdG8gZmluZCB0aGUgbGluZS9jb2x1bW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4vLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4vLyBpbnRvLlxuXG5mdW5jdGlvbiBnZXRMaW5lSW5mbyhpbnB1dCwgb2Zmc2V0KSB7XG4gIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IGN1cjtcbiAgICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA8IG9mZnNldCkge1xuICAgICAgKytsaW5lO1xuICAgICAgY3VyID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbi8vIHRoZSBwYXJzZXIgcHJvY2Vzcy4gVGhlc2Ugb3B0aW9ucyBhcmUgcmVjb2duaXplZDpcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAvLyBgZWNtYVZlcnNpb25gIGluZGljYXRlcyB0aGUgRUNNQVNjcmlwdCB2ZXJzaW9uIHRvIHBhcnNlLiBNdXN0IGJlXG4gIC8vIGVpdGhlciAzLCA1LCA2ICgyMDE1KSwgNyAoMjAxNiksIDggKDIwMTcpLCA5ICgyMDE4KSwgb3IgMTBcbiAgLy8gKDIwMTkpLiBUaGlzIGluZmx1ZW5jZXMgc3VwcG9ydCBmb3Igc3RyaWN0IG1vZGUsIHRoZSBzZXQgb2ZcbiAgLy8gcmVzZXJ2ZWQgd29yZHMsIGFuZCBzdXBwb3J0IGZvciBuZXcgc3ludGF4IGZlYXR1cmVzLiBUaGUgZGVmYXVsdFxuICAvLyBpcyA5LlxuICBlY21hVmVyc2lvbjogOSxcbiAgLy8gYHNvdXJjZVR5cGVgIGluZGljYXRlcyB0aGUgbW9kZSB0aGUgY29kZSBzaG91bGQgYmUgcGFyc2VkIGluLlxuICAvLyBDYW4gYmUgZWl0aGVyIGBcInNjcmlwdFwiYCBvciBgXCJtb2R1bGVcImAuIFRoaXMgaW5mbHVlbmNlcyBnbG9iYWxcbiAgLy8gc3RyaWN0IG1vZGUgYW5kIHBhcnNpbmcgb2YgYGltcG9ydGAgYW5kIGBleHBvcnRgIGRlY2xhcmF0aW9ucy5cbiAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgLy8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gIGNhbiBiZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWRcbiAgLy8gd2hlbiBhIHNlbWljb2xvbiBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkLiBJdCB3aWxsIGJlIHBhc3NlZFxuICAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbW1hIGFzIGFuIG9mZnNldCwgYW5kIGlmIGBsb2NhdGlvbnNgIGlzXG4gIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBhd2FpdCBpZGVudGlmaWVycyBhcmUgYWxsb3dlZCB0byBhcHBlYXIgYXQgdGhlIHRvcC1sZXZlbCBzY29wZSxcbiAgLy8gYnV0IHRoZXkgYXJlIHN0aWxsIG5vdCBhbGxvd2VkIGluIG5vbi1hc3luYyBmdW5jdGlvbnMuXG4gIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGVcbiAgLy8gaXMgYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC5cbiAgYWxsb3dIYXNoQmFuZzogZmFsc2UsXG4gIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgLy8gbGluZSBiZWluZyAxLWJhc2VkIGFuZCBjb2x1bW4gMC1iYXNlZCkgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGVcbiAgLy8gbm9kZXMuXG4gIGxvY2F0aW9uczogZmFsc2UsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Ub2tlbmAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIG9iamVjdCBpbiB0aGUgc2FtZVxuICAvLyBmb3JtYXQgYXMgdG9rZW5zIHJldHVybmVkIGZyb20gYHRva2VuaXplcigpLmdldFRva2VuKClgLiBOb3RlXG4gIC8vIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZSBwYXJzZXIgZnJvbSB0aGVcbiAgLy8gY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gIG9uVG9rZW46IG51bGwsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Db21tZW50YCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggYChibG9jaywgdGV4dCwgc3RhcnQsXG4gIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAvLyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgYmxvY2sgKGAvKiAqL2ApIGNvbW1lbnQsXG4gIC8vIGB0ZXh0YCBpcyB0aGUgY29udGVudCBvZiB0aGUgY29tbWVudCwgYW5kIGBzdGFydGAgYW5kIGBlbmRgIGFyZVxuICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAvLyBwYXNzZWQsIHRoZSBmdWxsIGB7bGluZSwgY29sdW1ufWAgbG9jYXRpb25zIG9mIHRoZSBzdGFydCBhbmRcbiAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvbkNvbW1lbnQ6IG51bGwsXG4gIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAvLyBgdHJ1ZWAuXG4gIC8vXG4gIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICByYW5nZXM6IGZhbHNlLFxuICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICBwcm9ncmFtOiBudWxsLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gIHNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG59O1xuXG4vLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXMob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KVxuICAgIHsgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5OyB9XG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICBpZiAoaXNBcnJheShvcHRpb25zLm9uVG9rZW4pKSB7XG4gICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICBvcHRpb25zLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHRva2VuKTsgfTtcbiAgfVxuICBpZiAoaXNBcnJheShvcHRpb25zLm9uQ29tbWVudCkpXG4gICAgeyBvcHRpb25zLm9uQ29tbWVudCA9IHB1c2hDb21tZW50KG9wdGlvbnMsIG9wdGlvbnMub25Db21tZW50KTsgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHB1c2hDb21tZW50KG9wdGlvbnMsIGFycmF5KSB7XG4gIHJldHVybiBmdW5jdGlvbihibG9jaywgdGV4dCwgc3RhcnQsIGVuZCwgc3RhcnRMb2MsIGVuZExvYykge1xuICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgdHlwZTogYmxvY2sgPyBcIkJsb2NrXCIgOiBcIkxpbmVcIixcbiAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmRcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7IH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07IH1cbiAgICBhcnJheS5wdXNoKGNvbW1lbnQpO1xuICB9XG59XG5cbi8vIEVhY2ggc2NvcGUgZ2V0cyBhIGJpdHNldCB0aGF0IG1heSBjb250YWluIHRoZXNlIGZsYWdzXG52YXIgU0NPUEVfVE9QID0gMTtcbnZhciBTQ09QRV9GVU5DVElPTiA9IDI7XG52YXIgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT047XG52YXIgU0NPUEVfQVNZTkMgPSA0O1xudmFyIFNDT1BFX0dFTkVSQVRPUiA9IDg7XG52YXIgU0NPUEVfQVJST1cgPSAxNjtcbnZhciBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMjtcbnZhciBTQ09QRV9TVVBFUiA9IDY0O1xudmFyIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyODtcblxuZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbn1cblxuLy8gVXNlZCBpbiBjaGVja0xWYWwgYW5kIGRlY2xhcmVOYW1lIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhIGJpbmRpbmdcbnZhciBCSU5EX05PTkUgPSAwO1xudmFyIEJJTkRfVkFSID0gMTtcbnZhciBCSU5EX0xFWElDQUwgPSAyO1xudmFyIEJJTkRfRlVOQ1RJT04gPSAzO1xudmFyIEJJTkRfU0lNUExFX0NBVENIID0gNDtcbnZhciBCSU5EX09VVFNJREUgPSA1OyAvLyBTcGVjaWFsIGNhc2UgZm9yIGZ1bmN0aW9uIG5hbWVzIGFzIGJvdW5kIGluc2lkZSB0aGUgZnVuY3Rpb25cblxuZnVuY3Rpb24ga2V5d29yZFJlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKVxufVxuXG52YXIgUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBzdGFydFBvcykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5zb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlO1xuICB0aGlzLmtleXdvcmRzID0ga2V5d29yZFJlZ2V4cChrZXl3b3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogNV0pO1xuICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICBpZiAoIW9wdGlvbnMuYWxsb3dSZXNlcnZlZCkge1xuICAgIGZvciAodmFyIHYgPSBvcHRpb25zLmVjbWFWZXJzaW9uOzsgdi0tKVxuICAgICAgeyBpZiAocmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW3ZdKSB7IGJyZWFrIH0gfVxuICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHsgcmVzZXJ2ZWQgKz0gXCIgYXdhaXRcIjsgfVxuICB9XG4gIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IGtleXdvcmRSZWdleHAocmVzZXJ2ZWQpO1xuICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0ID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICBpZiAoc3RhcnRQb3MpIHtcbiAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICB9XG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcbiAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSAwO1xuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gIHRoaXMubGFiZWxzID0gW107XG5cbiAgLy8gSWYgZW5hYmxlZCwgc2tpcCBsZWFkaW5nIGhhc2hiYW5nIGxpbmUuXG4gIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAvLyBTY29wZSB0cmFja2luZyBmb3IgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzIChzZWUgc2NvcGUuanMpXG4gIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfVE9QKTtcblxuICAvLyBGb3IgUmVnRXhwIHZhbGlkYXRpb25cbiAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpbkZ1bmN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluR2VuZXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQXN5bmM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd0RpcmVjdFN1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLm9wdGlvbnMucHJvZ3JhbSB8fCB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHRUb2tlbigpO1xuICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5GdW5jdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5Bc3luYy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX1NVUEVSKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd0RpcmVjdFN1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0RJUkVDVF9TVVBFUikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpIH07XG5cbi8vIFN3aXRjaCB0byBhIGdldHRlciBmb3IgNy4wLjAuXG5QYXJzZXIucHJvdG90eXBlLmluTm9uQXJyb3dGdW5jdGlvbiA9IGZ1bmN0aW9uIGluTm9uQXJyb3dGdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cblBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgIHZhciBwbHVnaW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICB2YXIgY2xzID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGNscyA9IHBsdWdpbnNbaV0oY2xzKTsgfVxuICByZXR1cm4gY2xzXG59O1xuXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG59O1xuXG5QYXJzZXIucGFyc2VFeHByZXNzaW9uQXQgPSBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdCAoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICB2YXIgcGFyc2VyID0gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gIHBhcnNlci5uZXh0VG9rZW4oKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZUV4cHJlc3Npb24oKVxufTtcblxuUGFyc2VyLnRva2VuaXplciA9IGZ1bmN0aW9uIHRva2VuaXplciAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBhcnNlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgcHAgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbnZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ10pKj8pJ3xcIigoPzpcXFxcLnxbXlwiXSkqPylcIikvO1xucHAuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIFRyeSB0byBmaW5kIHN0cmluZyBsaXRlcmFsLlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcyQxLmlucHV0KVswXS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMkMS5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgIC8vIFNraXAgc2VtaWNvbG9uLCBpZiBhbnkuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzJDEuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICBpZiAodGhpcyQxLmlucHV0W3N0YXJ0XSA9PT0gJzsnKVxuICAgICAgeyBzdGFydCsrOyB9XG4gIH1cbn07XG5cbi8vIFByZWRpY2F0ZSB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuXG4vLyB0eXBlLCBhbmQgaWYgeWVzLCBjb25zdW1lcyBpdCBhcyBhIHNpZGUgZWZmZWN0LlxuXG5wcC5lYXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG4vLyBUZXN0cyB3aGV0aGVyIHBhcnNlZCB0b2tlbiBpcyBhIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgIXRoaXMuY29udGFpbnNFc2Ncbn07XG5cbi8vIENvbnN1bWVzIGNvbnRleHR1YWwga2V5d29yZCBpZiBwb3NzaWJsZS5cblxucHAuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChuYW1lKSkgeyByZXR1cm4gZmFsc2UgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxucHAuY2FuSW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLmVvZiB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2VSIHx8XG4gICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxucHAuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuXG4vLyBDb25zdW1lIGEgc2VtaWNvbG9uLCBvciwgZmFpbGluZyB0aGF0LCBzZWUgaWYgd2UgYXJlIGFsbG93ZWQgdG9cbi8vIHByZXRlbmQgdGhhdCB0aGVyZSBpcyBhIHNlbWljb2xvbiBhdCB0aGlzIHBvc2l0aW9uLlxuXG5wcC5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmVhdCh0eXBlcy5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24odG9rVHlwZSwgbm90TmV4dCkge1xuICBpZiAodGhpcy50eXBlID09PSB0b2tUeXBlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgIGlmICghbm90TmV4dClcbiAgICAgIHsgdGhpcy5uZXh0KCk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuXG4vLyBFeHBlY3QgYSB0b2tlbiBvZiBhIGdpdmVuIHR5cGUuIElmIGZvdW5kLCBjb25zdW1lIGl0LCBvdGhlcndpc2UsXG4vLyByYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG5wcC5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxuLy8gUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xufTtcblxuZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPVxuICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRCaW5kID1cbiAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgLTE7XG59XG5cbnBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID4gLTEpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICBpZiAocGFyZW5zID4gLTEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBhcmVucywgXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbn07XG5cbnBwLmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gIHZhciBkb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gIGlmICghYW5kVGhyb3cpIHsgcmV0dXJuIHNob3J0aGFuZEFzc2lnbiA+PSAwIHx8IGRvdWJsZVByb3RvID49IDAgfVxuICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgeyB0aGlzLnJhaXNlKHNob3J0aGFuZEFzc2lnbiwgXCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuc1wiKTsgfVxuICBpZiAoZG91YmxlUHJvdG8gPj0gMClcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG59O1xuXG5wcC5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG59O1xuXG5wcC5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbn07XG5cbnZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMjIFN0YXRlbWVudCBwYXJzaW5nXG5cbi8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbi8vIGBwcm9ncmFtYCBhcmd1bWVudC4gIElmIHByZXNlbnQsIHRoZSBzdGF0ZW1lbnRzIHdpbGwgYmUgYXBwZW5kZWRcbi8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgbm9kZS5cblxucHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZXhwb3J0cyA9IHt9O1xuICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5lb2YpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMkMS5wYXJzZVN0YXRlbWVudChudWxsLCB0cnVlLCBleHBvcnRzKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG59O1xuXG52YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifTtcbnZhciBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxucHAkMS5pc0xldCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAvLyBGb3IgYW1iaWd1b3VzIGNhc2VzLCBkZXRlcm1pbmUgaWYgYSBMZXhpY2FsRGVjbGFyYXRpb24gKG9yIG9ubHkgYVxuICAvLyBTdGF0ZW1lbnQpIGlzIGFsbG93ZWQgaGVyZS4gSWYgY29udGV4dCBpcyBub3QgZW1wdHkgdGhlbiBvbmx5IGEgU3RhdGVtZW50XG4gIC8vIGlzIGFsbG93ZWQuIEhvd2V2ZXIsIGBsZXQgW2AgaXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgbG9va2FoZWFkIGZvclxuICAvLyBFeHByZXNzaW9uU3RhdGVtZW50LCBzbyBzcGVjaWFsLWNhc2UgaXQgZmlyc3QuXG4gIGlmIChuZXh0Q2ggPT09IDkxKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snXG4gIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKG5leHRDaCA9PT0gMTIzKSB7IHJldHVybiB0cnVlIH0gLy8gJ3snXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgIHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpLCB0cnVlKSkgeyArK3BvczsgfVxuICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICBpZiAoIWtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdChpZGVudCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gY2hlY2sgJ2FzeW5jIFtubyBMaW5lVGVybWluYXRvciBoZXJlXSBmdW5jdGlvbidcbi8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuLy8gLSAnYXN5bmMgLypcXG4qLyBmdW5jdGlvbicgaXMgaW52YWxpZC5cbnBwJDEuaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGg7XG4gIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIChuZXh0ICsgOCA9PT0gdGhpcy5pbnB1dC5sZW5ndGggfHwgIWlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQXQobmV4dCArIDgpKSlcbn07XG5cbi8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbi8vXG4vLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2Vcbi8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pYCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbi8vIGRvZXMgbm90IGhlbHAuXG5cbnBwJDEucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZXh0LCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgIHN0YXJ0dHlwZSA9IHR5cGVzLl92YXI7XG4gICAga2luZCA9IFwibGV0XCI7XG4gIH1cblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICBjYXNlIHR5cGVzLl9icmVhazogY2FzZSB0eXBlcy5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgY2FzZSB0eXBlcy5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgIC8vIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlxuICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKVxuICBjYXNlIHR5cGVzLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3N3aXRjaDogcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9jb25zdDogY2FzZSB0eXBlcy5fdmFyOlxuICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgaWYgKGNvbnRleHQgJiYga2luZCAhPT0gXCJ2YXJcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gIGNhc2UgdHlwZXMuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jayh0cnVlLCBub2RlKVxuICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikgfVxuICB9XG59O1xuXG5wcCQxLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtleXdvcmQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgZWxzZSB7XG4gICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgLy8gY29udGludWUgdG8uXG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsYWIgPSB0aGlzJDEubGFiZWxzW2ldO1xuICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG59O1xuXG4vLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4vLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbi8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4vLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4vLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4vLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbnBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkgJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXdhaXRcIikpID8gdGhpcy5sYXN0VG9rU3RhcnQgOiAtMTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICEoa2luZCAhPT0gXCJ2YXJcIiAmJiBpbml0JDEuZGVjbGFyYXRpb25zWzBdLmluaXQpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICB9XG4gIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgIH1cbiAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICB9XG4gIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jLCBkZWNsYXJhdGlvblBvc2l0aW9uKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGZhbHNlLCBpc0FzeW5jKVxufTtcblxucHAkMS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAvLyBhbGxvdyBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgaW4gYnJhbmNoZXMsIGJ1dCBvbmx5IGluIG5vbi1zdHJpY3QgbW9kZVxuICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIik7XG4gIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpIDogbnVsbDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gIC8vIHBvc3NpYmlsaXR5IHRvIGluc2VydCBvbmUuXG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5jYXNlcyA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB0aGlzLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgdGhpcy5lbnRlclNjb3BlKDApO1xuXG4gIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAvLyBub2Rlcy4gYGN1cmAgaXMgdXNlZCB0byBrZWVwIHRoZSBub2RlIHRoYXQgd2UgYXJlIGN1cnJlbnRseVxuICAvLyBhZGRpbmcgc3RhdGVtZW50cyB0by5cblxuICB2YXIgY3VyO1xuICBmb3IgKHZhciBzYXdEZWZhdWx0ID0gZmFsc2U7IHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSOykge1xuICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcyQxLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcyQxLnR5cGUgPT09IHR5cGVzLl9jYXNlO1xuICAgICAgaWYgKGN1cikgeyB0aGlzJDEuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMkMS5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcyQxLm5leHQoKTtcbiAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgY3VyLnRlc3QgPSB0aGlzJDEucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZSh0aGlzJDEubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7IHRoaXMkMS51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcyQxLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgdGhpcy5uZXh0KCk7IC8vIENsb3NpbmcgYnJhY2VcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmIChsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFJldXNlZCBlbXB0eSBhcnJheSBhZGRlZCBmb3Igbm9kZSBmaWVsZHMgdGhhdCBhcmUgYWx3YXlzIGVtcHR5LlxuXG52YXIgZW1wdHkgPSBbXTtcblxucHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NhdGNoKSB7XG4gICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgICAgdmFyIHNpbXBsZSA9IGNsYXVzZS5wYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICAgIHRoaXMuZW50ZXJTY29wZShzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgc2ltcGxlID8gQklORF9TSU1QTEVfQ0FUQ0ggOiBCSU5EX0xFWElDQUwpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgIH1cbiAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICB9XG4gIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IHRoaXMkMS5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICB7XG4gICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgIHsgdGhpcyQxLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gIH0gfVxuICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFiZWwkMSA9IHRoaXMkMS5sYWJlbHNbaV07XG4gICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICBsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID0gdGhpcyQxLnN0YXJ0O1xuICAgICAgbGFiZWwkMS5raW5kID0ga2luZDtcbiAgICB9IGVsc2UgeyBicmVhayB9XG4gIH1cbiAgdGhpcy5sYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kLCBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGFydH0pO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGNvbnRleHQgPyBjb250ZXh0LmluZGV4T2YoXCJsYWJlbFwiKSA9PT0gLTEgPyBjb250ZXh0ICsgXCJsYWJlbFwiIDogY29udGV4dCA6IFwibGFiZWxcIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICBub2RlLmxhYmVsID0gZXhwcjtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgZXhwcikge1xuICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4vLyBzdHJpY3RcImAgZGVjbGFyYXRpb25zIHdoZW4gYGFsbG93U3RyaWN0YCBpcyB0cnVlICh1c2VkIGZvclxuLy8gZnVuY3Rpb24gYm9kaWVzKS5cblxucHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBub2RlLmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzJDEucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4vLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbnBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0eXBlID09PSBcIkZvckluU3RhdGVtZW50XCIpIHtcbiAgICBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgfHxcbiAgICAgIChpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgICAgICh0aGlzLnN0cmljdCB8fCBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIikpKVxuICAgICAgeyB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiSW52YWxpZCBhc3NpZ25tZW50IGluIGZvci1pbiBsb29wIGhlYWRcIik7IH1cbiAgfVxuICBub2RlLmxlZnQgPSBpbml0O1xuICBub2RlLnJpZ2h0ID0gdHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKVxufTtcblxuLy8gUGFyc2UgYSBsaXN0IG9mIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cblxucHAkMS5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIGlzRm9yLCBraW5kKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZGVjbCA9IHRoaXMkMS5zdGFydE5vZGUoKTtcbiAgICB0aGlzJDEucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAodGhpcyQxLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgIGRlY2wuaW5pdCA9IHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMkMS50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMkMS5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcyQxLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMkMS51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5faW4gfHwgdGhpcyQxLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMkMS5yYWlzZSh0aGlzJDEubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzJDEuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgaWYgKChraW5kID09PSBcImNvbnN0XCIgfHwga2luZCA9PT0gXCJsZXRcIikgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHtcbiAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpO1xuICB9XG4gIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG59O1xuXG52YXIgRlVOQ19TVEFURU1FTlQgPSAxO1xudmFyIEZVTkNfSEFOR0lOR19TVEFURU1FTlQgPSAyO1xudmFyIEZVTkNfTlVMTEFCTEVfSUQgPSA0O1xuXG4vLyBQYXJzZSBhIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkMS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSwgc3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc0FzeW5jKSB7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICBpZiAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpIHtcbiAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICBpZiAobm9kZS5pZCAmJiAhKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgLy8gSWYgaXQgaXMgYSByZWd1bGFyIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIGluIHNsb3BweSBtb2RlLCB0aGVuIGl0IGlzXG4gICAgICAvLyBzdWJqZWN0IHRvIEFubmV4IEIgc2VtYW50aWNzIChCSU5EX0ZVTkNUSU9OKS4gT3RoZXJ3aXNlLCB0aGUgYmluZGluZ1xuICAgICAgLy8gbW9kZSBkZXBlbmRzIG9uIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgc2NvcGUgKHNlZVxuICAgICAgLy8gdHJlYXRGdW5jdGlvbnNBc1ZhcikuXG4gICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgfVxuXG4gIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcztcbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gIGlmICghKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSlcbiAgICB7IG5vZGUuaWQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbnBwJDEucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xufTtcblxuLy8gUGFyc2UgYSBjbGFzcyBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbnBwJDEucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgLy8gQSBjbGFzcyBkZWZpbml0aW9uIGlzIGFsd2F5cyBzdHJpY3QgbW9kZSBjb2RlLlxuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcyQxLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcyQxLnJhaXNlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgIGhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxufTtcblxucHAkMS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIHRyeUNvbnRleHR1YWwgPSBmdW5jdGlvbiAoaywgbm9MaW5lQnJlYWspIHtcbiAgICBpZiAoIG5vTGluZUJyZWFrID09PSB2b2lkIDAgKSBub0xpbmVCcmVhayA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcyQxLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMkMS5zdGFydExvYztcbiAgICBpZiAoIXRoaXMkMS5lYXRDb250ZXh0dWFsKGspKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMkMS50eXBlICE9PSB0eXBlcy5wYXJlbkwgJiYgKCFub0xpbmVCcmVhayB8fCAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKG1ldGhvZC5rZXkpIHsgdGhpcyQxLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIG1ldGhvZC5rZXkgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnQsIHN0YXJ0TG9jKTtcbiAgICBtZXRob2Qua2V5Lm5hbWUgPSBrO1xuICAgIHRoaXMkMS5maW5pc2hOb2RlKG1ldGhvZC5rZXksIFwiSWRlbnRpZmllclwiKTtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gIG1ldGhvZC5zdGF0aWMgPSB0cnlDb250ZXh0dWFsKFwic3RhdGljXCIpO1xuICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgaWYgKCFpc0dlbmVyYXRvcikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiB0cnlDb250ZXh0dWFsKFwiYXN5bmNcIiwgdHJ1ZSkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJnZXRcIikpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJnZXRcIjtcbiAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJzZXRcIjtcbiAgICB9XG4gIH1cbiAgaWYgKCFtZXRob2Qua2V5KSB7IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTsgfVxuICB2YXIga2V5ID0gbWV0aG9kLmtleTtcbiAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gIGlmICghbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgIGlmIChtZXRob2Qua2luZCAhPT0gXCJtZXRob2RcIikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICBpZiAoaXNHZW5lcmF0b3IpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICBpZiAoaXNBc3luYykgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBtZXRob2RcIik7IH1cbiAgICBtZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICBhbGxvd3NEaXJlY3RTdXBlciA9IGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gIH0gZWxzZSBpZiAobWV0aG9kLnN0YXRpYyAmJiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwicHJvdG90eXBlXCIpIHtcbiAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gIH1cbiAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gIHJldHVybiBtZXRob2Rcbn07XG5cbnBwJDEucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxufTtcblxucHAkMS5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSlcbiAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gIH1cbn07XG5cbnBwJDEucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG59O1xuXG4vLyBQYXJzZXMgbW9kdWxlIGV4cG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGV4cG9ydCAqIGZyb20gJy4uLidcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnN0YXIpKSB7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgdmFyIGlzQXN5bmM7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uIHx8IChpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NsYXNzKSB7XG4gICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzJDEuY2hlY2tVbnJlc2VydmVkKHNwZWMubG9jYWwpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDEuY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGlmIChoYXMoZXhwb3J0cywgbmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCBcIkR1cGxpY2F0ZSBleHBvcnQgJ1wiICsgbmFtZSArIFwiJ1wiKTsgfVxuICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbn07XG5cbnBwJDEuY2hlY2tQYXR0ZXJuRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgcGF0KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0Lm5hbWUsIHBhdC5zdGFydCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMkMS5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICBpZiAoZWx0KSB7IHRoaXMkMS5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgIH0gfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuYXJndW1lbnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxufTtcblxucHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICB0aGlzJDEuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICB9XG59O1xuXG5wcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG5wcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzJDEuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMkMS5wYXJzZUlkZW50KHRydWUpO1xuICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzJDEuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgIHRoaXMkMS5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIG5vZGUuZXhwb3J0ZWQuc3RhcnQpO1xuICAgIG5vZGVzLnB1c2godGhpcyQxLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gIH1cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBub2RlJDIgPSB0aGlzJDEuc3RhcnROb2RlKCk7XG4gICAgbm9kZSQyLmltcG9ydGVkID0gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMkMS5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgIG5vZGUkMi5sb2NhbCA9IHRoaXMkMS5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMkMS5jaGVja1VucmVzZXJ2ZWQobm9kZSQyLmltcG9ydGVkKTtcbiAgICAgIG5vZGUkMi5sb2NhbCA9IG5vZGUkMi5pbXBvcnRlZDtcbiAgICB9XG4gICAgdGhpcyQxLmNoZWNrTFZhbChub2RlJDIubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgbm9kZXMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkMS5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gIClcbn07XG5cbnZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMkMS50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzJDEucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaCB0byBBc3NpZ25tZW50UGF0dGVyblxuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmICghaXNCaW5kaW5nKSB7IGJyZWFrIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG5wcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgaWYgKGVsdCkgeyB0aGlzJDEudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICB9XG4gIGlmIChlbmQpIHtcbiAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgaXNCaW5kaW5nICYmIGxhc3QgJiYgbGFzdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiYgbGFzdC5hcmd1bWVudC50eXBlICE9PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKGxhc3QuYXJndW1lbnQuc3RhcnQpOyB9XG4gIH1cbiAgcmV0dXJuIGV4cHJMaXN0XG59O1xuXG4vLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbnBwJDIucGFyc2VTcHJlYWQgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxufTtcblxucHAkMi5wYXJzZVJlc3RCaW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gUmVzdEVsZW1lbnQgaW5zaWRlIG9mIGEgZnVuY3Rpb24gcGFyYW1ldGVyIG11c3QgYmUgYW4gaWRlbnRpZmllclxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSlcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxufTtcblxuLy8gUGFyc2VzIGx2YWx1ZSAoYXNzaWduYWJsZSkgYXRvbS5cblxucHAkMi5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxufTtcblxucHAkMi5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2U7IH1cbiAgICBlbHNlIHsgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb21tYSk7IH1cbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgdmFyIHJlc3QgPSB0aGlzJDEucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgdGhpcyQxLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgZWx0cy5wdXNoKHJlc3QpO1xuICAgICAgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgdGhpcyQxLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMkMS5wYXJzZU1heWJlRGVmYXVsdCh0aGlzJDEuc3RhcnQsIHRoaXMkMS5zdGFydExvYyk7XG4gICAgICB0aGlzJDEucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgICBlbHRzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgcmV0dXJuIHBhcmFtXG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gIGxlZnQgPSBsZWZ0IHx8IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMuZXEpKSB7IHJldHVybiBsZWZ0IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG59O1xuXG4vLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4vLyB0by5cbi8vIGJpbmRpbmdUeXBlIGNhbiBiZSBlaXRoZXI6XG4vLyAndmFyJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhICd2YXInIGJpbmRpbmdcbi8vICdsZXQnIGluZGljYXRpbmcgdGhhdCB0aGUgbHZhbCBjcmVhdGVzIGEgbGV4aWNhbCAoJ2xldCcgb3IgJ2NvbnN0JykgYmluZGluZ1xuLy8gJ25vbmUnIGluZGljYXRpbmcgdGhhdCB0aGUgYmluZGluZyBzaG91bGQgYmUgY2hlY2tlZCBmb3IgaWxsZWdhbCBpZGVudGlmaWVycywgYnV0IG5vdCBmb3IgZHVwbGljYXRlIHJlZmVyZW5jZXNcblxucHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZyBcIiA6IFwiQXNzaWduaW5nIHRvIFwiKSArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgaWYgKGhhcyhjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORSAmJiBiaW5kaW5nVHlwZSAhPT0gQklORF9PVVRTSURFKSB7IHRoaXMuZGVjbGFyZU5hbWUoZXhwci5uYW1lLCBiaW5kaW5nVHlwZSwgZXhwci5zdGFydCk7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgaWYgKGJpbmRpbmdUeXBlKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIHRoaXMkMS5jaGVja0xWYWwocHJvcCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgIC8vIEFzc2lnbm1lbnRQcm9wZXJ0eSBoYXMgdHlwZSA9PT0gXCJQcm9wZXJ0eVwiXG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoZWxlbSkgeyB0aGlzJDEuY2hlY2tMVmFsKGVsZW0sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpOyB9XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5sZWZ0LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICB9XG59O1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuLy8gc3ludGFjdGljIGVsZW1lbnRzLCBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aG9zZSwgZWFjaCBmdW5jdGlvblxuLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbi8vIGluc3RlYWQgb2YgYCgheClbMV1gIGlzIGhhbmRsZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGUgcGFyc2VyXG4vLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4vLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMg4oCUIHRoYXRcbi8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbi8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbi8vXG4vLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4vLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbi8vIHRoZSB0ZWNobmlxdWUgb3V0bGluZWQgYWJvdmUsIHdoaWNoIHVzZXMgZGlmZmVyZW50LCBuZXN0aW5nXG4vLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4vLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbi8vXG4vLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG52YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIENoZWNrIGlmIHByb3BlcnR5IG5hbWUgY2xhc2hlcyB3aXRoIGFscmVhZHkgYWRkZWQuXG4vLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4vLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4vLyBzdHJpY3QgbW9kZSwgaW5pdCBwcm9wZXJ0aWVzIGFyZSBhbHNvIG5vdCBhbGxvd2VkIHRvIGJlIHJlcGVhdGVkLlxuXG5wcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgeyByZXR1cm4gfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgIHsgcmV0dXJuIH1cbiAgdmFyIGtleSA9IHByb3Aua2V5O1xuICB2YXIgbmFtZTtcbiAgc3dpdGNoIChrZXkudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOiBuYW1lID0ga2V5Lm5hbWU7IGJyZWFrXG4gIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgZGVmYXVsdDogcmV0dXJuXG4gIH1cbiAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiICYmIGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA8IDApIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDsgfVxuICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGtsdWRnZS4gQ2FuIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjBcbiAgICAgICAgZWxzZSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICAgICAgfVxuICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBuYW1lID0gXCIkXCIgKyBuYW1lO1xuICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgaWYgKG90aGVyKSB7XG4gICAgdmFyIHJlZGVmaW5pdGlvbjtcbiAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICB9XG4gICAgaWYgKHJlZGVmaW5pdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBvdGhlciA9IHByb3BIYXNoW25hbWVdID0ge1xuICAgICAgaW5pdDogZmFsc2UsXG4gICAgICBnZXQ6IGZhbHNlLFxuICAgICAgc2V0OiBmYWxzZVxuICAgIH07XG4gIH1cbiAgb3RoZXJba2luZF0gPSB0cnVlO1xufTtcblxuLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4vLyBUaGVzZSBuZXN0LCBmcm9tIHRoZSBtb3N0IGdlbmVyYWwgZXhwcmVzc2lvbiB0eXBlIGF0IHRoZSB0b3AgdG9cbi8vICdhdG9taWMnLCBub25kaXZpc2libGUgZXhwcmVzc2lvbiB0eXBlcyBhdCB0aGUgYm90dG9tLiBNb3N0IG9mXG4vLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbi8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4vLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbi8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4vLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0YWxpemF0aW9uIGV4cHJlc3Npb25zKVxuLy8gYW5kIHByb3ZpZGUgcmVmZXJlbmNlIGZvciBzdG9yaW5nICc9JyBvcGVyYXRvciBpbnNpZGUgc2hvcnRoYW5kXG4vLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbi8vIGFuZCBvYmplY3QgcGF0dGVybiBtaWdodCBhcHBlYXIgKHNvIGl0J3MgcG9zc2libGUgdG8gcmFpc2Vcbi8vIGRlbGF5ZWQgc3ludGF4IGVycm9yIGF0IGNvcnJlY3QgcG9zaXRpb24pLlxuXG5wcCQzLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuLy8gb3BlcmF0b3JzIGxpa2UgYCs9YC5cblxucHAkMy5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvcikgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKG5vSW4pIH1cbiAgICAvLyBUaGUgdG9rZW5pemVyIHdpbGwgYXNzdW1lIGFuIGV4cHJlc3Npb24gaXMgYWxsb3dlZCBhZnRlclxuICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgIGVsc2UgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgfVxuXG4gIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMSwgb2xkU2hvcnRoYW5kQXNzaWduID0gLTE7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICBvbGRTaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICB7IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7IH1cbiAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgPyB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgOiBsZWZ0O1xuICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyBEZXN0cnVjdHVyaW5nRXJyb3JzLmNhbGwocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xOyAvLyByZXNldCBiZWNhdXNlIHNob3J0aGFuZCBkZWZhdWx0IHdhcyB1c2VkIGNvcnJlY3RseVxuICAgIHRoaXMuY2hlY2tMVmFsKGxlZnQpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgfVxuICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICBpZiAob2xkVHJhaWxpbmdDb21tYSA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IG9sZFRyYWlsaW5nQ29tbWE7IH1cbiAgaWYgKG9sZFNob3J0aGFuZEFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gb2xkU2hvcnRoYW5kQXNzaWduOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbnBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICByZXR1cm4gZXhwci5zdGFydCA9PT0gc3RhcnRQb3MgJiYgZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPyBleHByIDogdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKVxufTtcblxuLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbi8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4vLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbi8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbi8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxucHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICBpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCB0aGlzLnR5cGUgIT09IHR5cGVzLl9pbikpIHtcbiAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgIHZhciBsb2dpY2FsID0gdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgdmFyIG9wID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgbm9Jbik7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9JbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlZnRcbn07XG5cbnBwJDMuYnVpbGRCaW5hcnkgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5vcGVyYXRvciA9IG9wO1xuICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxucHAkMy5wYXJzZU1heWJlVW5hcnkgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBzYXdVbmFyeSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSkge1xuICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoKTtcbiAgICBzYXdVbmFyeSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5pbmNEZWM7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzJDEudmFsdWU7XG4gICAgICBub2RlJDEucHJlZml4ID0gZmFsc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnQgPSBleHByO1xuICAgICAgdGhpcyQxLmNoZWNrTFZhbChleHByKTtcbiAgICAgIHRoaXMkMS5uZXh0KCk7XG4gICAgICBleHByID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSQxLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyc3RhcikpXG4gICAgeyByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShzdGFydFBvcywgc3RhcnRMb2MsIGV4cHIsIHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgXCIqKlwiLCBmYWxzZSkgfVxuICBlbHNlXG4gICAgeyByZXR1cm4gZXhwciB9XG59O1xuXG4vLyBQYXJzZSBjYWxsLCBkb3QsIGFuZCBgW11gLXN1YnNjcmlwdCBleHByZXNzaW9ucy5cblxucHAkMy5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJBdG9tKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICB2YXIgc2tpcEFycm93U3Vic2NyaXB0cyA9IGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva0VuZCkgIT09IFwiKVwiO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgfHwgc2tpcEFycm93U3Vic2NyaXB0cykgeyByZXR1cm4gZXhwciB9XG4gIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuXG5wcCQzLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbWF5YmVBc3luY0Fycm93ID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmlucHV0LnNsaWNlKGJhc2Uuc3RhcnQsIGJhc2UuZW5kKSA9PT0gXCJhc3luY1wiO1xuICBmb3IgKHZhciBjb21wdXRlZCA9ICh2b2lkIDApOzspIHtcbiAgICBpZiAoKGNvbXB1dGVkID0gdGhpcyQxLmVhdCh0eXBlcy5icmFja2V0TCkpIHx8IHRoaXMkMS5lYXQodHlwZXMuZG90KSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUucHJvcGVydHkgPSBjb21wdXRlZCA/IHRoaXMkMS5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMkMS5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgICBpZiAoY29tcHV0ZWQpIHsgdGhpcyQxLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7IH1cbiAgICAgIGJhc2UgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzJDEuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcyQxLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMkMS5hd2FpdFBvcztcbiAgICAgIHRoaXMkMS55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzJDEuYXdhaXRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcyQxLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzJDEub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmICF0aGlzJDEuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcyQxLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgICAgdGhpcyQxLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMkMS5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgICAgdGhpcyQxLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMkMS5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICByZXR1cm4gdGhpcyQxLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzJDEueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzJDEueWllbGRQb3M7XG4gICAgICB0aGlzJDEuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzJDEuYXdhaXRQb3M7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudHMgPSBleHByTGlzdDtcbiAgICAgIGJhc2UgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlKSB7XG4gICAgICB2YXIgbm9kZSQyID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDIudGFnID0gYmFzZTtcbiAgICAgIG5vZGUkMi5xdWFzaSA9IHRoaXMkMS5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXNlXG4gICAgfVxuICB9XG59O1xuXG4vLyBQYXJzZSBhbiBhdG9taWMgZXhwcmVzc2lvbiDigJQgZWl0aGVyIGEgc2luZ2xlIHRva2VuIHRoYXQgaXMgYW5cbi8vIGV4cHJlc3Npb24sIGFuIGV4cHJlc3Npb24gc3RhcnRlZCBieSBhIGtleXdvcmQgbGlrZSBgZnVuY3Rpb25gIG9yXG4vLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbi8vIG9yIGB7fWAuXG5cbnBwJDMucGFyc2VFeHByQXRvbSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgLy8gSWYgYSBkaXZpc2lvbiBvcGVyYXRvciBhcHBlYXJzIGluIGFuIGV4cHJlc3Npb24gcG9zaXRpb24sIHRoZVxuICAvLyB0b2tlbml6ZXIgZ290IGNvbmZ1c2VkLCBhbmQgd2UgZm9yY2UgaXQgdG8gcmVhZCBhIHJlZ2V4cCBpbnN0ZWFkLlxuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidzdXBlcicga2V5d29yZCBvdXRzaWRlIGEgbWV0aG9kXCIpOyB9XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmICF0aGlzLmFsbG93RGlyZWN0U3VwZXIpXG4gICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgLy8gVGhlIGBzdXBlcmAga2V5d29yZCBjYW4gYXBwZWFyIGF0IGJlbG93OlxuICAgIC8vIFN1cGVyUHJvcGVydHk6XG4gICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgLy8gICAgIHN1cGVyIC4gSWRlbnRpZmllck5hbWVcbiAgICAvLyBTdXBlckNhbGw6XG4gICAgLy8gICAgIHN1cGVyIEFyZ3VtZW50c1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLmRvdCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKVxuXG4gIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcy5uYW1lOlxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudCh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLl9mdW5jdGlvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSkgfVxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UpIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmICFjb250YWluc0VzYykge1xuICAgICAgICBpZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRcblxuICBjYXNlIHR5cGVzLnJlZ2V4cDpcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSk7XG4gICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgIHJldHVybiBub2RlXG5cbiAgY2FzZSB0eXBlcy5udW06IGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKVxuXG4gIGNhc2UgdHlwZXMuX251bGw6IGNhc2UgdHlwZXMuX3RydWU6IGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3RydWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsIGV4cHIgPSB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHN0YXJ0OyB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgfVxuICAgIHJldHVybiBleHByXG5cbiAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG5cbiAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpXG5cbiAgY2FzZSB0eXBlcy5fbmV3OlxuICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KClcblxuICBjYXNlIHR5cGVzLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBkZWZhdWx0OlxuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbn07XG5cbnBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIHJldHVybiB2YWxcbn07XG5cbnBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3cpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5SKSB7XG4gICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcyQxLnN0YXJ0O1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMkMS5wYXJzZVBhcmVuSXRlbSh0aGlzJDEucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcyQxLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMkMS5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufTtcblxucHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW1cbn07XG5cbnBwJDMucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbn07XG5cbi8vIE5ldydzIHByZWNlZGVuY2UgaXMgc2xpZ2h0bHkgdHJpY2t5LiBJdCBtdXN0IGFsbG93IGl0cyBhcmd1bWVudCB0b1xuLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbi8vIGFyZ3VtZW50IHRvIHBhcnNlU3Vic2NyaXB0cyB0byBwcmV2ZW50IGl0IGZyb20gY29uc3VtaW5nIHRoZVxuLy8gYXJndW1lbnQgbGlzdC5cblxudmFyIGVtcHR5JDEgPSBbXTtcblxucHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIgfHwgY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyBuZXcudGFyZ2V0XCIpOyB9XG4gICAgaWYgKCF0aGlzLmluTm9uQXJyb3dGdW5jdGlvbigpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHsgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UpOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbnBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgIH1cbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgY29va2VkOiBudWxsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbn07XG5cbnBwJDMucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7IGlmICggaXNUYWdnZWQgPT09IHZvaWQgMCApIGlzVGFnZ2VkID0gZmFsc2U7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmVvZikgeyB0aGlzJDEucmFpc2UodGhpcyQxLnBvcywgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTsgfVxuICAgIHRoaXMkMS5leHBlY3QodHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICB0aGlzJDEuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgbm9kZS5xdWFzaXMucHVzaChjdXJFbHQgPSB0aGlzJDEucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxufTtcblxucHAkMy5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcy5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSkgJiZcbiAgICAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG5wcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5uZXh0KCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIHByb3AgPSB0aGlzJDEucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMkMS5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzUGF0dGVybiA/IFwiT2JqZWN0UGF0dGVyblwiIDogXCJPYmplY3RFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgfVxuICAgIC8vIFRvIGRpc2FsbG93IHBhcmVudGhlc2l6ZWQgaWRlbnRpZmllciB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAvLyBUbyBkaXNhbGxvdyB0cmFpbGluZyBjb21tYSB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgLy8gRmluaXNoXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBzdGFydFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgfVxuICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gIH1cbiAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLmlzQXN5bmNQcm9wKHByb3ApKSB7XG4gICAgaXNBc3luYyA9IHRydWU7XG4gICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICB9IGVsc2Uge1xuICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbG9uKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MKSB7XG4gICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMuY29tbWEgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIHJldHVybiBwcm9wLmtleVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlcbn07XG5cbi8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxucHAkMy5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG59O1xuXG4vLyBQYXJzZSBvYmplY3Qgb3IgY2xhc3MgbWV0aG9kLlxuXG5wcCQzLnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93RGlyZWN0U3VwZXIpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcztcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcztcblxuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcblxuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbnBwJDMucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbihub2RlLCBpc0Fycm93RnVuY3Rpb24pIHtcbiAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlTDtcbiAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgIC8vIG9yIGBhcmd1bWVudHNgLlxuICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgIH1cbiAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAvLyBBZGQgdGhlIHBhcmFtcyB0byB2YXJEZWNsYXJlZE5hbWVzIHRvIGVuc3VyZSB0aGF0IGFuIGVycm9yIGlzIHRocm93blxuICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuICB9XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG5cbiAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG59O1xuXG5wcCQzLmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBDaGVja3MgZnVuY3Rpb24gcGFyYW1zIGZvciB2YXJpb3VzIGRpc2FsbG93ZWQgcGF0dGVybnMgc3VjaCBhcyB1c2luZyBcImV2YWxcIlxuLy8gb3IgXCJhcmd1bWVudHNcIiBhbmQgZHVwbGljYXRlIHBhcmFtZXRlcnMuXG5cbnBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5hbWVIYXNoID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgdGhpcyQxLmNoZWNrTFZhbChwYXJhbSwgQklORF9WQVIsIGFsbG93RHVwbGljYXRlcyA/IG51bGwgOiBuYW1lSGFzaCk7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4vLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4vLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG5wcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpXG4gICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIGVsdCA9IHRoaXMkMS5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMkMS5zdGFydDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzJDEucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfVxuICAgIGVsdHMucHVzaChlbHQpO1xuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQzLmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gIHZhciBlbmQgPSByZWYuZW5kO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW4gbm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbiBub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgaWYgKHRoaXMua2V5d29yZHMudGVzdChuYW1lKSlcbiAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiAmJlxuICAgIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7IHJldHVybiB9XG4gIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICBpZiAocmUudGVzdChuYW1lKSkge1xuICAgIGlmICghdGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbiBub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCAoXCJUaGUga2V5d29yZCAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkXCIpKTtcbiAgfVxufTtcblxuLy8gUGFyc2UgdGhlIG5leHQgdG9rZW4gYXMgYW4gaWRlbnRpZmllci4gSWYgYGxpYmVyYWxgIGlzIHRydWUgKHVzZWRcbi8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuLy8gaWRlbnRpZmllcnMuXG5cbnBwJDMucGFyc2VJZGVudCA9IGZ1bmN0aW9uKGxpYmVyYWwsIGlzQmluZGluZykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmIChsaWJlcmFsICYmIHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSBcIm5ldmVyXCIpIHsgbGliZXJhbCA9IGZhbHNlOyB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7IHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpOyB9XG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG5wcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbihub0luKSB7XG4gIGlmICghdGhpcy55aWVsZFBvcykgeyB0aGlzLnlpZWxkUG9zID0gdGhpcy5zdGFydDsgfVxuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxufTtcblxucHAkMy5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxufTtcblxudmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmFpc2UgZXhjZXB0aW9ucyBvbiBwYXJzZSBlcnJvcnMuIEl0XG4vLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbi8vIG9mIHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgdGhlbiByYWlzZXMgYSBgU3ludGF4RXJyb3JgIHdpdGggdGhhdFxuLy8gbWVzc2FnZS5cblxucHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgdGhyb3cgZXJyXG59O1xuXG5wcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG5wcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gIH1cbn07XG5cbnZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxudmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAvLyBBIGxpc3Qgb2YgdmFyLWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy52YXIgPSBbXTtcbiAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMubGV4aWNhbCA9IFtdO1xuICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIEZ1bmN0aW9uRGVjbGFyYXRpb24gbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xufTtcblxuLy8gVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBrZWVwIHRyYWNrIG9mIGRlY2xhcmVkIHZhcmlhYmxlcyBpbiB0aGUgY3VycmVudCBzY29wZSBpbiBvcmRlciB0byBkZXRlY3QgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzLlxuXG5wcCQ1LmVudGVyU2NvcGUgPSBmdW5jdGlvbihmbGFncykge1xuICB0aGlzLnNjb3BlU3RhY2sucHVzaChuZXcgU2NvcGUoZmxhZ3MpKTtcbn07XG5cbnBwJDUuZXhpdFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbn07XG5cbi8vIFRoZSBzcGVjIHNheXM6XG4vLyA+IEF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmdW5jdGlvbiwgb3Igc2NyaXB0LCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgYXJlXG4vLyA+IHRyZWF0ZWQgbGlrZSB2YXIgZGVjbGFyYXRpb25zIHJhdGhlciB0aGFuIGxpa2UgbGV4aWNhbCBkZWNsYXJhdGlvbnMuXG5wcCQ1LnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgcmV0dXJuIChzY29wZS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSB8fCAhdGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApO1xufTtcblxucHAkNS5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX1NJTVBMRV9DQVRDSCkge1xuICAgIHZhciBzY29wZSQxID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBzY29wZSQxLmxleGljYWwucHVzaChuYW1lKTtcbiAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9GVU5DVElPTikge1xuICAgIHZhciBzY29wZSQyID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAodGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyKVxuICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUkMi52YXIuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgc2NvcGUkMi5mdW5jdGlvbnMucHVzaChuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgc2NvcGUkMyA9IHRoaXMkMS5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgIShzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUgfHxcbiAgICAgICAgICAhdGhpcyQxLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxufTtcblxucHAkNS5jdXJyZW50U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV1cbn07XG5cbnBwJDUuY3VycmVudFZhclNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMkMS5zY29wZVN0YWNrW2ldO1xuICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG4vLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGB0aGlzYCwgYG5ldy50YXJnZXRgLCBgc3VwZXIoKWAsIGBzdXBlci5wcm9wZXJ0eWAsIGFuZCBgc3VwZXJbcHJvcGVydHldYC5cbnBwJDUuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzJDEuc2NvcGVTdGFja1tpXTtcbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIgJiYgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICB0aGlzLnR5cGUgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gcG9zO1xuICB0aGlzLmVuZCA9IDA7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbn07XG5cbi8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbnZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG59O1xuXG5wcCQ2LnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxufTtcblxuLy8gRmluaXNoIGFuIEFTVCBub2RlLCBhZGRpbmcgYHR5cGVgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzLlxuXG5mdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgbm9kZS50eXBlID0gdHlwZTtcbiAgbm9kZS5lbmQgPSBwb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICByZXR1cm4gbm9kZVxufVxuXG5wcCQ2LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbn07XG5cbi8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbnBwJDYuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxufTtcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuLy8gZ2l2ZW4gcG9pbnQgaW4gdGhlIHByb2dyYW0gaXMgbG9vc2VseSBiYXNlZCBvbiBzd2VldC5qcycgYXBwcm9hY2guXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cblxudmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlLCBnZW5lcmF0b3IpIHtcbiAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbn07XG5cbnZhciB0eXBlcyQxID0ge1xuICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxufTtcblxudmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ3LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdHlwZXMkMS5iX3N0YXRdXG59O1xuXG5wcCQ3LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKHBhcmVudCA9PT0gdHlwZXMkMS5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcyQxLmZfc3RhdClcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiAmJiAocGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYl9leHByKSlcbiAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgLy8gVGhlIGNoZWNrIGZvciBgdHQubmFtZSAmJiBleHByQWxsb3dlZGAgZGV0ZWN0cyB3aGV0aGVyIHdlIGFyZVxuICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAvLyBgdHQubmFtZWAuXG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLmV4cHJBbGxvd2VkKVxuICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYXJyb3cpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKVxuICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl92YXIgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxufTtcblxucHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcyQxLmNvbnRleHRbaV07XG4gICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnBwJDcudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzLmRvdClcbiAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpXG4gICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjsgfVxufTtcblxuLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG50eXBlcy5wYXJlblIudXBkYXRlQ29udGV4dCA9IHR5cGVzLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgaWYgKG91dCA9PT0gdHlwZXMkMS5iX3N0YXQgJiYgdGhpcy5jdXJDb250ZXh0KCkudG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG59O1xuXG50eXBlcy5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYl9zdGF0IDogdHlwZXMkMS5iX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLmRvbGxhckJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuYl90bXBsKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHlwZXMuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3doaWxlO1xuICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcyQxLnBfc3RhdCA6IHR5cGVzJDEucF9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5pbmNEZWMudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbn07XG5cbnR5cGVzLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Vsc2UgJiZcbiAgICAgICEocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5iX3N0YXQpKVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX2V4cHIpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9zdGF0KTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEucV90bXBsKVxuICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEucV90bXBsKTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5zdGFyLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcyQxLmZfZXhwcilcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9leHByX2dlbjsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuZG90KSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICB0aGlzLnZhbHVlID09PSBcInlpZWxkXCIgJiYgdGhpcy5pbkdlbmVyYXRvckNvbnRleHQoKSlcbiAgICAgIHsgYWxsb3dlZCA9IHRydWU7IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gYWxsb3dlZDtcbn07XG5cbnZhciBkYXRhID0ge1xuICBcIiRMT05FXCI6IFtcbiAgICBcIkFTQ0lJXCIsXG4gICAgXCJBU0NJSV9IZXhfRGlnaXRcIixcbiAgICBcIkFIZXhcIixcbiAgICBcIkFscGhhYmV0aWNcIixcbiAgICBcIkFscGhhXCIsXG4gICAgXCJBbnlcIixcbiAgICBcIkFzc2lnbmVkXCIsXG4gICAgXCJCaWRpX0NvbnRyb2xcIixcbiAgICBcIkJpZGlfQ1wiLFxuICAgIFwiQmlkaV9NaXJyb3JlZFwiLFxuICAgIFwiQmlkaV9NXCIsXG4gICAgXCJDYXNlX0lnbm9yYWJsZVwiLFxuICAgIFwiQ0lcIixcbiAgICBcIkNhc2VkXCIsXG4gICAgXCJDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZFwiLFxuICAgIFwiQ1dDRlwiLFxuICAgIFwiQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWRcIixcbiAgICBcIkNXQ01cIixcbiAgICBcIkNoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkXCIsXG4gICAgXCJDV0xcIixcbiAgICBcIkNoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWRcIixcbiAgICBcIkNXS0NGXCIsXG4gICAgXCJDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZFwiLFxuICAgIFwiQ1dUXCIsXG4gICAgXCJDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZFwiLFxuICAgIFwiQ1dVXCIsXG4gICAgXCJEYXNoXCIsXG4gICAgXCJEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50XCIsXG4gICAgXCJESVwiLFxuICAgIFwiRGVwcmVjYXRlZFwiLFxuICAgIFwiRGVwXCIsXG4gICAgXCJEaWFjcml0aWNcIixcbiAgICBcIkRpYVwiLFxuICAgIFwiRW1vamlcIixcbiAgICBcIkVtb2ppX0NvbXBvbmVudFwiLFxuICAgIFwiRW1vamlfTW9kaWZpZXJcIixcbiAgICBcIkVtb2ppX01vZGlmaWVyX0Jhc2VcIixcbiAgICBcIkVtb2ppX1ByZXNlbnRhdGlvblwiLFxuICAgIFwiRXh0ZW5kZXJcIixcbiAgICBcIkV4dFwiLFxuICAgIFwiR3JhcGhlbWVfQmFzZVwiLFxuICAgIFwiR3JfQmFzZVwiLFxuICAgIFwiR3JhcGhlbWVfRXh0ZW5kXCIsXG4gICAgXCJHcl9FeHRcIixcbiAgICBcIkhleF9EaWdpdFwiLFxuICAgIFwiSGV4XCIsXG4gICAgXCJJRFNfQmluYXJ5X09wZXJhdG9yXCIsXG4gICAgXCJJRFNCXCIsXG4gICAgXCJJRFNfVHJpbmFyeV9PcGVyYXRvclwiLFxuICAgIFwiSURTVFwiLFxuICAgIFwiSURfQ29udGludWVcIixcbiAgICBcIklEQ1wiLFxuICAgIFwiSURfU3RhcnRcIixcbiAgICBcIklEU1wiLFxuICAgIFwiSWRlb2dyYXBoaWNcIixcbiAgICBcIklkZW9cIixcbiAgICBcIkpvaW5fQ29udHJvbFwiLFxuICAgIFwiSm9pbl9DXCIsXG4gICAgXCJMb2dpY2FsX09yZGVyX0V4Y2VwdGlvblwiLFxuICAgIFwiTE9FXCIsXG4gICAgXCJMb3dlcmNhc2VcIixcbiAgICBcIkxvd2VyXCIsXG4gICAgXCJNYXRoXCIsXG4gICAgXCJOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludFwiLFxuICAgIFwiTkNoYXJcIixcbiAgICBcIlBhdHRlcm5fU3ludGF4XCIsXG4gICAgXCJQYXRfU3luXCIsXG4gICAgXCJQYXR0ZXJuX1doaXRlX1NwYWNlXCIsXG4gICAgXCJQYXRfV1NcIixcbiAgICBcIlF1b3RhdGlvbl9NYXJrXCIsXG4gICAgXCJRTWFya1wiLFxuICAgIFwiUmFkaWNhbFwiLFxuICAgIFwiUmVnaW9uYWxfSW5kaWNhdG9yXCIsXG4gICAgXCJSSVwiLFxuICAgIFwiU2VudGVuY2VfVGVybWluYWxcIixcbiAgICBcIlNUZXJtXCIsXG4gICAgXCJTb2Z0X0RvdHRlZFwiLFxuICAgIFwiU0RcIixcbiAgICBcIlRlcm1pbmFsX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJUZXJtXCIsXG4gICAgXCJVbmlmaWVkX0lkZW9ncmFwaFwiLFxuICAgIFwiVUlkZW9cIixcbiAgICBcIlVwcGVyY2FzZVwiLFxuICAgIFwiVXBwZXJcIixcbiAgICBcIlZhcmlhdGlvbl9TZWxlY3RvclwiLFxuICAgIFwiVlNcIixcbiAgICBcIldoaXRlX1NwYWNlXCIsXG4gICAgXCJzcGFjZVwiLFxuICAgIFwiWElEX0NvbnRpbnVlXCIsXG4gICAgXCJYSURDXCIsXG4gICAgXCJYSURfU3RhcnRcIixcbiAgICBcIlhJRFNcIlxuICBdLFxuICBcIkdlbmVyYWxfQ2F0ZWdvcnlcIjogW1xuICAgIFwiQ2FzZWRfTGV0dGVyXCIsXG4gICAgXCJMQ1wiLFxuICAgIFwiQ2xvc2VfUHVuY3R1YXRpb25cIixcbiAgICBcIlBlXCIsXG4gICAgXCJDb25uZWN0b3JfUHVuY3R1YXRpb25cIixcbiAgICBcIlBjXCIsXG4gICAgXCJDb250cm9sXCIsXG4gICAgXCJDY1wiLFxuICAgIFwiY250cmxcIixcbiAgICBcIkN1cnJlbmN5X1N5bWJvbFwiLFxuICAgIFwiU2NcIixcbiAgICBcIkRhc2hfUHVuY3R1YXRpb25cIixcbiAgICBcIlBkXCIsXG4gICAgXCJEZWNpbWFsX051bWJlclwiLFxuICAgIFwiTmRcIixcbiAgICBcImRpZ2l0XCIsXG4gICAgXCJFbmNsb3NpbmdfTWFya1wiLFxuICAgIFwiTWVcIixcbiAgICBcIkZpbmFsX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJQZlwiLFxuICAgIFwiRm9ybWF0XCIsXG4gICAgXCJDZlwiLFxuICAgIFwiSW5pdGlhbF9QdW5jdHVhdGlvblwiLFxuICAgIFwiUGlcIixcbiAgICBcIkxldHRlclwiLFxuICAgIFwiTFwiLFxuICAgIFwiTGV0dGVyX051bWJlclwiLFxuICAgIFwiTmxcIixcbiAgICBcIkxpbmVfU2VwYXJhdG9yXCIsXG4gICAgXCJabFwiLFxuICAgIFwiTG93ZXJjYXNlX0xldHRlclwiLFxuICAgIFwiTGxcIixcbiAgICBcIk1hcmtcIixcbiAgICBcIk1cIixcbiAgICBcIkNvbWJpbmluZ19NYXJrXCIsXG4gICAgXCJNYXRoX1N5bWJvbFwiLFxuICAgIFwiU21cIixcbiAgICBcIk1vZGlmaWVyX0xldHRlclwiLFxuICAgIFwiTG1cIixcbiAgICBcIk1vZGlmaWVyX1N5bWJvbFwiLFxuICAgIFwiU2tcIixcbiAgICBcIk5vbnNwYWNpbmdfTWFya1wiLFxuICAgIFwiTW5cIixcbiAgICBcIk51bWJlclwiLFxuICAgIFwiTlwiLFxuICAgIFwiT3Blbl9QdW5jdHVhdGlvblwiLFxuICAgIFwiUHNcIixcbiAgICBcIk90aGVyXCIsXG4gICAgXCJDXCIsXG4gICAgXCJPdGhlcl9MZXR0ZXJcIixcbiAgICBcIkxvXCIsXG4gICAgXCJPdGhlcl9OdW1iZXJcIixcbiAgICBcIk5vXCIsXG4gICAgXCJPdGhlcl9QdW5jdHVhdGlvblwiLFxuICAgIFwiUG9cIixcbiAgICBcIk90aGVyX1N5bWJvbFwiLFxuICAgIFwiU29cIixcbiAgICBcIlBhcmFncmFwaF9TZXBhcmF0b3JcIixcbiAgICBcIlpwXCIsXG4gICAgXCJQcml2YXRlX1VzZVwiLFxuICAgIFwiQ29cIixcbiAgICBcIlB1bmN0dWF0aW9uXCIsXG4gICAgXCJQXCIsXG4gICAgXCJwdW5jdFwiLFxuICAgIFwiU2VwYXJhdG9yXCIsXG4gICAgXCJaXCIsXG4gICAgXCJTcGFjZV9TZXBhcmF0b3JcIixcbiAgICBcIlpzXCIsXG4gICAgXCJTcGFjaW5nX01hcmtcIixcbiAgICBcIk1jXCIsXG4gICAgXCJTdXJyb2dhdGVcIixcbiAgICBcIkNzXCIsXG4gICAgXCJTeW1ib2xcIixcbiAgICBcIlNcIixcbiAgICBcIlRpdGxlY2FzZV9MZXR0ZXJcIixcbiAgICBcIkx0XCIsXG4gICAgXCJVbmFzc2lnbmVkXCIsXG4gICAgXCJDblwiLFxuICAgIFwiVXBwZXJjYXNlX0xldHRlclwiLFxuICAgIFwiTHVcIlxuICBdLFxuICBcIlNjcmlwdFwiOiBbXG4gICAgXCJBZGxhbVwiLFxuICAgIFwiQWRsbVwiLFxuICAgIFwiQWhvbVwiLFxuICAgIFwiQW5hdG9saWFuX0hpZXJvZ2x5cGhzXCIsXG4gICAgXCJIbHV3XCIsXG4gICAgXCJBcmFiaWNcIixcbiAgICBcIkFyYWJcIixcbiAgICBcIkFybWVuaWFuXCIsXG4gICAgXCJBcm1uXCIsXG4gICAgXCJBdmVzdGFuXCIsXG4gICAgXCJBdnN0XCIsXG4gICAgXCJCYWxpbmVzZVwiLFxuICAgIFwiQmFsaVwiLFxuICAgIFwiQmFtdW1cIixcbiAgICBcIkJhbXVcIixcbiAgICBcIkJhc3NhX1ZhaFwiLFxuICAgIFwiQmFzc1wiLFxuICAgIFwiQmF0YWtcIixcbiAgICBcIkJhdGtcIixcbiAgICBcIkJlbmdhbGlcIixcbiAgICBcIkJlbmdcIixcbiAgICBcIkJoYWlrc3VraVwiLFxuICAgIFwiQmhrc1wiLFxuICAgIFwiQm9wb21vZm9cIixcbiAgICBcIkJvcG9cIixcbiAgICBcIkJyYWhtaVwiLFxuICAgIFwiQnJhaFwiLFxuICAgIFwiQnJhaWxsZVwiLFxuICAgIFwiQnJhaVwiLFxuICAgIFwiQnVnaW5lc2VcIixcbiAgICBcIkJ1Z2lcIixcbiAgICBcIkJ1aGlkXCIsXG4gICAgXCJCdWhkXCIsXG4gICAgXCJDYW5hZGlhbl9BYm9yaWdpbmFsXCIsXG4gICAgXCJDYW5zXCIsXG4gICAgXCJDYXJpYW5cIixcbiAgICBcIkNhcmlcIixcbiAgICBcIkNhdWNhc2lhbl9BbGJhbmlhblwiLFxuICAgIFwiQWdoYlwiLFxuICAgIFwiQ2hha21hXCIsXG4gICAgXCJDYWttXCIsXG4gICAgXCJDaGFtXCIsXG4gICAgXCJDaGVyb2tlZVwiLFxuICAgIFwiQ2hlclwiLFxuICAgIFwiQ29tbW9uXCIsXG4gICAgXCJaeXl5XCIsXG4gICAgXCJDb3B0aWNcIixcbiAgICBcIkNvcHRcIixcbiAgICBcIlFhYWNcIixcbiAgICBcIkN1bmVpZm9ybVwiLFxuICAgIFwiWHN1eFwiLFxuICAgIFwiQ3lwcmlvdFwiLFxuICAgIFwiQ3BydFwiLFxuICAgIFwiQ3lyaWxsaWNcIixcbiAgICBcIkN5cmxcIixcbiAgICBcIkRlc2VyZXRcIixcbiAgICBcIkRzcnRcIixcbiAgICBcIkRldmFuYWdhcmlcIixcbiAgICBcIkRldmFcIixcbiAgICBcIkR1cGxveWFuXCIsXG4gICAgXCJEdXBsXCIsXG4gICAgXCJFZ3lwdGlhbl9IaWVyb2dseXBoc1wiLFxuICAgIFwiRWd5cFwiLFxuICAgIFwiRWxiYXNhblwiLFxuICAgIFwiRWxiYVwiLFxuICAgIFwiRXRoaW9waWNcIixcbiAgICBcIkV0aGlcIixcbiAgICBcIkdlb3JnaWFuXCIsXG4gICAgXCJHZW9yXCIsXG4gICAgXCJHbGFnb2xpdGljXCIsXG4gICAgXCJHbGFnXCIsXG4gICAgXCJHb3RoaWNcIixcbiAgICBcIkdvdGhcIixcbiAgICBcIkdyYW50aGFcIixcbiAgICBcIkdyYW5cIixcbiAgICBcIkdyZWVrXCIsXG4gICAgXCJHcmVrXCIsXG4gICAgXCJHdWphcmF0aVwiLFxuICAgIFwiR3VqclwiLFxuICAgIFwiR3VybXVraGlcIixcbiAgICBcIkd1cnVcIixcbiAgICBcIkhhblwiLFxuICAgIFwiSGFuaVwiLFxuICAgIFwiSGFuZ3VsXCIsXG4gICAgXCJIYW5nXCIsXG4gICAgXCJIYW51bm9vXCIsXG4gICAgXCJIYW5vXCIsXG4gICAgXCJIYXRyYW5cIixcbiAgICBcIkhhdHJcIixcbiAgICBcIkhlYnJld1wiLFxuICAgIFwiSGViclwiLFxuICAgIFwiSGlyYWdhbmFcIixcbiAgICBcIkhpcmFcIixcbiAgICBcIkltcGVyaWFsX0FyYW1haWNcIixcbiAgICBcIkFybWlcIixcbiAgICBcIkluaGVyaXRlZFwiLFxuICAgIFwiWmluaFwiLFxuICAgIFwiUWFhaVwiLFxuICAgIFwiSW5zY3JpcHRpb25hbF9QYWhsYXZpXCIsXG4gICAgXCJQaGxpXCIsXG4gICAgXCJJbnNjcmlwdGlvbmFsX1BhcnRoaWFuXCIsXG4gICAgXCJQcnRpXCIsXG4gICAgXCJKYXZhbmVzZVwiLFxuICAgIFwiSmF2YVwiLFxuICAgIFwiS2FpdGhpXCIsXG4gICAgXCJLdGhpXCIsXG4gICAgXCJLYW5uYWRhXCIsXG4gICAgXCJLbmRhXCIsXG4gICAgXCJLYXRha2FuYVwiLFxuICAgIFwiS2FuYVwiLFxuICAgIFwiS2F5YWhfTGlcIixcbiAgICBcIkthbGlcIixcbiAgICBcIktoYXJvc2h0aGlcIixcbiAgICBcIktoYXJcIixcbiAgICBcIktobWVyXCIsXG4gICAgXCJLaG1yXCIsXG4gICAgXCJLaG9qa2lcIixcbiAgICBcIktob2pcIixcbiAgICBcIktodWRhd2FkaVwiLFxuICAgIFwiU2luZFwiLFxuICAgIFwiTGFvXCIsXG4gICAgXCJMYW9vXCIsXG4gICAgXCJMYXRpblwiLFxuICAgIFwiTGF0blwiLFxuICAgIFwiTGVwY2hhXCIsXG4gICAgXCJMZXBjXCIsXG4gICAgXCJMaW1idVwiLFxuICAgIFwiTGltYlwiLFxuICAgIFwiTGluZWFyX0FcIixcbiAgICBcIkxpbmFcIixcbiAgICBcIkxpbmVhcl9CXCIsXG4gICAgXCJMaW5iXCIsXG4gICAgXCJMaXN1XCIsXG4gICAgXCJMeWNpYW5cIixcbiAgICBcIkx5Y2lcIixcbiAgICBcIkx5ZGlhblwiLFxuICAgIFwiTHlkaVwiLFxuICAgIFwiTWFoYWphbmlcIixcbiAgICBcIk1haGpcIixcbiAgICBcIk1hbGF5YWxhbVwiLFxuICAgIFwiTWx5bVwiLFxuICAgIFwiTWFuZGFpY1wiLFxuICAgIFwiTWFuZFwiLFxuICAgIFwiTWFuaWNoYWVhblwiLFxuICAgIFwiTWFuaVwiLFxuICAgIFwiTWFyY2hlblwiLFxuICAgIFwiTWFyY1wiLFxuICAgIFwiTWFzYXJhbV9Hb25kaVwiLFxuICAgIFwiR29ubVwiLFxuICAgIFwiTWVldGVpX01heWVrXCIsXG4gICAgXCJNdGVpXCIsXG4gICAgXCJNZW5kZV9LaWtha3VpXCIsXG4gICAgXCJNZW5kXCIsXG4gICAgXCJNZXJvaXRpY19DdXJzaXZlXCIsXG4gICAgXCJNZXJjXCIsXG4gICAgXCJNZXJvaXRpY19IaWVyb2dseXBoc1wiLFxuICAgIFwiTWVyb1wiLFxuICAgIFwiTWlhb1wiLFxuICAgIFwiUGxyZFwiLFxuICAgIFwiTW9kaVwiLFxuICAgIFwiTW9uZ29saWFuXCIsXG4gICAgXCJNb25nXCIsXG4gICAgXCJNcm9cIixcbiAgICBcIk1yb29cIixcbiAgICBcIk11bHRhbmlcIixcbiAgICBcIk11bHRcIixcbiAgICBcIk15YW5tYXJcIixcbiAgICBcIk15bXJcIixcbiAgICBcIk5hYmF0YWVhblwiLFxuICAgIFwiTmJhdFwiLFxuICAgIFwiTmV3X1RhaV9MdWVcIixcbiAgICBcIlRhbHVcIixcbiAgICBcIk5ld2FcIixcbiAgICBcIk5rb1wiLFxuICAgIFwiTmtvb1wiLFxuICAgIFwiTnVzaHVcIixcbiAgICBcIk5zaHVcIixcbiAgICBcIk9naGFtXCIsXG4gICAgXCJPZ2FtXCIsXG4gICAgXCJPbF9DaGlraVwiLFxuICAgIFwiT2xja1wiLFxuICAgIFwiT2xkX0h1bmdhcmlhblwiLFxuICAgIFwiSHVuZ1wiLFxuICAgIFwiT2xkX0l0YWxpY1wiLFxuICAgIFwiSXRhbFwiLFxuICAgIFwiT2xkX05vcnRoX0FyYWJpYW5cIixcbiAgICBcIk5hcmJcIixcbiAgICBcIk9sZF9QZXJtaWNcIixcbiAgICBcIlBlcm1cIixcbiAgICBcIk9sZF9QZXJzaWFuXCIsXG4gICAgXCJYcGVvXCIsXG4gICAgXCJPbGRfU291dGhfQXJhYmlhblwiLFxuICAgIFwiU2FyYlwiLFxuICAgIFwiT2xkX1R1cmtpY1wiLFxuICAgIFwiT3JraFwiLFxuICAgIFwiT3JpeWFcIixcbiAgICBcIk9yeWFcIixcbiAgICBcIk9zYWdlXCIsXG4gICAgXCJPc2dlXCIsXG4gICAgXCJPc21hbnlhXCIsXG4gICAgXCJPc21hXCIsXG4gICAgXCJQYWhhd2hfSG1vbmdcIixcbiAgICBcIkhtbmdcIixcbiAgICBcIlBhbG15cmVuZVwiLFxuICAgIFwiUGFsbVwiLFxuICAgIFwiUGF1X0Npbl9IYXVcIixcbiAgICBcIlBhdWNcIixcbiAgICBcIlBoYWdzX1BhXCIsXG4gICAgXCJQaGFnXCIsXG4gICAgXCJQaG9lbmljaWFuXCIsXG4gICAgXCJQaG54XCIsXG4gICAgXCJQc2FsdGVyX1BhaGxhdmlcIixcbiAgICBcIlBobHBcIixcbiAgICBcIlJlamFuZ1wiLFxuICAgIFwiUmpuZ1wiLFxuICAgIFwiUnVuaWNcIixcbiAgICBcIlJ1bnJcIixcbiAgICBcIlNhbWFyaXRhblwiLFxuICAgIFwiU2FtclwiLFxuICAgIFwiU2F1cmFzaHRyYVwiLFxuICAgIFwiU2F1clwiLFxuICAgIFwiU2hhcmFkYVwiLFxuICAgIFwiU2hyZFwiLFxuICAgIFwiU2hhdmlhblwiLFxuICAgIFwiU2hhd1wiLFxuICAgIFwiU2lkZGhhbVwiLFxuICAgIFwiU2lkZFwiLFxuICAgIFwiU2lnbldyaXRpbmdcIixcbiAgICBcIlNnbndcIixcbiAgICBcIlNpbmhhbGFcIixcbiAgICBcIlNpbmhcIixcbiAgICBcIlNvcmFfU29tcGVuZ1wiLFxuICAgIFwiU29yYVwiLFxuICAgIFwiU295b21ib1wiLFxuICAgIFwiU295b1wiLFxuICAgIFwiU3VuZGFuZXNlXCIsXG4gICAgXCJTdW5kXCIsXG4gICAgXCJTeWxvdGlfTmFncmlcIixcbiAgICBcIlN5bG9cIixcbiAgICBcIlN5cmlhY1wiLFxuICAgIFwiU3lyY1wiLFxuICAgIFwiVGFnYWxvZ1wiLFxuICAgIFwiVGdsZ1wiLFxuICAgIFwiVGFnYmFud2FcIixcbiAgICBcIlRhZ2JcIixcbiAgICBcIlRhaV9MZVwiLFxuICAgIFwiVGFsZVwiLFxuICAgIFwiVGFpX1RoYW1cIixcbiAgICBcIkxhbmFcIixcbiAgICBcIlRhaV9WaWV0XCIsXG4gICAgXCJUYXZ0XCIsXG4gICAgXCJUYWtyaVwiLFxuICAgIFwiVGFrclwiLFxuICAgIFwiVGFtaWxcIixcbiAgICBcIlRhbWxcIixcbiAgICBcIlRhbmd1dFwiLFxuICAgIFwiVGFuZ1wiLFxuICAgIFwiVGVsdWd1XCIsXG4gICAgXCJUZWx1XCIsXG4gICAgXCJUaGFhbmFcIixcbiAgICBcIlRoYWFcIixcbiAgICBcIlRoYWlcIixcbiAgICBcIlRpYmV0YW5cIixcbiAgICBcIlRpYnRcIixcbiAgICBcIlRpZmluYWdoXCIsXG4gICAgXCJUZm5nXCIsXG4gICAgXCJUaXJodXRhXCIsXG4gICAgXCJUaXJoXCIsXG4gICAgXCJVZ2FyaXRpY1wiLFxuICAgIFwiVWdhclwiLFxuICAgIFwiVmFpXCIsXG4gICAgXCJWYWlpXCIsXG4gICAgXCJXYXJhbmdfQ2l0aVwiLFxuICAgIFwiV2FyYVwiLFxuICAgIFwiWWlcIixcbiAgICBcIllpaWlcIixcbiAgICBcIlphbmFiYXphcl9TcXVhcmVcIixcbiAgICBcIlphbmJcIlxuICBdXG59O1xuQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YS4kTE9ORSwgZGF0YS5HZW5lcmFsX0NhdGVnb3J5KTtcbmRhdGEuZ2MgPSBkYXRhLkdlbmVyYWxfQ2F0ZWdvcnk7XG5kYXRhLnNjID0gZGF0YS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGRhdGEuc2N4ID0gZGF0YS5TY3JpcHQ7XG5cbnZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxudmFyIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZShwYXJzZXIpIHtcbiAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIHRoaXMudmFsaWRGbGFncyA9IFwiZ2ltXCIgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IFwidXlcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgPyBcInNcIiA6IFwiXCIpO1xuICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gIHRoaXMuZmxhZ3MgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gMDtcbiAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gIHRoaXMuc3dpdGNoTiA9IGZhbHNlO1xuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMubGFzdEludFZhbHVlID0gMDtcbiAgdGhpcy5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB0aGlzLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICB0aGlzLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gIHRoaXMubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gIHRoaXMuZ3JvdXBOYW1lcyA9IFtdO1xuICB0aGlzLmJhY2tSZWZlcmVuY2VOYW1lcyA9IFtdO1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0IChzdGFydCwgcGF0dGVybiwgZmxhZ3MpIHtcbiAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gIHRoaXMuc3RhcnQgPSBzdGFydCB8IDA7XG4gIHRoaXMuc291cmNlID0gcGF0dGVybiArIFwiXCI7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHRoaXMuc3dpdGNoTiA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5O1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gIHRoaXMucGFyc2VyLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC9cIiArICh0aGlzLnNvdXJjZSkgKyBcIi86IFwiICsgbWVzc2FnZSkpO1xufTtcblxuLy8gSWYgdSBmbGFnIGlzIGdpdmVuLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGluZGV4IChpdCBjb21iaW5lcyBhIHN1cnJvZ2F0ZSBwYWlyKS5cbi8vIE90aGVyd2lzZSwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGluZGV4IChjYW4gYmUgYSBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIpLlxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpKSB7XG4gIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gIHZhciBsID0gcy5sZW5ndGg7XG4gIGlmIChpID49IGwpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgaWYgKCF0aGlzLnN3aXRjaFUgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuIChjIDw8IDEwKSArIHMuY2hhckNvZGVBdChpICsgMSkgLSAweDM1RkRDMDBcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubmV4dEluZGV4ID0gZnVuY3Rpb24gbmV4dEluZGV4IChpKSB7XG4gIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gIHZhciBsID0gcy5sZW5ndGg7XG4gIGlmIChpID49IGwpIHtcbiAgICByZXR1cm4gbFxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgcmV0dXJuIGkgKyAxXG4gIH1cbiAgcmV0dXJuIGkgKyAyXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MpXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoKSB7XG4gIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zKSlcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKCkge1xuICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zKTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCkge1xuICBpZiAodGhpcy5jdXJyZW50KCkgPT09IGNoKSB7XG4gICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nJDEoY2gpIHtcbiAgaWYgKGNoIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCkgfVxuICBjaCAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY2ggPj4gMTApICsgMHhEODAwLCAoY2ggJiAweDAzRkYpICsgMHhEQzAwKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBmbGFncyBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQ5LnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdmFsaWRGbGFncyA9IHN0YXRlLnZhbGlkRmxhZ3M7XG4gIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmxhZyA9IGZsYWdzLmNoYXJBdChpKTtcbiAgICBpZiAodmFsaWRGbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgdGhpcyQxLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICB0aGlzJDEucmFpc2Uoc3RhdGUuc3RhcnQsIFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgcGF0dGVybiBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQ5LnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIFRoZSBnb2FsIHN5bWJvbCBmb3IgdGhlIHBhcnNlIGlzIHxQYXR0ZXJuW35VLCB+Tl18LiBJZiB0aGUgcmVzdWx0IG9mXG4gIC8vIHBhcnNpbmcgY29udGFpbnMgYSB8R3JvdXBOYW1lfCwgcmVwYXJzZSB3aXRoIHRoZSBnb2FsIHN5bWJvbFxuICAvLyB8UGF0dGVyblt+VSwgK05dfCBhbmQgdXNlIHRoaXMgcmVzdWx0IGluc3RlYWQuIFRocm93IGEgKlN5bnRheEVycm9yKlxuICAvLyBleGNlcHRpb24gaWYgX1BfIGRpZCBub3QgY29uZm9ybSB0byB0aGUgZ3JhbW1hciwgaWYgYW55IGVsZW1lbnRzIG9mIF9QX1xuICAvLyB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoZSBwYXJzZSwgb3IgaWYgYW55IEVhcmx5IEVycm9yIGNvbmRpdGlvbnMgZXhpc3QuXG4gIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICBzdGF0ZS5zd2l0Y2hOID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVyblxucHAkOS5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLnBvcyA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPSAwO1xuICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoID0gMDtcblxuICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZXMgYXMgVjguXG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBbICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID4gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURpc2p1bmN0aW9uXG5wcCQ5LnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgdGhpcyQxLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIH1cblxuICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUFsdGVybmF0aXZlXG5wcCQ5LnJlZ2V4cF9hbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zb3VyY2UubGVuZ3RoICYmIHRoaXMucmVnZXhwX2VhdFRlcm0oc3RhdGUpKVxuICAgIHsgIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1UZXJtXG5wcCQ5LnJlZ2V4cF9lYXRUZXJtID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAvLyBIYW5kbGUgYFF1YW50aWZpYWJsZUFzc2VydGlvbiBRdWFudGlmaWVyYCBhbHRlcm5hdGl2ZS5cbiAgICAvLyBgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlYCBpcyB0cnVlIGlmIHRoZSBsYXN0IGVhdGVuIEFzc2VydGlvblxuICAgIC8vIGlzIGEgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uLlxuICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXNzZXJ0aW9uXG5wcCQ5LnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gIC8vIF4sICRcbiAgaWYgKHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pIHx8IHN0YXRlLmVhdCgweDI0IC8qICQgKi8pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFxcYiBcXEJcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg0MiAvKiBCICovKSB8fCBzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICAvLyBMb29rYWhlYWQgLyBMb29rYmVoaW5kXG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSAmJiBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgLyogPCAqLyk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSB8fCBzdGF0ZS5lYXQoMHgyMSAvKiAhICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9ICFsb29rYmVoaW5kO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyXG5wcCQ5LnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoc3RhdGUsIG5vRXJyb3IpKSB7XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLyk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJQcmVmaXhcbnBwJDkucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJBIC8qICogKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4MkIgLyogKyAqLykgfHxcbiAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIG5vRXJyb3IpXG4gIClcbn07XG5wcCQ5LnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICBtaW4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgLyogLCAqLykgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgIC8vIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtdGVybVxuICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW5jb21wbGV0ZSBxdWFudGlmaWVyXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUF0b21cbnBwJDkucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gIClcbn07XG5wcCQ5LnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDkucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSAmJiBzdGF0ZS5lYXQoMHgzQSAvKiA6ICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOS5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiAvKiA/ICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRBdG9tXG5wcCQ5LnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSW52YWxpZEJyYWNlZFF1YW50aWZpZXJcbnBwJDkucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxucHAkOS5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLyB8fFxuICAgIGNoID09PSAweDJFIC8qIC4gKi8gfHxcbiAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgY2ggPj0gMHg1QiAvKiBbICovICYmIGNoIDw9IDB4NUUgLyogXiAqLyB8fFxuICAgIGNoID49IDB4N0IgLyogeyAqLyAmJiBjaCA8PSAweDdEIC8qIH0gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuQ2hhcmFjdGVyXG4vLyBCdXQgZWF0IGVhZ2VyLlxucHAkOS5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpICE9PSAtMSAmJiAhaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG5wcCQ5LnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChcbiAgICBjaCAhPT0gLTEgJiZcbiAgICBjaCAhPT0gMHgyNCAvKiAkICovICYmXG4gICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgIGNoICE9PSAweDJFIC8qIC4gKi8gJiZcbiAgICBjaCAhPT0gMHgzRiAvKiA/ICovICYmXG4gICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgIGNoICE9PSAweDVFIC8qIF4gKi8gJiZcbiAgICBjaCAhPT0gMHg3QyAvKiB8ICovXG4gICkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gR3JvdXBTcGVjaWZpZXJbVV0gOjpcbi8vICAgW2VtcHR5XVxuLy8gICBgP2AgR3JvdXBOYW1lWz9VXVxucHAkOS5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gIH1cbn07XG5cbi8vIEdyb3VwTmFtZVtVXSA6OlxuLy8gICBgPGAgUmVnRXhwSWRlbnRpZmllck5hbWVbP1VdIGA+YFxuLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG5wcCQ5LnJlZ2V4cF9lYXRHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAoc3RhdGUuZWF0KDB4M0MgLyogPCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNFIC8qID4gKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gUmVnRXhwSWRlbnRpZmllck5hbWVbVV0gOjpcbi8vICAgUmVnRXhwSWRlbnRpZmllclN0YXJ0Wz9VXVxuLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZVs/VV0gUmVnRXhwSWRlbnRpZmllclBhcnRbP1VdXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDkucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmckMShzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyQxKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyU3RhcnRbVV0gOjpcbi8vICAgVW5pY29kZUlEU3RhcnRcbi8vICAgYCRgXG4vLyAgIGBfYFxuLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV1cbnBwJDkucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBzdGF0ZS5hZHZhbmNlKCk7XG5cbiAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBSZWdFeHBJZGVudGlmaWVyUGFydFtVXSA6OlxuLy8gICBVbmljb2RlSURDb250aW51ZVxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWz9VXVxuLy8gICA8WldOSj5cbi8vICAgPFpXSj5cbnBwJDkucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIHN0YXRlLmFkdmFuY2UoKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovIHx8IGNoID09PSAweDIwMEMgLyogPFpXTko+ICovIHx8IGNoID09PSAweDIwMEQgLyogPFpXSj4gKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbnBwJDkucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoXG4gICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOS5yZWdleHBfZWF0QmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOS5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg2QiAvKiBrICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DaGFyYWN0ZXJFc2NhcGVcbnBwJDkucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q29udHJvbEVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gIClcbn07XG5wcCQ5LnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ5LnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbEVzY2FwZVxucHAkOS5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID09PSAweDc0IC8qIHQgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyAvKiBcXHQgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IC8qIFxcbiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3NiAvKiB2ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDY2IC8qIGYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyAvKiBcXGYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IC8qIFxcciAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbExldHRlclxucHAkOS5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDdBIC8qIHogKi8pXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlXG5wcCQ5LnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKFxuICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxucHAkOS5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkY7IC8qIC8gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NjMgLyogYyAqLyAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgLyogayAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxucHAkOS5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICBkbyB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc0VzY2FwZVxucHAkOS5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgaWYgKGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoXG4gICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgKGNoID09PSAweDUwIC8qIFAgKi8gfHwgY2ggPT09IDB4NzAgLyogcCAqLylcbiAgKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24oc3RhdGUpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4NjQgLyogZCAqLyB8fFxuICAgIGNoID09PSAweDQ0IC8qIEQgKi8gfHxcbiAgICBjaCA9PT0gMHg3MyAvKiBzICovIHx8XG4gICAgY2ggPT09IDB4NTMgLyogUyAqLyB8fFxuICAgIGNoID09PSAweDc3IC8qIHcgKi8gfHxcbiAgICBjaCA9PT0gMHg1NyAvKiBXICovXG4gIClcbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4vLyAgIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxucHAkOS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSkge1xuICAgIHZhciBuYW1lID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlKHN0YXRlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KG5hbWUpIHx8IGRhdGFbbmFtZV0uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gIH1cbn07XG5wcCQ5LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gIGlmIChkYXRhLiRMT05FLmluZGV4T2YobmFtZU9yVmFsdWUpID09PSAtMSkge1xuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICB9XG59O1xuXG4vLyBVbmljb2RlUHJvcGVydHlOYW1lIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXJzXG5wcCQ5LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmckMShjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5mdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbnBwJDkucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaClcbn1cblxuLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkOS5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NcbnBwJDkucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgc3RhdGUuZWF0KDB4NUUgLyogXiAqLyk7XG4gICAgdGhpcy5yZWdleHBfY2xhc3NSYW5nZXMoc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBbICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gVW5yZWFjaGFibGUgc2luY2UgaXQgdGhyZXcgXCJ1bnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIgZXJyb3IgYmVmb3JlLlxuICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzUmFuZ2VzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG5wcCQ5LnJlZ2V4cF9jbGFzc1JhbmdlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pICYmIHRoaXMkMS5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tTm9EYXNoXG5wcCQ5LnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDVEIC8qIFsgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG5wcCQ5LnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgLyogLSAqL1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzQ29udHJvbExldHRlclxucHAkOS5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxucHAkOS5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg3OCAvKiB4ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgMikpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxEaWdpdHNcbnBwJDkucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHdoaWxlIChpc0RlY2ltYWxEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRzXG5wcCQ5LnJlZ2V4cF9lYXRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcbmZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgcmV0dXJuIChcbiAgICAoY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykgfHxcbiAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykgfHxcbiAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLylcbiAgKVxufVxuZnVuY3Rpb24gaGV4VG9JbnQoY2gpIHtcbiAgaWYgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHtcbiAgICByZXR1cm4gMTAgKyAoY2ggLSAweDQxIC8qIEEgKi8pXG4gIH1cbiAgaWYgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pIHtcbiAgICByZXR1cm4gMTAgKyAoY2ggLSAweDYxIC8qIGEgKi8pXG4gIH1cbiAgcmV0dXJuIGNoIC0gMHgzMCAvKiAwICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1MZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlXG4vLyBBbGxvd3Mgb25seSAwLTM3NyhvY3RhbCkgaS5lLiAwLTI1NShkZWNpbWFsKS5cbnBwJDkucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjIgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDY0ICsgbjIgKiA4ICsgc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtT2N0YWxEaWdpdFxucHAkOS5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IC8qIDAgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM3IC8qIDcgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4NERpZ2l0c1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRcbi8vIEFuZCBIZXhEaWdpdCBIZXhEaWdpdCBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxucHAkOS5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSwgbGVuZ3RoKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbi8vIHNpbXBseSBleGlzdCBhcyBwcm9wZXJ0aWVzIG9uIHRoZSBwYXJzZXIgb2JqZWN0LiBUaGlzIGlzIG9ubHlcbi8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG52YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gIHRoaXMudHlwZSA9IHAudHlwZTtcbiAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICB0aGlzLmVuZCA9IHAuZW5kO1xuICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICBpZiAocC5vcHRpb25zLnJhbmdlcylcbiAgICB7IHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdOyB9XG59O1xuXG4vLyAjIyBUb2tlbml6ZXJcblxudmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbnBwJDgubmV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbn07XG5cbnBwJDguZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiBuZXcgVG9rZW4odGhpcylcbn07XG5cbi8vIElmIHdlJ3JlIGluIGFuIEVTNiBlbnZpcm9ubWVudCwgbWFrZSBwYXJzZXJzIGl0ZXJhYmxlXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgeyBwcCQ4W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMS5nZXRUb2tlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzLmVvZixcbiAgICAgICAgICB2YWx1ZTogdG9rZW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgfVxuXG4vLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4vLyBwZWRhbnRpYyB0ZXN0cyAoYFwidXNlIHN0cmljdFwiOyAwMTA7YCBzaG91bGQgZmFpbCkuXG5cbnBwJDguY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXVxufTtcblxuLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4vLyBwcm9wZXJ0aWVzLlxuXG5wcCQ4Lm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICBpZiAoIWN1ckNvbnRleHQgfHwgIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgeyB0aGlzLnNraXBTcGFjZSgpOyB9XG5cbiAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lb2YpIH1cblxuICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG59O1xuXG5wcCQ4LnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gIC8vIGlkZW50aWZpZXJzLCBzbyAnXFwnIGFsc28gZGlzcGF0Y2hlcyB0byB0aGF0LlxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pXG4gICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db2RlKGNvZGUpXG59O1xuXG5wcCQ4LmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKGNvZGUgPD0gMHhkN2ZmIHx8IGNvZGUgPj0gMHhlMDAwKSB7IHJldHVybiBjb2RlIH1cbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbn07XG5cbnBwJDguc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydDtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyh0aGlzLmlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0aGlzLnBvcykge1xuICAgICAgKyt0aGlzJDEuY3VyTGluZTtcbiAgICAgIHRoaXMkMS5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxucHAkOC5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbihzdGFydFNraXApIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZShjaCkpIHtcbiAgICBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcyQxLnBvcyk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4vLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG5wcCQ4LnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBsb29wOiB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAodGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICB9XG4gICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgICBpZiAodGhpcyQxLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdGhpcyQxLmN1ckxpbmU7XG4gICAgICAgIHRoaXMkMS5saW5lU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgIHN3aXRjaCAodGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyArIDEpKSB7XG4gICAgICBjYXNlIDQyOiAvLyAnKidcbiAgICAgICAgdGhpcyQxLnNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHRoaXMkMS5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPiA4ICYmIGNoIDwgMTQgfHwgY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbi8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbi8vIHRoZSB0b2tlbiwgc28gdGhhdCB0aGUgbmV4dCBvbmUncyBgc3RhcnRgIHdpbGwgcG9pbnQgYXQgdGhlXG4vLyByaWdodCBwb3NpdGlvbi5cblxucHAkOC5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbn07XG5cbi8vICMjIyBUb2tlbiByZWFkaW5nXG5cbi8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4vLyB0aGFuIGNoYXJhY3RlcnMsIGFuZCBiZWNhdXNlIG9wZXJhdG9yIHBhcnNpbmcgaGFzIGJlZW4gaW5saW5lZFxuLy8gaW50byBpdC5cbi8vXG4vLyBBbGwgaW4gdGhlIG5hbWUgb2Ygc3BlZWQuXG4vL1xucHAkOC5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHsgcmV0dXJuIHRoaXMucmVhZE51bWJlcih0cnVlKSB9XG4gIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IC8vIDQ2ID0gZG90ICcuJ1xuICAgIHRoaXMucG9zICs9IDM7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZWxsaXBzaXMpXG4gIH0gZWxzZSB7XG4gICAgKyt0aGlzLnBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb3QpXG4gIH1cbn07XG5cbnBwJDgucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IC8vICcvJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAodGhpcy5leHByQWxsb3dlZCkgeyArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCkgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnNsYXNoLCAxKVxufTtcblxucHAkOC5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnJSonXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcblxuICAvLyBleHBvbmVudGlhdGlvbiBvcGVyYXRvciAqKiBhbmQgKio9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICsrc2l6ZTtcbiAgICB0b2tlbnR5cGUgPSB0eXBlcy5zdGFyc3RhcjtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0b2tlbnR5cGUsIHNpemUpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5sb2dpY2FsT1IgOiB0eXBlcy5sb2dpY2FsQU5ELCAyKSB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSlcbn07XG5cbnBwJDgucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IC8vICdeJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJystJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCA9PT0gMCB8fCBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5wb3MpKSkpIHtcbiAgICAgIC8vIEEgYC0tPmAgbGluZSBjb21tZW50XG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wbHVzTWluLCAxKVxufTtcblxucHAkOC5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc8PidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgc2l6ZSkgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXRTaGlmdCwgc2l6ZSlcbiAgfVxuICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCBzaXplKVxufTtcblxucHAkOC5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJz0hJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKSB9XG4gIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyAvLyAnPT4nXG4gICAgdGhpcy5wb3MgKz0gMjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hcnJvdylcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKVxufTtcblxucHAkOC5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gIGNhc2UgNDY6IC8vICcuJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5MKVxuICBjYXNlIDQxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlblIpXG4gIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnNlbWkpXG4gIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbW1hKVxuICBjYXNlIDkxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0TClcbiAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldFIpXG4gIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZUwpXG4gIGNhc2UgMTI1OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpXG4gIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbG9uKVxuICBjYXNlIDYzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5xdWVzdGlvbilcblxuICBjYXNlIDk2OiAvLyAnYCdcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyBicmVhayB9XG4gICAgKyt0aGlzLnBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG5cbiAgY2FzZSA0ODogLy8gJzAnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigxNikgfSAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIH0gLy8gJzBiJywgJzBCJyAtIGJpbmFyeSBudW1iZXJcbiAgICB9XG5cbiAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gIC8vIG51bWJlciwgb3IgZmxvYXQuXG4gIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgY2FzZSAzNDogY2FzZSAzOTogLy8gJ1wiJywgXCInXCJcbiAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgLy8gT3BlcmF0b3JzIGFyZSBwYXJzZWQgaW5saW5lIGluIHRpbnkgc3RhdGUgbWFjaGluZXMuICc9JyAoNjEpIGlzXG4gIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gIC8vIG9mIHRoZSB0eXBlIGdpdmVuIGJ5IGl0cyBmaXJzdCBhcmd1bWVudC5cblxuICBjYXNlIDQ3OiAvLyAnLydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gIGNhc2UgMzc6IGNhc2UgNDI6IC8vICclKidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwKGNvZGUpXG5cbiAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICBjYXNlIDk0OiAvLyAnXidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fY2FyZXQoKVxuXG4gIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSlcblxuICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpXG5cbiAgY2FzZSA2MTogY2FzZSAzMzogLy8gJz0hJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpXG5cbiAgY2FzZSAxMjY6IC8vICd+J1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnByZWZpeCwgMSlcbiAgfVxuXG4gIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcCQ4LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxufTtcblxucHAkOC5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgeyB0aGlzJDEucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQXQodGhpcyQxLnBvcyk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KGNoKSkgeyB0aGlzJDEucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMkMS5wb3M7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHZhciBmbGFnc1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gIC8vIFZhbGlkYXRlIHBhdHRlcm5cbiAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3Moc3RhdGUpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgLy8gQ3JlYXRlIExpdGVyYWwjdmFsdWUgcHJvcGVydHkgdmFsdWUuXG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEVTVHJlZSByZXF1aXJlcyBudWxsIGlmIGl0IGZhaWxlZCB0byBpbnN0YW50aWF0ZSBSZWdFeHAgb2JqZWN0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvYTI3MDAzYWRmNGZkN2JmYWQ0NGRlOWNlZjM3MmEyZWFjZDUyN2IxYy9lczUubWQjcmVnZXhwbGl0ZXJhbFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbi8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4vLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxucHAkOC5yZWFkSW50ID0gZnVuY3Rpb24ocmFkaXgsIGxlbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpLCB2YWwgPSAodm9pZCAwKTtcbiAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICArK3RoaXMkMS5wb3M7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG4gIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSB7IHJldHVybiBudWxsIH1cblxuICByZXR1cm4gdG90YWxcbn07XG5cbnBwJDgucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgdmFyIHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbnBwJDgucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICBpZiAob2N0YWwgJiYgL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSkgeyBvY3RhbCA9IGZhbHNlOyB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICB2YXIgdmFsID0gb2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxucHAkOC5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgaWYgKGNoID09PSAxMjMpIHsgLy8gJ3snXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gIH1cbiAgcmV0dXJuIGNvZGVcbn07XG5cbmZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpIHtcbiAgLy8gVVRGLTE2IERlY29kaW5nXG4gIGlmIChjb2RlIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSB9XG4gIGNvZGUgLT0gMHgxMDAwMDtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxufVxuXG5wcCQ4LnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9ICsrdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcyQxLnBvcyA+PSB0aGlzJDEuaW5wdXQubGVuZ3RoKSB7IHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpO1xuICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgIG91dCArPSB0aGlzJDEucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoLCB0aGlzJDEub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMCkpIHsgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgfVxuICB9XG4gIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dClcbn07XG5cbi8vIFJlYWRzIHRlbXBsYXRlIHN0cmluZyB0b2tlbnMuXG5cbnZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG5wcCQ4LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICB0cnkge1xuICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xufTtcblxucHAkOC5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gIH1cbn07XG5cbnBwJDgucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpO1xuICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgaWYgKHRoaXMkMS5wb3MgPT09IHRoaXMkMS5zdGFydCAmJiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMkMS50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICB0aGlzJDEucG9zICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMkMS5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgICAgIHJldHVybiB0aGlzJDEuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpO1xuICAgICAgcmV0dXJuIHRoaXMkMS5maW5pc2hUb2tlbih0eXBlcy50ZW1wbGF0ZSwgb3V0KVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcyQxLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKSA9PT0gMTApIHsgKyt0aGlzJDEucG9zOyB9XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzJDEub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzJDEuY3VyTGluZTtcbiAgICAgICAgdGhpcyQxLmxpbmVTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgICB9XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzJDEucG9zO1xuICAgIH1cbiAgfVxufTtcblxuLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xucHAkOC5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICBzd2l0Y2ggKHRoaXMkMS5pbnB1dFt0aGlzJDEucG9zXSkge1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIGlmICh0aGlzJDEuaW5wdXRbdGhpcyQxLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgXCJgXCI6XG4gICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR5cGVzLmludmFsaWRUZW1wbGF0ZSwgdGhpcyQxLmlucHV0LnNsaWNlKHRoaXMkMS5zdGFydCwgdGhpcyQxLnBvcykpXG5cbiAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9XG4gIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbnBwJDgucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHN3aXRjaCAoY2gpIHtcbiAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgLy8gJ3InIC0+ICdcXHInXG4gIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyh0aGlzLnJlYWRDb2RlUG9pbnQoKSkgLy8gJ3UnXG4gIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiAvLyAndCcgLT4gJ1xcdCdcbiAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gIGNhc2UgMTE4OiByZXR1cm4gXCJcXHUwMDBiXCIgLy8gJ3YnIC0+ICdcXHUwMDBiJ1xuICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCIgLy8gJ2YnIC0+ICdcXGYnXG4gIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gIGNhc2UgMTA6IC8vICcgXFxuJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgcmV0dXJuIFwiXCJcbiAgZGVmYXVsdDpcbiAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgY2ggPT09IDU2IHx8IGNoID09PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgfVxuICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAvLyBVbmljb2RlIG5ldyBsaW5lIGNoYXJhY3RlcnMgYWZ0ZXIgXFwgZ2V0IHJlbW92ZWQgZnJvbSBvdXRwdXQgaW4gYm90aFxuICAgICAgLy8gdGVtcGxhdGUgbGl0ZXJhbHMgYW5kIHN0cmluZ3NcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuICB9XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG5wcCQ4LnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gIHJldHVybiBuXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuY29udGFpbnNFc2NgXG4vLyB0byB3aGV0aGVyIHRoZSB3b3JkIGNvbnRhaW5lZCBhICdcXHUnIGVzY2FwZS5cbi8vXG4vLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4vLyBhcyBhIG1pY3JvLW9wdGltaXphdGlvbi5cblxucHAkOC5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcyQxLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgIHRoaXMkMS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgLy8gXCJcXFwiXG4gICAgICB0aGlzJDEuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgd29yZCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcyQxLnBvcykgIT09IDExNykgLy8gXCJ1XCJcbiAgICAgICAgeyB0aGlzJDEuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMkMS5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgdmFyIGVzYyA9IHRoaXMkMS5yZWFkQ29kZVBvaW50KCk7XG4gICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICB7IHRoaXMkMS5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyhlc2MpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4vLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxucHAkOC5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIFwiICsgd29yZCk7IH1cbiAgICB0eXBlID0ga2V5d29yZHMkMVt3b3JkXTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxufTtcblxuLy8gQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cbi8vXG4vLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlLCBJbmd2YXIgU3RlcGFueWFuLCBhbmRcbi8vIHZhcmlvdXMgY29udHJpYnV0b3JzIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4uZ2l0XG4vL1xuLy8gUGxlYXNlIHVzZSB0aGUgW2dpdGh1YiBidWcgdHJhY2tlcl1bZ2hidF0gdG8gcmVwb3J0IGlzc3Vlcy5cbi8vXG4vLyBbZ2hidF06IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlc1xuLy9cbi8vIFt3YWxrXTogdXRpbC93YWxrLmpzXG5cbnZhciB2ZXJzaW9uID0gXCI2LjAuNlwiO1xuXG4vLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbi8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuLy8gQVBJXVthcGldLlxuLy9cbi8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4vLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4vLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxufVxuXG4vLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKVxufVxuXG5leHBvcnQgeyB2ZXJzaW9uLCBwYXJzZSwgcGFyc2VFeHByZXNzaW9uQXQsIHRva2VuaXplciwgUGFyc2VyLCBkZWZhdWx0T3B0aW9ucywgUG9zaXRpb24sIFNvdXJjZUxvY2F0aW9uLCBnZXRMaW5lSW5mbywgTm9kZSwgVG9rZW5UeXBlLCB0eXBlcyBhcyB0b2tUeXBlcywga2V5d29yZHMkMSBhcyBrZXl3b3JkVHlwZXMsIFRva0NvbnRleHQsIHR5cGVzJDEgYXMgdG9rQ29udGV4dHMsIGlzSWRlbnRpZmllckNoYXIsIGlzSWRlbnRpZmllclN0YXJ0LCBUb2tlbiwgaXNOZXdMaW5lLCBsaW5lQnJlYWssIGxpbmVCcmVha0csIG5vbkFTQ0lJd2hpdGVzcGFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNvcm4ubWpzLm1hcFxuIiwiLyoqXG4gKiBSZXR1cm5zIGEgY3VycmllZCBmdW5jdGlvbiB3aXRoIGFyaXR5IDFcbiAqIEBmdW5jdGlvbiBjdXJyeTFcbiAqIEBwcml2YXRlXG4gKiBAc2luY2UgdjEuMC4yXG4gKiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGN1cnJ5MSAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWQgKGEpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgPyB0aGlzXG4gICAgICA6IGZuKGEpXG4gIH1cbn1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGJvdGggcHJlZGljYXRlcyBhcmUgdHJ1ZVxuICpcbiAqIEBmdW5jdGlvbiBhbmRcbiAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgYm90aCBwcmVkaWNhdGVzIGFyZSB0cnVlXG4gKiBAc2luY2UgdjEuMC4yXG4gKiBAc2lnICh4LCB5KSAtPiBib29sZWFuXG4gKiBAcGFyYW0geyp9IHggLSBBIHByZWRpY2F0ZVxuICogQHBhcmFtIHsqfSB5IC0gQSBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSdcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gYW5kICh4LCB5KSB7XG4gIHJldHVybiB4ICYmIHlcbn0pXG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gYXJyYXlDb25jYXRcbiAqIEBwYXJhbSBhMVxuICogQHBhcmFtIGEyXG4gKiBAcmV0dXJucyB7VFtdfVxuICovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi4vY3VycnknXG5cbmV4cG9ydCBkZWZhdWx0IGN1cnJ5KGZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChhLCBiKVxufSlcbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBlcXVhbHNBcnJheVxuICogQGRlc2NyaXB0aW9uIEF1dG9jdXJyaWVkIGZ1bmN0aW9uIGZvciBkZWVwIGNvbXBhcmlzb24gb2YgYXJyYXlzXG4gKiBAcGFyYW0ge2F9IHggLSBPYmplY3QgdG8gY29tcGFyZSBvZiB0eXBlIGFcbiAqIEBwYXJhbSB7YX0geSAtIE9iamVjdCB4IHRvIGNvbXBhcmUgd2l0aCBvYmplY3QgeFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuaW1wb3J0IGN1cnJ5IGZyb20gJy4uL2N1cnJ5J1xuaW1wb3J0IG5vdCBmcm9tICcuLi9ub3QnXG5pbXBvcnQgZXF1YWxzIGZyb20gJy4uL2VxdWFscydcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gZXF1YWxzQXJyYXkgKHgsIHkpIHtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub3QoZXF1YWxzKHhbaV0sIHlbaV0pKSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn0pXG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gZm9sZFxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBtYXBwaW5nIG92ZXIgdGhlIHByb3ZpZGVkIGFycmF5IGFuZCBjYWxsaW5nIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2NiRnVuY3Rpb259IGNiIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gbW9kaWZ5IHRoZSBpdGVtXG4gKiBAcGFyYW0geyp9IGluaXQgLSBJbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBhIC0gQXJyYXkgd2l0aCBpdGVtcyB0byBtb2RpZnkgYnkgdGhlIGNiIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhbGlhcyByZWR1Y2VcbiAqIEBzaW5jZSAxLjAuMlxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBmb2xkKGFkZCwgMCwgWzEsMSwxXSlcbiAqIC8vIHJlc3VsdCA9IDNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBjYkZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHIgLSBBY2N1bXVsYXRvciB3aGljaCBhY2N1bXVsYXRlcyB0aGUgY2FsbGJhY2sncyByZXR1cm4gdmFsdWVzXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV5IG9mIHRoZSBpdGVtIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtBcnJheX0gYSAtIFRoZSBpbml0aWFsIGFycmF5XG4gKiBAcmV0dXJuIHsqfVxuICovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi4vY3VycnknXG5cbmV4cG9ydCBkZWZhdWx0IGN1cnJ5KGZ1bmN0aW9uIGZvbGQgKGNiLCBpbml0LCBhKSB7XG4gIGxldCBpID0gLTFcbiAgY29uc3QgbCA9IGEubGVuZ3RoXG4gIGxldCByID0gaW5pdFxuICB3aGlsZSAoKytpIDwgbCkge1xuICAgIHIgPSBjYihyLCBhW2ldLCBpLCBhKVxuICB9XG4gIHJldHVybiByXG59KVxuIiwiLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBhbiBhcnJheSwgYXV0b2N1cnJpZWQgZnVuY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIGlzQXJyYXlcbiAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBhbiBhcnJheSwgYXV0b2N1cnJpZWQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gT2JqZWN0IHRvIHZlcmlmaXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAc2luY2UgMS4wLjJcbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgcmVzdWx0ID0gaXNBcnJheShbMSwxLDFdKVxuICogLy8gcmVzdWx0ID0gdHJ1ZVxuICovXG5cbmltcG9ydCBpcyBmcm9tICcuLi9pcydcblxuZXhwb3J0IGRlZmF1bHQgaXMoJ0FycmF5JylcbiIsIi8qKlxuICogQGZ1bmN0aW9uIG1hcFxuICogQGRlc2NyaXB0aW9uIE1hcHMgb3ZlciBhbiBhcnJheSBhbmQgYXBwbGllcyBhIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtJdGVyYWJsZX0gYVxuICogQHJldHVybiB7SXRlcmFibGV9XG4gKiBAc2luY2UgdjEuMC4yXG4gKiBAZXhhbXBsZVxuICpcbiAqICBjb25zdCByZXN1bHQgPSBtYXAoaWRlbnRpdHksIFswLDIsM10pXG4gKiAgLy8gcmVzdWx0ID0gWzAsMiwzXVxuICogIGNvbnN0IGFkZDIgPSBhZGQoMilcbiAqICBjb25zdCByZXN1bHQgPSBtYXAoYWRkMiwgWzAsMiwzXSlcbiAqICAvLyByZXN1bHQgPSBbMiw0LDVdXG4gKiovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi4vY3VycnknXG5cbmV4cG9ydCBkZWZhdWx0IGN1cnJ5KGZ1bmN0aW9uIG1hcCAoY2IsIGEpIHtcbiAgbGV0IGkgPSAtMVxuICBjb25zdCBsID0gYS5sZW5ndGhcbiAgY29uc3QgciA9IG5ldyBBcnJheShsKVxuICB3aGlsZSAoKytpIDwgbCkge1xuICAgIHJbaV0gPSBjYihhW2ldLCBpLCBhKVxuICB9XG4gIHJldHVybiByXG59KVxuIiwiLyoqXG4gKiBDdXJyaWVkIGZ1bmN0aW9uIHRoYXQgdmVyaWZpZXMgb2YgdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGlzIGEgYm9vbGVhblxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gaXNcbiAqIEBkZXNjcmlwdGlvbiBDdXJyaWVkIGZ1bmN0aW9uIHRoYXQgdmVyaWZpZXMgb2YgdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGlzIGEgYm9vbGVhblxuICogQHNpbmNlIHYxLjAuMlxuICogQHBhcmFtIHsqfSBJdGVtIHRvIHZlcmlmeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqKi9cbmltcG9ydCBpcyBmcm9tICcuLi9pcydcblxuZXhwb3J0IGRlZmF1bHQgaXMoJ0Jvb2xlYW4nKVxuIiwiLyoqXG4gKiBDb25jYXRlbmF0ZXMgMiBpdGVtcyB0b2dldGhlclxuICpcbiAqIEBmdW5jdGlvbiBjb25jYXRcbiAqIEBkZXNjcmlwdGlvbiBDb25jYXRlbmF0ZXMgMiBpdGVtcyB0b2dldGhlclxuICogQHNpbmNlIHYxLjAuNFxuICogQHBhcmFtIHthfSBhIC0gTGVmdCBzaWRlIG9mIHRoZSBjb25jYXRlbmF0aW9uXG4gKiBAcGFyYW0ge2F9IGIgLSByaWdodCBzaWRlIG9mIHRoZSBjb25jYXRlbmF0aW9uXG4gKiBAcmV0dXJuIHthfSBDb25jYXRlbmF0ZWQgaXRlbVxuICoqL1xuXG5pbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSdcbmltcG9ydCBhcnJheUNvbmNhdCBmcm9tICcuL2FycmF5L2NvbmNhdCdcbmltcG9ydCBzdHJpbmdDb25jYXQgZnJvbSAnLi9zdHJpbmcvY29uY2F0J1xuaW1wb3J0IHR5cGUgZnJvbSAnLi90eXBlJ1xuXG5leHBvcnQgZGVmYXVsdCBjdXJyeShmdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgY29uc3QgdHlwZU1hcCA9IHtcbiAgICAnU3RyaW5nJzogc3RyaW5nQ29uY2F0LFxuICAgICdBcnJheSc6IGFycmF5Q29uY2F0XG4gIH1cbiAgcmV0dXJuIHR5cGVNYXBbdHlwZShhKV0oYSwgYilcbn0pXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuLyoqXG4gKiBAZnVuY3Rpb24gY3VycnlcbiAqIEBkZXNjcmlwdGlvbiBBdXRvY3VycmllcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3VycnkgKGZ1bikge1xuICBjb25zdCBhcmdzbGVuID0gZnVuLmxlbmd0aFxuXG4gIGlmIChhcmdzbGVuID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1blxuICB9XG4gIHJldHVybiBjcmVhdGVSZWN1cnNlcihbXSlcblxuICBmdW5jdGlvbiByZWN1cnNlIChhY2MsIGFyZ3MpIHtcbiAgICBjb25zdCBfYWNjID0gYWNjLmNvbmNhdChhcmdzKVxuICAgIHJldHVybiBfYWNjLmxlbmd0aCA8IGFyZ3NsZW5cbiAgICAgID8gY3JlYXRlUmVjdXJzZXIoX2FjYylcbiAgICAgIDogZnVuLmFwcGx5KHRoaXMsIF9hY2MpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZWN1cnNlciAoYWNjKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWN1cnNlKGFjYywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBkaWVyaWNreC5sZW4gb24gMDEvMDQvMjAxNy5cbiAqL1xuLyoqXG4gKiBDcmVhdGVkIGJ5IGRpZXJpY2t4LmxlbiBvbiAwMS8wNC8yMDE3LlxuICovXG5pbXBvcnQgaXMgZnJvbSAnLi4vaXMnXG5cbmV4cG9ydCBkZWZhdWx0IGlzKCdEYXRlJylcbiIsIi8qKlxuXG4gKiBAZnVuY3Rpb24gZW1wdHlcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBlbXB0eSBlcXVpdmFsZW50IG9mIHRoZSBmaXJzdCBhcmd1bWVudFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVtcHR5ICh4KSB7XG4gIHJldHVybiBuZXcgeC5jb25zdHJ1Y3RvcigpXG59O1xuIiwiLyoqXG5cbiAqIEBmdW5jdGlvbiBlcXVhbHNcbiAqIEBkZXNjcmlwdGlvbiBBdXRvY3VycmllZCBmdW5jdGlvbiB0aGF0IGNoZWNrcyBmb3IgZXF1YWxpdHkgb2YgMiBpdGVtc1xuICogQHBhcmFtIHsqfSB4IC0gTGVmdCBzaWRlIG9mIHRoZSBlcXVhbGl0eSBjaGVja1xuICogQHBhcmFtIHsqfSB5IC0gUmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IG5hbiA9IE51bWJlci5OYU5cbiAqIGVxdWFsKG5hbiwgbmFuKSAvLyByZXR1cm5zIHRydWVcbiAqXG4gKiBjb25zdCBhcnIxID0gWzAsIDEsIDIsIDNdXG4gKiBjb25zdCBhcnIyID0gW251bGwsIDEsIDIsIDNdXG4gKiBlcXVhbHMoYXJyMSwgYXJyMikgLy8gcmV0dXJucyBmYWxzZVxuICpcbiAqIGVxdWFscyhuZXcgT2JqZWN0KHsnYSc6IDAsICdiJzogMX0pLCB7J2EnOiAwLCAnYic6IDF9KSAvLyB0cnVlXG4gKlxuICovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSdcbmltcG9ydCBleGlzdHMgZnJvbSAnLi9leGlzdHMnXG5pbXBvcnQgaWRlbnRpY2FsIGZyb20gJy4vaWRlbnRpY2FsJ1xuaW1wb3J0IHR5cGUgZnJvbSAnLi90eXBlJ1xuaW1wb3J0IG5vdCBmcm9tICcuL25vdCdcbmltcG9ydCBvciBmcm9tICcuL29yJ1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vb2JqZWN0L2lzJ1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9hcnJheS9pcydcbmltcG9ydCBpc0Jvb2xlYW4gZnJvbSAnLi9ib29sZWFuL2lzJ1xuaW1wb3J0IGlzTnVtYmVyIGZyb20gJy4vbnVtYmVyL2lzJ1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJy4vc3RyaW5nL2lzJ1xuaW1wb3J0IGlzRGF0ZSBmcm9tICcuL2RhdGUvaXMnXG5pbXBvcnQgZXF1YWxzQXJyYXkgZnJvbSAnLi9hcnJheS9lcXVhbHMnXG5pbXBvcnQgZXF1YWxzT2JqZWN0IGZyb20gJy4vb2JqZWN0L2VxdWFscydcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gZXF1YWxzICh4LCB5KSB7XG4gIGlmIChpZGVudGljYWwoeCwgeSkpIHJldHVybiB0cnVlXG5cbiAgaWYgKHR5cGUoeCkgIT09IHR5cGUoeSkpIHJldHVybiBmYWxzZVxuXG4gIGlmIChvcihub3QoZXhpc3RzKHgpKSwgbm90KGV4aXN0cyh5KSkpKSByZXR1cm4gZmFsc2VcblxuICBpZiAoeC5jb25zdHJ1Y3RvciAhPT0geS5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGlzU3RyaW5nKHgpIHx8IGlzQm9vbGVhbih4KSB8fCBpc051bWJlcih4KSB8fCBpc0RhdGUoeCkpIHtcbiAgICByZXR1cm4gaWRlbnRpY2FsKHgudmFsdWVPZigpLCB5LnZhbHVlT2YoKSlcbiAgfVxuICBpZiAoaXNBcnJheSh4KSkge1xuICAgIHJldHVybiBlcXVhbHNBcnJheSh4LCB5KVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGVxdWFsc09iamVjdCh4LCB5KVxuICB9XG4gIHJldHVybiBmYWxzZVxufSlcbiIsIi8qKlxuICogQGZ1bmN0aW9uIGV4aXN0c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleGlzdHMgKHgpIHtcbiAgcmV0dXJuICEoeCA9PSBudWxsKVxufTtcbiIsIi8qKlxuICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IGxpa2Ugb2JqZWN0IGFuZCBjYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBpdGVtXG4gKlxuICogQGZ1bmN0aW9uIGZvbGRcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgc2luZ2xlIGl0ZW0gYnkgaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgbGlrZSBvYmplY3QgYW5kIGNhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGl0ZW1cbiAqIEBzaW5jZSB2MS4wLjJcbiAqIEBzaWcgKChhLCBiLCBjLCBhKSDihpIgYSkg4oaSIGEg4oaSIFtiXSDihpIgYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgcmVjZWl2ZXMgNCB2YWx1ZXM6IHRoZSBhY2N1bXVsYXRvciwgdGhlIGl0ZW0sIHRoZSBpbmRleCwgYW5kIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHsqfSBhIGlzIHRoZSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0geyp9IFtiXSB0aGUgYXJyYXkgbGlrZSBpdGVtIHRvIGl0ZXJhdGUgb3ZlclxuICogQHJldHVybiB7Kn0gYSBpcyB0aGUgYWNjdW11bGF0ZWQgdmFsdWVcbiAqKi9cblxuaW1wb3J0IGN1cnJ5IGZyb20gJy4vY3VycnknXG5pbXBvcnQgYXJyYXlGb2xkIGZyb20gJy4vYXJyYXkvZm9sZCdcbmltcG9ydCBvYmplY3RGb2xkIGZyb20gJy4vb2JqZWN0L2ZvbGQnXG5pbXBvcnQgdHlwZSBmcm9tICcuL3R5cGUnXG5cbmV4cG9ydCBkZWZhdWx0IGN1cnJ5KGZ1bmN0aW9uIGZvbGQgKGNiLCBpbml0LCBhKSB7XG4gIGNvbnN0IHR5cGVNYXAgPSB7XG4gICAgJ09iamVjdCc6IG9iamVjdEZvbGQsXG4gICAgJ0FycmF5JzogYXJyYXlGb2xkXG4gIH1cbiAgLy8gaWYgKGEubmV4dCkge1xuICAvLyAgIHJldHVybiBpdGVyYWJsZUZvbGQoY2IsIGluaXQsIGEpXG4gIC8vIH1cbiAgLy8gaWYgKHR5cGUoU3ltYm9sKSAhPT0gJ3VuZGVmaW5lZCcgJiYgYVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gIC8vICAgcmV0dXJuIGl0ZXJhYmxlRm9sZChjYiwgaW5pdCwgYVtTeW1ib2wuaXRlcmF0b3JdKCkpXG4gIC8vIH1cbiAgcmV0dXJuIHR5cGVNYXBbdHlwZShhKV0oY2IsIGluaXQsIGEpXG59KVxuXG4vLyBmdW5jdGlvbiBpdGVyYWJsZUZvbGQgKGNiLCBhY2MsIGdlbikge1xuLy8gICBsZXQgc3RlcCA9IGdlbi5uZXh0KClcbi8vICAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbi8vICAgICBhY2MgPSBjYihhY2MsIHN0ZXAudmFsdWUpXG4vLyAgICAgc3RlcCA9IGdlbi5uZXh0KClcbi8vICAgfVxuLy8gICByZXR1cm4gYWNjXG4vLyB9XG4iLCIvKipcblxuICogQGZ1bmN0aW9uIGlkZW50aWNhbFxuICogQGRlc2NyaXB0aW9uIGNoZWNrcyBmb3IgaWRlbnRpbnRpY2FsIGl0ZW1zXG4gKi9cbmltcG9ydCBjdXJyeSBmcm9tICcuL2N1cnJ5J1xuaW1wb3J0IGlzTmFuIGZyb20gJy4vbnVtYmVyL2lzTmFuJ1xuXG5leHBvcnQgZGVmYXVsdCBjdXJyeShmdW5jdGlvbiBpZGVudGljYWwgKHgsIHkpIHtcbiAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCkge1xuICAgIHJldHVybiAxIC8geCA9PT0gMSAvIHlcbiAgfVxuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKGlzTmFuKHgpICYmIGlzTmFuKHkpKVxufSlcbiIsIi8qKlxuICogQGZ1bmN0aW9uIGlzXG4gKiBAZGVzY3JpcHRpb24gVmVyaWZpZXMgdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIGFyZ3VtZW50XG4gKlxuICovXG5cbmltcG9ydCBjdXJyeSBmcm9tICcuL2N1cnJ5J1xuaW1wb3J0IHR5cGUgZnJvbSAnLi90eXBlJ1xuXG5leHBvcnQgZGVmYXVsdCBjdXJyeShmdW5jdGlvbiBpcyAoQ3RvciwgdmFsKSB7XG4gIHJldHVybiB0eXBlKHZhbCkgPT09IEN0b3Jcbn0pXG4iLCIvKipcbiAqIENyZWF0ZWQgYnkgZGllcmlja3gubGVuIG9uIDAxLzA0LzIwMTcuXG4gKi9cbmltcG9ydCBpcyBmcm9tICcuLi9pcydcbmNvbnN0IGlzRnVuY3Rpb24gPSBpcygnRnVuY3Rpb24nKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0l0ZXIgKGl0ZXIpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oaXRlcltTeW1ib2wuaXRlcmF0b3JdKVxufVxuIiwiLyoqXG4gKiBNYXBzIG92ZXIgYW4gSXRlcmF0b3IgYW5kIGFwcGxpZXMgYSBmdW5jdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHNpbmNlIHYxLjAuM1xuICogQHNpZyAoY3VycmVudFZhbHVlLCBpZHgsIFthXSkgLT4ge2J9IC0+IFtiXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7SXRlcmF0b3J9IGFcbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICoqL1xuaW1wb3J0IGN1cnJ5IGZyb20gJy4uL2N1cnJ5J1xuXG5leHBvcnQgZGVmYXVsdCBjdXJyeShmdW5jdGlvbiBtYXAgKGNhbGxiYWNrLCBpdGVyYXRvcikge1xuICBsZXQgciA9IFtdXG4gIGZvciAobGV0IG5leHRWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKTsgbmV4dFZhbHVlLmRvbmUgIT09IHRydWU7IG5leHRWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKSkge1xuICAgIHIucHVzaChjYWxsYmFjayhpdGVyYXRvci52YWx1ZSgpKSlcbiAgfVxuICByZXR1cm4gclxufSlcbiIsIi8qKlxuICogTWFwcyBvdmVyIGFuIGl0ZXJhYmxlIGFuZCBhcHBsaWVzIGEgZnVuY3Rpb25cbiAqXG4gKiBAZnVuY3Rpb24gbWFwXG4gKiBAZGVzY3JpcHRpb24gQXV0b2N1cnJpZWQgZnVuY3Rpb24gd2hpY2ggbWFwcyBvdmVyIGFuIGl0ZXJhYmxlLlxuICogQHNpbmNlIHYxLjAuMlxuICogQHNpZyAoY3VycmVudFZhbHVlLCBpZHgsIFthXSkgLT4gYiAtPiBiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtJdGVyYWJsZX0gYVxuICogQHJldHVybiB7SXRlcmFibGV9XG4gKiovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSdcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL2FycmF5L21hcCdcbmltcG9ydCBvYmplY3RNYXAgZnJvbSAnLi9vYmplY3QvbWFwJ1xuaW1wb3J0IG1hcE1hcCBmcm9tICcuL21hcC9tYXAnXG5pbXBvcnQgc3RyaW5nTWFwIGZyb20gJy4vc3RyaW5nL21hcCdcbmltcG9ydCBpdGVyYXRvck1hcCBmcm9tICcuL2l0ZXJhdG9yL21hcCdcbmltcG9ydCB0eXBlIGZyb20gJy4vdHlwZSdcbmltcG9ydCBpc0l0ZXJhdG9yIGZyb20gJy4vaXRlcmF0b3IvaXMnXG5cbmV4cG9ydCBkZWZhdWx0IGN1cnJ5KGZ1bmN0aW9uIG1hcCAoY2IsIGEpIHtcbiAgc3dpdGNoICh0eXBlKGEpKSB7XG4gICAgY2FzZSAnRnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGN1cnJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNiLmNhbGwodGhpcywgYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgICAgfSlcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgcmV0dXJuIG9iamVjdE1hcChjYiwgYSlcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIHN0cmluZ01hcChjYiwgYSlcbiAgICBjYXNlICdNYXAnOlxuICAgICAgcmV0dXJuIG1hcE1hcChjYiwgYSlcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gYXJyYXlNYXAoY2IsIGEpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBpc0l0ZXJhdG9yKGEpXG4gICAgICAgID8gaXRlcmF0b3JNYXAoY2IsIGEpXG4gICAgICAgIDogYXJyYXlNYXAoY2IsIGEpXG4gIH1cbn0pXG4iLCIvKipcbiAqIE1hcHMgb3ZlciBhIE1hcCBhbmQgYXBwbGllcyBhIGZ1bmN0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2luY2UgdjEuMC4yXG4gKiBAc2lnIChjdXJyZW50VmFsdWUsIGlkeCwgW2FdKSAtPiB7Yn0gLT4gW2JdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtNYXB9IGFcbiAqIEByZXR1cm4ge01hcH1cbiAqKi9cbmltcG9ydCBjdXJyeSBmcm9tICcuLi9jdXJyeSdcbmltcG9ydCBlbXB0eSBmcm9tICcuLi9lbXB0eSdcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gbWFwIChjYiwgYSkge1xuICBjb25zdCByID0gZW1wdHkoYSlcbiAgYS5mb3JFYWNoKCh2LCBrLCBtYXApID0+IHtcbiAgICByLnNldChrLCBjYih2LCBrLCBtYXApKVxuICB9KVxuICByZXR1cm4gclxufSlcbiIsIi8qKlxuICogQGZ1bmN0aW9uIG5vdFxuICovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSdcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gbm90ICh4KSB7XG4gIHJldHVybiAheFxufSlcbiIsIi8qKlxuICogQHByaXZhdGVcbiAqL1xuaW1wb3J0IGlzIGZyb20gJy4uL2lzJ1xuXG5leHBvcnQgZGVmYXVsdCBpcygnTnVtYmVyJylcbiIsIi8qKlxuICogQGZ1bmN0aW9uIGlzTmFOXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIG51bWJlciBpcyBOQU5cblxuICovXG5pbXBvcnQgaXNOdW1iZXIgZnJvbSAnLi9pcydcbmltcG9ydCBhbmQgZnJvbSAnLi4vYW5kJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc05hbiAoeCkge1xuICByZXR1cm4gYW5kKGlzTnVtYmVyKHgpLCBpc05hTih4KSlcbn07XG4iLCIvKipcblxuICogZXF1YWxzXG4gKiBjaGVja3MgZm9yIGVxdWFsaXR5XG4gKi9cbmltcG9ydCBjdXJyeSBmcm9tICcuLi9jdXJyeSdcbmltcG9ydCBleGlzdHMgZnJvbSAnLi4vZXhpc3RzJ1xuaW1wb3J0IG5vdCBmcm9tICcuLi9ub3QnXG5pbXBvcnQgZXF1YWxzIGZyb20gJy4uL2VxdWFscydcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoKHgsIHkpID0+IHtcbiAgZm9yIChsZXQga2V5WCBpbiB4KSB7XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgIGlmIChub3QoZXF1YWxzKHhba2V5WF0sIHlba2V5WF0pKSkgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBrZXlZIGluIHkpIHtcbiAgICBpZiAobm90KGV4aXN0cyh4W2tleVldKSkgJiYgZXhpc3RzKHlba2V5WV0pKSByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59KVxuIiwiLyoqXG4gKiBAZnVuY3Rpb24gZm9sZFxuICogQHByaXZhdGVcbiAqXG4gKi9cbmltcG9ydCBjdXJyeSBmcm9tICcuLi9jdXJyeSdcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cydcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gZm9sZCAoY2IsIGluaXQsIG8pIHtcbiAgY29uc3QgayA9IGtleXMobylcbiAgbGV0IGkgPSAtMVxuICBjb25zdCBsID0gay5sZW5ndGhcbiAgbGV0IHIgPSBPYmplY3QoaW5pdClcbiAgd2hpbGUgKCsraSA8IGwpIHtcbiAgICByID0gY2Iociwgb1trW2ldXSwga1tpXSwgbylcbiAgfVxuICByZXR1cm4gclxufSlcbiIsIi8qKlxuXG4gKi9cbmltcG9ydCBpcyBmcm9tICcuLi9pcydcblxuZXhwb3J0IGRlZmF1bHQgaXMoJ09iamVjdCcpXG4iLCIvKipcbiAqIFJldHVybnMgdGhlIG93biBrZXlzIG9mIGFuIG9iamVjdCBhcyBhbiBBcnJheVxuICpcbiAqIEBmdW5jdGlvblxuICogQHNpbmNlIHYxLjAuMlxuICogQHNpZyBhIC0+IFtiXVxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqKi9cbmltcG9ydCBjdXJyeSBmcm9tICcuLi9jdXJyeSdcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24ga2V5cyAoYSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoT2JqZWN0KGEpKVxufSlcbiIsIi8qKlxuICogTWFwcyBvdmVyIGFuIG9iamVjdCBhbmQgYXBwbGllcyBhIGZ1bmN0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2luY2UgdjEuMC4yXG4gKiBAc2lnIChjdXJyZW50VmFsdWUsIGlkeCwgW2FdKSAtPiB7Yn0gLT4gW2JdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqKi9cbmltcG9ydCBjdXJyeSBmcm9tICcuLi9jdXJyeSdcbmltcG9ydCBlbXB0eSBmcm9tICcuLi9lbXB0eSdcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cydcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gbWFwIChjYiwgYSkge1xuICBjb25zdCBrID0ga2V5cyhhKVxuICBsZXQgaSA9IC0xXG4gIGNvbnN0IGwgPSBrLmxlbmd0aFxuICBjb25zdCByID0gZW1wdHkoYSlcbiAgd2hpbGUgKCsraSA8IGwpIHtcbiAgICByW2tbaV1dID0gY2IoYVtrW2ldXSwga1tpXSwgYSlcbiAgfVxuICByZXR1cm4gclxufSlcbiIsIi8qKlxuICogQGZ1bmN0aW9uIG9yXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0cnVlIGlmIG9uZSBvciB0aGUgb3RoZXIgaXMgdHJ1ZVxuICovXG5pbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSdcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gb3IgKHgsIHkpIHtcbiAgcmV0dXJuIHggfHwgeVxufSlcbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBzdHJpbmdDb25jYXRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25jYXQgKGEsIGIpIHsgLy8gdXNlIGZ1bmN0aW9uKCksIGFycm93IGZ1bmN0aW9uIGRvZXNuJ3QgYmluZCBhcmd1bWVudHNcbiAgcmV0dXJuIFN0cmluZyhhKSArIFN0cmluZyhiKVxufVxuIiwiLyoqXG5cbiAqL1xuaW1wb3J0IGlzIGZyb20gJy4uL2lzJ1xuXG5leHBvcnQgZGVmYXVsdCBpcygnU3RyaW5nJylcbiIsIi8qKlxuICogTWFwcyBvdmVyIGEgc3RyaW5nIGFuZCBhcHBsaWVzIGEgZnVuY3Rpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzaW5jZSB2MS4wLjJcbiAqIEBzaWcgKGN1cnJlbnRWYWx1ZSwgaWR4LCBbYV0pIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBhXG4gKiBAcmV0dXJuIHtJdGVyYWJsZX1cbiAqKi9cbmltcG9ydCBjdXJyeSBmcm9tICcuLi9jdXJyeSdcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkoZnVuY3Rpb24gbWFwIChjYiwgYSkge1xuICBsZXQgaSA9IC0xXG4gIGNvbnN0IGwgPSBhLmxlbmd0aFxuICBsZXQgciA9ICcnXG4gIHdoaWxlICgrK2kgPCBsKSB7XG4gICAgciArPSBjYihhLmNoYXJBdChpKSwgaSwgYSlcbiAgfVxuICByZXR1cm4gclxufSlcbiIsIi8qKlxuICogQGZ1bmN0aW9uIHR5cGVcbiAqL1xuaW1wb3J0IGN1cnJ5MSBmcm9tICcuL19wcml2YXRlL2N1cnJ5MSdcblxuZXhwb3J0IGRlZmF1bHQgY3VycnkxKGZ1bmN0aW9uIHR5cGUgKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KS5zbGljZSg4LCAtMSlcbn0pXG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dCAod2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICB3aWR0aCA9IHdpZHRoIHwgMFxuICBoZWlnaHQgPSBoZWlnaHQgfCAwXG4gIGlmICghKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgaWYgKCFjYW52YXMpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciBnbFxuICBjYW52YXMud2lkdGggPSB3aWR0aFxuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG5cbiAgdHJ5IHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHZhciBfZ2V0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uXG4gIHZhciBleHREZXN0cm95ID0ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3NlQ29udGV4dCA9IF9nZXRFeHRlbnNpb24uY2FsbChnbCwgJ1dFQkdMX2xvc2VfY29udGV4dCcpXG4gICAgICBpZiAobG9zZUNvbnRleHQpIHtcbiAgICAgICAgbG9zZUNvbnRleHQubG9zZUNvbnRleHQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBleHRSZXNpemUgPSB7XG4gICAgcmVzaXplOiBmdW5jdGlvbiAodywgaCkge1xuICAgICAgY2FudmFzLndpZHRoID0gd1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhcbiAgICB9XG4gIH1cblxuICB2YXIgX3N1cHBvcnRlZEV4dGVuc2lvbnMgPSBnbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkuc2xpY2UoKVxuICBfc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKFxuICAgICdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcsXG4gICAgJ1NUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXInKVxuICBnbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3VwcG9ydGVkRXh0ZW5zaW9ucy5zbGljZSgpXG4gIH1cblxuICBnbC5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0TmFtZSkge1xuICAgIHZhciBuYW1lID0gZXh0TmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKG5hbWUgPT09ICdzdGFja2dsX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyJykge1xuICAgICAgcmV0dXJuIGV4dFJlc2l6ZVxuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ3N0YWNrZ2xfZGVzdHJveV9jb250ZXh0Jykge1xuICAgICAgcmV0dXJuIGV4dERlc3Ryb3lcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRFeHRlbnNpb24uY2FsbChnbCwgZXh0TmFtZSlcbiAgfVxuXG4gIHJldHVybiBnbCB8fCBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ29udGV4dFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtb2NrMUQoKSB7XG4gIGNvbnN0IHJvdyA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMub3V0cHV0Lng7IHgrKykge1xuICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgIHRoaXMudGhyZWFkLnkgPSAwO1xuICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgIHJvdy5wdXNoKHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG4gIHJldHVybiByb3c7XG59XG5cbmZ1bmN0aW9uIG1vY2syRCgpIHtcbiAgY29uc3QgbWF0cml4ID0gW107XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5vdXRwdXQueTsgeSsrKSB7XG4gICAgY29uc3Qgcm93ID0gW107XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHJvdy5wdXNoKHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBtYXRyaXgucHVzaChyb3cpO1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmZ1bmN0aW9uIG1vY2szRCgpIHtcbiAgY29uc3QgY3ViZSA9IFtdO1xuICBmb3IgKGxldCB6ID0gMDsgeiA8IHRoaXMub3V0cHV0Lno7IHorKykge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5vdXRwdXQueTsgeSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgdGhpcy50aHJlYWQueiA9IHo7XG4gICAgICAgIHJvdy5wdXNoKHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgbWF0cml4LnB1c2gocm93KTtcbiAgICB9XG4gICAgY3ViZS5wdXNoKG1hdHJpeCk7XG4gIH1cbiAgcmV0dXJuIGN1YmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ3B1TW9jayhmbiwgb3B0aW9ucykge1xuICBsZXQgY29udGV4dE91dHB1dCA9IG51bGw7XG4gIGlmIChvcHRpb25zLm91dHB1dC5sZW5ndGgpIHtcbiAgICBpZiAob3B0aW9ucy5vdXRwdXQubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb250ZXh0T3V0cHV0ID0geyB4OiBvcHRpb25zLm91dHB1dFswXSwgeTogb3B0aW9ucy5vdXRwdXRbMV0sIHo6IG9wdGlvbnMub3V0cHV0WzJdIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm91dHB1dC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnRleHRPdXRwdXQgPSB7IHg6IG9wdGlvbnMub3V0cHV0WzBdLCB5OiBvcHRpb25zLm91dHB1dFsxXSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0T3V0cHV0ID0geyB4OiBvcHRpb25zLm91dHB1dFswXSB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0T3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQ7XG4gIH1cblxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIF9mbjogZm4sXG4gICAgY29uc3RhbnRzOiBvcHRpb25zLmNvbnN0YW50cyxcbiAgICBvdXRwdXQ6IGNvbnRleHRPdXRwdXQsXG4gICAgdGhyZWFkOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHo6IDBcbiAgICB9XG4gIH07XG5cbiAgaWYgKGNvbnRleHRPdXRwdXQueikge1xuICAgIHJldHVybiBtb2NrM0QuYmluZChjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChjb250ZXh0T3V0cHV0LnkpIHtcbiAgICByZXR1cm4gbW9jazJELmJpbmQoY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1vY2sxRC5iaW5kKGNvbnRleHQpO1xuICB9XG59O1xuIiwiY29uc3Qge1xuXHR1dGlsc1xufSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSBzb3VyY2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYWxpYXMobmFtZSwgc291cmNlKSB7XG5cdGNvbnN0IGZuU3RyaW5nID0gc291cmNlLnRvU3RyaW5nKCk7XG5cdHJldHVybiBuZXcgRnVuY3Rpb24oYHJldHVybiBmdW5jdGlvbiAkeyBuYW1lIH0gKCR7IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKGZuU3RyaW5nKS5qb2luKCcsICcpIH0pIHtcbiAgJHsgdXRpbHMuZ2V0RnVuY3Rpb25Cb2R5RnJvbVN0cmluZyhmblN0cmluZykgfVxufWApKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhbGlhc1xufTsiLCJjb25zdCB7XG5cdEZ1bmN0aW9uTm9kZVxufSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLW5vZGUnKTtcblxuLyoqXG4gKiBAZGVzYyBbSU5URVJOQUxdIFJlcHJlc2VudHMgYSBzaW5nbGUgZnVuY3Rpb24sIGluc2lkZSBKU1xuICpcbiAqIDxwPlRoaXMgaGFuZGxlcyBhbGwgdGhlIHJhdyBzdGF0ZSwgY29udmVydGVkIHN0YXRlLCBldGMuIE9mIGEgc2luZ2xlIGZ1bmN0aW9uLjwvcD5cbiAqL1xuY2xhc3MgQ1BVRnVuY3Rpb25Ob2RlIGV4dGVuZHMgRnVuY3Rpb25Ob2RlIHtcblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yIHRvIGl0cyAqbmFtZWQgZnVuY3Rpb24qXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcblx0ICovXG5cdGFzdEZ1bmN0aW9uRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXG5cdFx0Ly8gU2V0dXAgZnVuY3Rpb24gcmV0dXJuIHR5cGUgYW5kIG5hbWVcblx0XHRpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgnZnVuY3Rpb24nKTtcblx0XHRcdHJldEFyci5wdXNoKCcgJyk7XG5cdFx0XHRyZXRBcnIucHVzaCh0aGlzLm5hbWUpO1xuXHRcdFx0cmV0QXJyLnB1c2goJygnKTtcblxuXHRcdFx0Ly8gQXJndW1lbnRzIGhhbmRsaW5nXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjb25zdCBhcmd1bWVudE5hbWUgPSB0aGlzLmFyZ3VtZW50TmFtZXNbaV07XG5cblx0XHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJywgJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0QXJyLnB1c2goJ3VzZXJfJyk7XG5cdFx0XHRcdHJldEFyci5wdXNoKGFyZ3VtZW50TmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZ1bmN0aW9uIG9wZW5pbmdcblx0XHRcdHJldEFyci5wdXNoKCcpIHtcXG4nKTtcblx0XHR9XG5cblx0XHQvLyBCb2R5IHN0YXRlbWVudCBpdGVyYXRpb25cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5LmJvZHkubGVuZ3RoOyArK2kpIHtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYm9keS5ib2R5W2ldLCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJ1xcbicpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc1Jvb3RLZXJuZWwpIHtcblx0XHRcdC8vIEZ1bmN0aW9uIGNsb3Npbmdcblx0XHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cdFx0fVxuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgdG8gKnJldHVybiogc3RhdGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcblx0ICovXG5cdGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuXHRcdGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuXHRcdFx0cmV0QXJyLnB1c2godGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50KTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnO1xcbicpO1xuXHRcdFx0cmV0QXJyLnB1c2godGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQpO1xuXHRcdFx0cmV0QXJyLnB1c2goJ2NvbnRpbnVlO1xcbicpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5pc1N1Yktlcm5lbCkge1xuXHRcdFx0cmV0QXJyLnB1c2goYHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfSA9IGApO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRyZXRBcnIucHVzaChgcmV0dXJuIHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfTtgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0QXJyLnB1c2goJ3JldHVybiAnKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpsaXRlcmFsIHZhbHVlKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RMaXRlcmFsKGFzdCwgcmV0QXJyKSB7XG5cblx0XHQvLyBSZWplY3Qgbm9uIG51bWVyaWMgbGl0ZXJhbHNcblx0XHRpZiAoaXNOYU4oYXN0LnZhbHVlKSkge1xuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcblx0XHRcdFx0J05vbi1udW1lcmljIGxpdGVyYWwgbm90IHN1cHBvcnRlZCA6ICcgKyBhc3QudmFsdWUsXG5cdFx0XHRcdGFzdFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXRBcnIucHVzaChhc3QudmFsdWUpO1xuXG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqYmluYXJ5KiBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcblx0ICovXG5cdGFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRyZXRBcnIucHVzaCgnKCcpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaChhc3Qub3BlcmF0b3IpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICppZGVudGlmaWVyKiBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpZHROb2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcblx0XHRpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG5cdFx0XHRcdCdJZGVudGlmaWVyRXhwcmVzc2lvbiAtIG5vdCBhbiBJZGVudGlmaWVyJyxcblx0XHRcdFx0aWR0Tm9kZVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGlkdE5vZGUubmFtZSkge1xuXHRcdFx0Y2FzZSAnSW5maW5pdHknOlxuXHRcdFx0XHRyZXRBcnIucHVzaCgnSW5maW5pdHknKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRpZiAodGhpcy5jb25zdGFudHMgJiYgdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkoaWR0Tm9kZS5uYW1lKSkge1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCdjb25zdGFudHNfJyArIGlkdE5vZGUubmFtZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRoaXMuZ2V0S2VybmVsQXJndW1lbnROYW1lKGlkdE5vZGUubmFtZSk7XG5cdFx0XHRcdFx0aWYgKG5hbWUpIHtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd1c2VyXycgKyBuYW1lKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VzZXJfJyArIGlkdE5vZGUubmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqZm9yLWxvb3AqIGV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGZvck5vZGUgLSBBbiBhc3QgTm9kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHBhcnNlZCB3ZWJnbCBzdHJpbmdcblx0ICovXG5cdGFzdEZvclN0YXRlbWVudChmb3JOb2RlLCByZXRBcnIpIHtcblx0XHRpZiAoZm9yTm9kZS50eXBlICE9PSAnRm9yU3RhdGVtZW50Jykge1xuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCBmb3Igc3RhdGVtZW50JywgZm9yTm9kZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5pdEFyciA9IFtdO1xuXHRcdGNvbnN0IHRlc3RBcnIgPSBbXTtcblx0XHRjb25zdCB1cGRhdGVBcnIgPSBbXTtcblx0XHRjb25zdCBib2R5QXJyID0gW107XG5cdFx0bGV0IGlzU2FmZSA9IG51bGw7XG5cblx0XHRpZiAoZm9yTm9kZS5pbml0KSB7XG5cdFx0XHR0aGlzLnB1c2hTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUuaW5pdCwgaW5pdEFycik7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGluaXRBcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGluaXRBcnJbaV0uaW5jbHVkZXMgJiYgaW5pdEFycltpXS5pbmNsdWRlcygnLCcpKSB7XG5cdFx0XHRcdFx0aXNTYWZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucG9wU3RhdGUoJ2luLWZvci1sb29wLWluaXQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXNTYWZlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGZvck5vZGUudGVzdCkge1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdCwgdGVzdEFycik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlzU2FmZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChmb3JOb2RlLnVwZGF0ZSkge1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUudXBkYXRlLCB1cGRhdGVBcnIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpc1NhZmUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZm9yTm9kZS5ib2R5KSB7XG5cdFx0XHR0aGlzLnB1c2hTdGF0ZSgnbG9vcC1ib2R5Jyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LCBib2R5QXJyKTtcblx0XHRcdHRoaXMucG9wU3RhdGUoJ2xvb3AtYm9keScpO1xuXHRcdH1cblxuXHRcdC8vIGhhdmUgYWxsIHBhcnRzLCBub3cgbWFrZSB0aGVtIHNhZmVcblx0XHRpZiAoaXNTYWZlID09PSBudWxsKSB7XG5cdFx0XHRpc1NhZmUgPSB0aGlzLmlzU2FmZShmb3JOb2RlLmluaXQpICYmIHRoaXMuaXNTYWZlKGZvck5vZGUudGVzdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzU2FmZSkge1xuXHRcdFx0cmV0QXJyLnB1c2goYGZvciAoJHtpbml0QXJyLmpvaW4oJycpfTske3Rlc3RBcnIuam9pbignJyl9OyR7dXBkYXRlQXJyLmpvaW4oJycpfSl7XFxuYCk7XG5cdFx0XHRyZXRBcnIucHVzaChib2R5QXJyLmpvaW4oJycpKTtcblx0XHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuXHRcdFx0aWYgKGluaXRBcnIubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRyZXRBcnIucHVzaChpbml0QXJyLmpvaW4oJycpLCAnO1xcbicpO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goYGZvciAobGV0ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG5cdFx0XHRpZiAodGVzdEFyci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKGBpZiAoISR7dGVzdEFyci5qb2luKCcnKX0pIGJyZWFrO1xcbmApO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG5cdFx0XHRyZXRBcnIucHVzaChgXFxuJHt1cGRhdGVBcnIuam9pbignJyl9O2ApO1xuXHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqd2hpbGUqIGxvb3Bcblx0ICogQHBhcmFtIHtPYmplY3R9IHdoaWxlTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgcGFyc2VkIGphdmFzY3JpcHQgc3RyaW5nXG5cdCAqL1xuXHRhc3RXaGlsZVN0YXRlbWVudCh3aGlsZU5vZGUsIHJldEFycikge1xuXHRcdGlmICh3aGlsZU5vZGUudHlwZSAhPT0gJ1doaWxlU3RhdGVtZW50Jykge1xuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcblx0XHRcdFx0J0ludmFsaWQgd2hpbGUgc3RhdGVtZW50Jyxcblx0XHRcdFx0d2hpbGVOb2RlXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldEFyci5wdXNoKCdmb3IgKGxldCBpID0gMDsgaSA8IExPT1BfTUFYOyBpKyspIHsnKTtcblx0XHRyZXRBcnIucHVzaCgnaWYgKCcpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUudGVzdCwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cdFx0dGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuXHRcdHJldEFyci5wdXNoKCd9IGVsc2Uge1xcbicpO1xuXHRcdHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcblx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpkbyB3aGlsZSogbG9vcFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZG9XaGlsZU5vZGUgLSBBbiBhc3QgTm9kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHBhcnNlZCB3ZWJnbCBzdHJpbmdcblx0ICovXG5cdGFzdERvV2hpbGVTdGF0ZW1lbnQoZG9XaGlsZU5vZGUsIHJldEFycikge1xuXHRcdGlmIChkb1doaWxlTm9kZS50eXBlICE9PSAnRG9XaGlsZVN0YXRlbWVudCcpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG5cdFx0XHRcdCdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsXG5cdFx0XHRcdGRvV2hpbGVOb2RlXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldEFyci5wdXNoKCdmb3IgKGxldCBpID0gMDsgaSA8IExPT1BfTUFYOyBpKyspIHsnKTtcblx0XHR0aGlzLmFzdEdlbmVyaWMoZG9XaGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaCgnaWYgKCEnKTtcblx0XHR0aGlzLmFzdEdlbmVyaWMoZG9XaGlsZU5vZGUudGVzdCwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cdFx0cmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuXHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblxuXHRcdHJldHVybiByZXRBcnI7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqQXNzaWdubWVudCogRXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXNzTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXNzTm9kZSwgcmV0QXJyKSB7XG5cdFx0dGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaChhc3NOb2RlLm9wZXJhdG9yKTtcblx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpCbG9jayogc3RhdGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBiTm9kZSAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0QmxvY2tTdGF0ZW1lbnQoYk5vZGUsIHJldEFycikge1xuXHRcdGlmICh0aGlzLmlzU3RhdGUoJ2xvb3AtYm9keScpKSB7XG5cdFx0XHR0aGlzLnB1c2hTdGF0ZSgnYmxvY2stYm9keScpOyAvLyB0aGlzIHByZXZlbnRzIHJlY3Vyc2l2ZSByZW1vdmFsIG9mIGJyYWNlc1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb3BTdGF0ZSgnYmxvY2stYm9keScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRBcnIucHVzaCgne1xcbicpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqVmFyaWFibGUgRGVjbGFyYXRpb24qXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YXJEZWNOb2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RWYXJpYWJsZURlY2xhcmF0aW9uKHZhckRlY05vZGUsIHJldEFycikge1xuXHRcdGlmICh2YXJEZWNOb2RlLmtpbmQgPT09ICd2YXInKSB7XG5cdFx0XHR0aGlzLnZhcldhcm4oKTtcblx0XHR9XG5cdFx0cmV0QXJyLnB1c2goYCR7dmFyRGVjTm9kZS5raW5kfSBgKTtcblx0XHRjb25zdCBmaXJzdERlY2xhcmF0aW9uID0gdmFyRGVjTm9kZS5kZWNsYXJhdGlvbnNbMF07XG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShmaXJzdERlY2xhcmF0aW9uLmluaXQpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdmFyRGVjTm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuZGVjbGFyYXRpb25zW3ZhckRlY05vZGUuZGVjbGFyYXRpb25zW2ldLmlkLm5hbWVdID0ge1xuXHRcdFx0XHR0eXBlOiB0eXBlID09PSAnTGl0ZXJhbEludGVnZXInID8gJ051bWJlcicgOiB0eXBlLFxuXHRcdFx0XHRkZXBlbmRlbmNpZXM6IHtcblx0XHRcdFx0XHRjb25zdGFudHM6IFtdLFxuXHRcdFx0XHRcdGFyZ3VtZW50czogW11cblx0XHRcdFx0fSxcblx0XHRcdFx0aXNVbnNhZmU6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcsJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWModmFyRGVjTm9kZS5kZWNsYXJhdGlvbnNbaV0sIHJldEFycik7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5pc1N0YXRlKCdpbi1mb3ItbG9vcC1pbml0JykpIHtcblx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0fVxuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKklmKiBTdGF0ZW1lbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGlmTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0SWZTdGF0ZW1lbnQoaWZOb2RlLCByZXRBcnIpIHtcblx0XHRyZXRBcnIucHVzaCgnaWYgKCcpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUudGVzdCwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdGlmIChpZk5vZGUuY29uc2VxdWVudC50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldEFyci5wdXNoKCcge1xcbicpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcblx0XHR9XG5cblx0XHRpZiAoaWZOb2RlLmFsdGVybmF0ZSkge1xuXHRcdFx0cmV0QXJyLnB1c2goJ2Vsc2UgJyk7XG5cdFx0XHRpZiAoaWZOb2RlLmFsdGVybmF0ZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goJyB7XFxuJyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnXFxufVxcbicpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0QXJyO1xuXG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlRoaXMqIGV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtPYmplY3R9IHROb2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RUaGlzRXhwcmVzc2lvbih0Tm9kZSwgcmV0QXJyKSB7XG5cdFx0cmV0QXJyLnB1c2goJ190aGlzJyk7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqTWVtYmVyKiBFeHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0TWVtYmVyRXhwcmVzc2lvbihtTm9kZSwgcmV0QXJyKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0c2lnbmF0dXJlLFxuXHRcdFx0dHlwZSxcblx0XHRcdHByb3BlcnR5LFxuXHRcdFx0eFByb3BlcnR5LFxuXHRcdFx0eVByb3BlcnR5LFxuXHRcdFx0elByb3BlcnR5LFxuXHRcdFx0bmFtZSxcblx0XHRcdG9yaWdpblxuXHRcdH0gPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKG1Ob2RlKTtcblx0XHRzd2l0Y2ggKHNpZ25hdHVyZSkge1xuXHRcdFx0Y2FzZSAndGhpcy50aHJlYWQudmFsdWUnOlxuXHRcdFx0XHRyZXRBcnIucHVzaChgX3RoaXMudGhyZWFkLiR7IG5hbWUgfWApO1xuXHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0Y2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuXHRcdFx0XHRzd2l0Y2ggKG5hbWUpIHtcblx0XHRcdFx0XHRjYXNlICd4Jzpcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzBdKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3knOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMV0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCh0aGlzLm91dHB1dFsyXSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRjYXNlICd2YWx1ZSc6XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcblx0XHRcdGNhc2UgJ3ZhbHVlW10nOlxuXHRcdFx0Y2FzZSAndmFsdWVbXVtdJzpcblx0XHRcdGNhc2UgJ3ZhbHVlW11bXVtdJzpcblx0XHRcdGNhc2UgJ3ZhbHVlLnZhbHVlJzpcblx0XHRcdFx0aWYgKG9yaWdpbiA9PT0gJ01hdGgnKSB7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goTWF0aFtuYW1lXSk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0Y2FzZSAncic6XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMF1gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRcdFx0Y2FzZSAnZyc6XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMV1gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMl1gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bM11gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG5cdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJzpcblx0XHRcdGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXSc6XG5cdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZm4oKVtdJzpcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLnByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBzaW1wbGUgdHlwZXNcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXRBcnIucHVzaChgJHsgb3JpZ2luIH1fJHsgbmFtZX1gKTtcblx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvLyBoYW5kbGUgbW9yZSBjb21wbGV4IHR5cGVzXG5cdFx0Ly8gYXJndW1lbnQgbWF5IGhhdmUgY29tZSBmcm9tIGEgcGFyZW50XG5cdFx0Y29uc3Qgc3lub255bU5hbWUgPSB0aGlzLmdldEtlcm5lbEFyZ3VtZW50TmFtZShuYW1lKTtcblx0XHRjb25zdCBtYXJrdXBOYW1lID0gYCR7b3JpZ2lufV8ke3N5bm9ueW1OYW1lIHx8IG5hbWV9YDtcblxuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnQXJyYXkoMiknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zdCBpc0lucHV0ID0gdGhpcy5pc0lucHV0KHN5bm9ueW1OYW1lIHx8IG5hbWUpO1xuXHRcdFx0XHRyZXRBcnIucHVzaChgJHsgbWFya3VwTmFtZSB9YCk7XG5cdFx0XHRcdGlmICh6UHJvcGVydHkgJiYgeVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0aWYgKGlzSW5wdXQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSB0aGlzLmFyZ3VtZW50U2l6ZXNbdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YobmFtZSldO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1soJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoelByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goYCokeyBzaXplWzFdICogc2l6ZVswXX0pKyhgKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChgKiR7IHNpemVbMF0gfSkrYCk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ10nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh6UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh5UHJvcGVydHkpIHtcblx0XHRcdFx0XHRpZiAoaXNJbnB1dCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuYXJndW1lbnRTaXplc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihuYW1lKV07XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnWygnKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChgKiR7IHNpemVbMF0gfSkrYCk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ10nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnWycpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ10nKTtcblx0XHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpjYWxsKiBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zICB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdGlmIChhc3QuY2FsbGVlKSB7XG5cdFx0XHQvLyBHZXQgdGhlIGZ1bGwgZnVuY3Rpb24gY2FsbCwgdW5yb2xsZWRcblx0XHRcdGxldCBmdW5jTmFtZSA9IHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QuY2FsbGVlKTtcblxuXHRcdFx0Ly8gUmVnaXN0ZXIgdGhlIGZ1bmN0aW9uIGludG8gdGhlIGNhbGxlZCByZWdpc3RyeVxuXHRcdFx0aWYgKHRoaXMuY2FsbGVkRnVuY3Rpb25zLmluZGV4T2YoZnVuY05hbWUpIDwgMCkge1xuXHRcdFx0XHR0aGlzLmNhbGxlZEZ1bmN0aW9ucy5wdXNoKGZ1bmNOYW1lKTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5jYWxsZWRGdW5jdGlvbnNBcmd1bWVudHNbZnVuY05hbWVdKSB7XG5cdFx0XHRcdHRoaXMuY2FsbGVkRnVuY3Rpb25zQXJndW1lbnRzW2Z1bmNOYW1lXSA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmdW5jdGlvbkFyZ3VtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5jYWxsZWRGdW5jdGlvbnNBcmd1bWVudHNbZnVuY05hbWVdLnB1c2goZnVuY3Rpb25Bcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBDYWxsIHRoZSBmdW5jdGlvblxuXHRcdFx0cmV0QXJyLnB1c2goZnVuY05hbWUpO1xuXG5cdFx0XHQvLyBPcGVuIGFyZ3VtZW50cyBzcGFjZVxuXHRcdFx0cmV0QXJyLnB1c2goJygnKTtcblxuXHRcdFx0Ly8gQWRkIHRoZSB2YXJzXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5hcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgYXJndW1lbnQgPSBhc3QuYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnLCAnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG5cdFx0XHRcdGlmIChhcmd1bWVudFR5cGUpIHtcblx0XHRcdFx0XHRmdW5jdGlvbkFyZ3VtZW50cy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6IGFyZ3VtZW50Lm5hbWUgfHwgbnVsbCxcblx0XHRcdFx0XHRcdHR5cGU6IGFyZ3VtZW50VHlwZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZ1bmN0aW9uQXJndW1lbnRzLnB1c2gobnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xvc2UgYXJndW1lbnRzIHNwYWNlXG5cdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8vIEZhaWx1cmUsIHVua25vd24gZXhwcmVzc2lvblxuXHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG5cdFx0XHQnVW5rbm93biBDYWxsRXhwcmVzc2lvbicsXG5cdFx0XHRhc3Rcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpBcnJheSogRXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJyTm9kZSAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0QXJyYXlFeHByZXNzaW9uKGFyck5vZGUsIHJldEFycikge1xuXHRcdGNvbnN0IGFyckxlbiA9IGFyck5vZGUuZWxlbWVudHMubGVuZ3RoO1xuXG5cdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyckxlbjsgKytpKSB7XG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goJywgJyk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBzdWJOb2RlID0gYXJyTm9kZS5lbGVtZW50c1tpXTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhzdWJOb2RlLCByZXRBcnIpXG5cdFx0fVxuXHRcdHJldEFyci5wdXNoKCddJyk7XG5cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0YXN0RGVidWdnZXJTdGF0ZW1lbnQoYXJyTm9kZSwgcmV0QXJyKSB7XG5cdFx0cmV0QXJyLnB1c2goJ2RlYnVnZ2VyOycpO1xuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdENQVUZ1bmN0aW9uTm9kZVxufTsiLCJjb25zdCB7XG5cdHV0aWxzXG59ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHtcblx0a2VybmVsUnVuU2hvcnRjdXRcbn0gPSByZXF1aXJlKCcuLi8uLi9rZXJuZWwtcnVuLXNob3J0Y3V0Jyk7XG5cbmZ1bmN0aW9uIHJlbW92ZUZuTm9pc2UoZm4pIHtcblx0aWYgKC9eZnVuY3Rpb24gLy50ZXN0KGZuKSkge1xuXHRcdGZuID0gZm4uc3Vic3RyaW5nKDkpO1xuXHR9XG5cdHJldHVybiBmbi5yZXBsYWNlKC9bX110eXBlb2YvZywgJ3R5cGVvZicpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2lzZShzdHIpIHtcblx0cmV0dXJuIHN0clxuXHRcdC5yZXBsYWNlKC9eW0EtWmEtel0rLywgJ2Z1bmN0aW9uJylcblx0XHQucmVwbGFjZSgvW19ddHlwZW9mL2csICd0eXBlb2YnKTtcbn1cblxuZnVuY3Rpb24gY3B1S2VybmVsU3RyaW5nKGNwdUtlcm5lbCwgbmFtZSkge1xuXHRyZXR1cm4gYCgpID0+IHtcbiAgICAkeyBrZXJuZWxSdW5TaG9ydGN1dC50b1N0cmluZygpIH07XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICBhbGxQcm9wZXJ0aWVzT2Y6ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmFsbFByb3BlcnRpZXNPZi50b1N0cmluZygpKSB9LFxuICAgICAgY2xvbmU6ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmNsb25lLnRvU3RyaW5nKCkpIH0sXG4gICAgfTtcbiAgICBsZXQgSW5wdXQgPSBmdW5jdGlvbigpIHt9O1xuICAgIGNsYXNzICR7IG5hbWUgfHwgJ0tlcm5lbCcgfSB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHsgICAgICAgIFxuICAgICAgICB0aGlzLmFyZ3VtZW50c0xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5idWlsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmFyZ3VtZW50TmFtZXMgPSAkeyBKU09OLnN0cmluZ2lmeShjcHVLZXJuZWwuYXJndW1lbnROYW1lcykgfTtcbiAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzID0gJHsgSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLmFyZ3VtZW50VHlwZXMpIH07XG4gICAgICAgIHRoaXMuYXJndW1lbnRTaXplcyA9ICR7IEpTT04uc3RyaW5naWZ5KGNwdUtlcm5lbC5hcmd1bWVudFNpemVzKSB9O1xuICAgICAgICB0aGlzLm91dHB1dCA9ICR7IEpTT04uc3RyaW5naWZ5KGNwdUtlcm5lbC5vdXRwdXQpIH07XG4gICAgICAgIHRoaXMuX2tlcm5lbFN0cmluZyA9IFxcYCR7IGNwdUtlcm5lbC5fa2VybmVsU3RyaW5nIH1cXGA7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gJHsgSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLm91dHB1dCkgfTtcblx0XHQgICAgdGhpcy5ydW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnJ1biA9IG51bGw7XG4gICAgICAgICAgdGhpcy5idWlsZChhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnJ1bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGhyZWFkID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB6OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzZXRDYW52YXMoY2FudmFzKSB7IHRoaXMuY2FudmFzID0gY2FudmFzOyByZXR1cm4gdGhpczsgfVxuICAgICAgc2V0Q29udGV4dChjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9XG4gICAgICBzZXRJbnB1dChUeXBlKSB7IElucHV0ID0gVHlwZTsgfVxuICAgICAgJHsgcmVtb3ZlRm5Ob2lzZShjcHVLZXJuZWwuYnVpbGQudG9TdHJpbmcoKSkgfVxuICAgICAgc2V0dXBBcmd1bWVudHMoKSB7fVxuICAgICAgJHsgcmVtb3ZlRm5Ob2lzZShjcHVLZXJuZWwuc2V0dXBDb25zdGFudHMudG9TdHJpbmcoKSkgfVxuICAgICAgdHJhbnNsYXRlU291cmNlKCkge31cbiAgICAgIHBpY2tSZW5kZXJTdHJhdGVneSgpIHt9XG4gICAgICBydW4gKCkgeyAkeyBjcHVLZXJuZWwua2VybmVsU3RyaW5nIH0gfVxuICAgICAgZ2V0S2VybmVsU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fa2VybmVsU3RyaW5nOyB9XG4gICAgICAkeyByZW1vdmVGbk5vaXNlKGNwdUtlcm5lbC52YWxpZGF0ZVNldHRpbmdzLnRvU3RyaW5nKCkpIH1cbiAgICAgICR7IHJlbW92ZUZuTm9pc2UoY3B1S2VybmVsLmNoZWNrT3V0cHV0LnRvU3RyaW5nKCkpIH1cbiAgICB9O1xuICAgIHJldHVybiBrZXJuZWxSdW5TaG9ydGN1dChuZXcgS2VybmVsKCkpO1xuICB9O2A7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcHVLZXJuZWxTdHJpbmdcbn07IiwiY29uc3Qge1xuXHRLZXJuZWxcbn0gPSByZXF1aXJlKCcuLi9rZXJuZWwnKTtcbmNvbnN0IHtcblx0RnVuY3Rpb25CdWlsZGVyXG59ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3Qge1xuXHRDUFVGdW5jdGlvbk5vZGVcbn0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHtcblx0dXRpbHNcbn0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3Qge1xuXHRjcHVLZXJuZWxTdHJpbmdcbn0gPSByZXF1aXJlKCcuL2tlcm5lbC1zdHJpbmcnKTtcblxuLyoqXG4gKiBAZGVzYyBLZXJuZWwgSW1wbGVtZW50YXRpb24gZm9yIENQVS5cbiAqIDxwPkluc3RhbnRpYXRlcyBwcm9wZXJ0aWVzIHRvIHRoZSBDUFUgS2VybmVsLjwvcD5cbiAqL1xuY2xhc3MgQ1BVS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcblx0c3RhdGljIGdldEZlYXR1cmVzKCkge1xuXHRcdHJldHVybiB0aGlzLmZlYXR1cmVzO1xuXHR9XG5cdHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoe1xuXHRcdFx0a2VybmVsTWFwOiB0cnVlLFxuXHRcdFx0aXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTogdHJ1ZVxuXHRcdH0pO1xuXHR9XG5cdHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0c3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0LyoqXG5cdCAqIEBkZXNjIFRoZSBjdXJyZW50IG1vZGUgaW4gd2hpY2ggZ3B1LmpzIGlzIGV4ZWN1dGluZy5cblx0ICovXG5cdHN0YXRpYyBnZXQgbW9kZSgpIHtcblx0XHRyZXR1cm4gJ2NwdSc7XG5cdH1cblxuXHRzdGF0aWMgbmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRzdGF0aWMgbmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0c3RhdGljIGNvbWJpbmVLZXJuZWxzKGNvbWJpbmVkS2VybmVsKSB7XG5cdFx0cmV0dXJuIGNvbWJpbmVkS2VybmVsO1xuXHR9XG5cblx0Y29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuXHRcdHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuXHRcdHRoaXMubWVyZ2VTZXR0aW5ncyhzb3VyY2Uuc2V0dGluZ3MgfHwgc2V0dGluZ3MpO1xuXG5cdFx0dGhpcy5faW1hZ2VEYXRhID0gbnVsbDtcblx0XHR0aGlzLl9jb2xvckRhdGEgPSBudWxsO1xuXHRcdHRoaXMuX2tlcm5lbFN0cmluZyA9IG51bGw7XG5cdFx0dGhpcy50aHJlYWQgPSB7XG5cdFx0XHR4OiAwLFxuXHRcdFx0eTogMCxcblx0XHRcdHo6IDBcblx0XHR9O1xuXHRcdHRoaXMudHJhbnNsYXRlZFNvdXJjZXMgPSBudWxsO1xuXHRcdHRoaXMucnVuID0gZnVuY3Rpb24oKSB7IC8vbm90ZTogbmVlZCBhcmd1bWVudHNcblx0XHRcdHRoaXMucnVuID0gbnVsbDtcblx0XHRcdHRoaXMuYnVpbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiB0aGlzLnJ1bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0uYmluZCh0aGlzKTtcblx0fVxuXG5cdGluaXRDYW52YXMoKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcblx0XHR9XG5cdH1cblxuXHRpbml0Q29udGV4dCgpIHtcblx0XHRpZiAoIXRoaXMuY2FudmFzKSByZXR1cm4gbnVsbDtcblx0XHRyZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0fVxuXG5cdGluaXRQbHVnaW5zKHNldHRpbmdzKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFZhbGlkYXRlIHNldHRpbmdzIHJlbGF0ZWQgdG8gQ1BVIEtlcm5lbCwgc3VjaCBhc1xuXHQgKiBkaW1lbnNpb25zIHNpemUsIGFuZCBhdXRvIGRpbWVuc2lvbiBzdXBwb3J0LlxuXHQgKi9cblx0dmFsaWRhdGVTZXR0aW5ncygpIHtcblx0XHRpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcblx0XHRcdFx0dGhyb3cgJ0F1dG8gZGltZW5zaW9ucyBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmd1bWVudHNbMF0pO1xuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdBcnJheScpIHtcblx0XHRcdFx0dGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnTnVtYmVyVGV4dHVyZScgfHwgYXJnVHlwZSA9PT0gJ0FycmF5VGV4dHVyZSg0KScpIHtcblx0XHRcdFx0dGhpcy5vdXRwdXQgPSBhcmd1bWVudHNbMF0ub3V0cHV0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgJ0F1dG8gZGltZW5zaW9ucyBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdGlmICh0aGlzLm91dHB1dC5sZW5ndGggIT09IDIpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgbXVzdCBoYXZlIDIgZGltZW5zaW9ucyBvbiBncmFwaGljYWwgbW9kZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuY2hlY2tPdXRwdXQoKTtcblx0fVxuXG5cdHRyYW5zbGF0ZVNvdXJjZSgpIHtcblx0XHR0aGlzLmxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQgPSB0aGlzLm91dHB1dC5sZW5ndGggPiAxID8gJ3Jlc3VsdFhbeF0gPSAnIDogJ3Jlc3VsdFt4XSA9ICc7XG5cdFx0aWYgKHRoaXMuc3ViS2VybmVscykge1xuXHRcdFx0Y29uc3QgZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50ID0gW11cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRuYW1lXG5cdFx0XHRcdH0gPSB0aGlzLnN1Yktlcm5lbHNbaV07XG5cdFx0XHRcdGZvbGxvd2luZ1JldHVyblN0YXRlbWVudC5wdXNoKHRoaXMub3V0cHV0Lmxlbmd0aCA+IDEgPyBgcmVzdWx0WF8keyBuYW1lIH1beF0gPSBzdWJLZXJuZWxSZXN1bHRfJHsgbmFtZSB9O1xcbmAgOiBgcmVzdWx0XyR7IG5hbWUgfVt4XSA9IHN1Yktlcm5lbFJlc3VsdF8keyBuYW1lIH07XFxuYCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IGZvbGxvd2luZ1JldHVyblN0YXRlbWVudC5qb2luKCcnKTtcblx0XHR9XG5cdFx0Y29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgQ1BVRnVuY3Rpb25Ob2RlKTtcblx0XHR0aGlzLnRyYW5zbGF0ZWRTb3VyY2VzID0gZnVuY3Rpb25CdWlsZGVyLmdldFByb3RvdHlwZXMoJ2tlcm5lbCcpO1xuXHRcdGlmICghdGhpcy5ncmFwaGljYWwgJiYgIXRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0dGhpcy5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldEtlcm5lbFJlc3VsdFR5cGUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgQnVpbGRzIHRoZSBLZXJuZWwsIGJ5IGdlbmVyYXRpbmcgdGhlIGtlcm5lbFxuXHQgKiBzdHJpbmcgdXNpbmcgdGhyZWFkIGRpbWVuc2lvbnMsIGFuZCBhcmd1bWVudHNcblx0ICogc3VwcGxpZWQgdG8gdGhlIGtlcm5lbC5cblx0ICpcblx0ICogPHA+SWYgdGhlIGdyYXBoaWNhbCBmbGFnIGlzIGVuYWJsZWQsIGNhbnZhcyBpcyB1c2VkLjwvcD5cblx0ICovXG5cdGJ1aWxkKCkge1xuXHRcdHRoaXMuc2V0dXBDb25zdGFudHMoKTtcblx0XHR0aGlzLnNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy52YWxpZGF0ZVNldHRpbmdzKCk7XG5cdFx0dGhpcy50cmFuc2xhdGVTb3VyY2UoKTtcblxuXHRcdGlmICh0aGlzLmdyYXBoaWNhbCkge1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRjYW52YXMsXG5cdFx0XHRcdG91dHB1dFxuXHRcdFx0fSA9IHRoaXM7XG5cdFx0XHRpZiAoIWNhbnZhcykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ25vIGNhbnZhcyBhdmFpbGFibGUgZm9yIHVzaW5nIGdyYXBoaWNhbCBvdXRwdXQnKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHdpZHRoID0gb3V0cHV0WzBdO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gb3V0cHV0WzFdIHx8IDE7XG5cdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR0aGlzLl9pbWFnZURhdGEgPSB0aGlzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5fY29sb3JEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga2VybmVsU3RyaW5nID0gdGhpcy5nZXRLZXJuZWxTdHJpbmcoKTtcblx0XHR0aGlzLmtlcm5lbFN0cmluZyA9IGtlcm5lbFN0cmluZztcblxuXHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnRnVuY3Rpb24gb3V0cHV0OicpO1xuXHRcdFx0Y29uc29sZS5sb2coa2VybmVsU3RyaW5nKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5ydW4gPSBuZXcgRnVuY3Rpb24oW10sIGtlcm5lbFN0cmluZykuYmluZCh0aGlzKSgpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgamF2YXNjcmlwdDogJywgZSk7XG5cdFx0fVxuXHR9XG5cblx0Y29sb3IociwgZywgYiwgYSkge1xuXHRcdGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGEgPSAxO1xuXHRcdH1cblxuXHRcdHIgPSBNYXRoLmZsb29yKHIgKiAyNTUpO1xuXHRcdGcgPSBNYXRoLmZsb29yKGcgKiAyNTUpO1xuXHRcdGIgPSBNYXRoLmZsb29yKGIgKiAyNTUpO1xuXHRcdGEgPSBNYXRoLmZsb29yKGEgKiAyNTUpO1xuXG5cdFx0Y29uc3Qgd2lkdGggPSB0aGlzLm91dHB1dFswXTtcblx0XHRjb25zdCBoZWlnaHQgPSB0aGlzLm91dHB1dFsxXTtcblxuXHRcdGNvbnN0IHggPSB0aGlzLnRocmVhZC54O1xuXHRcdGNvbnN0IHkgPSBoZWlnaHQgLSB0aGlzLnRocmVhZC55IC0gMTtcblxuXHRcdGNvbnN0IGluZGV4ID0geCArIHkgKiB3aWR0aDtcblxuXHRcdHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAwXSA9IHI7XG5cdFx0dGhpcy5fY29sb3JEYXRhW2luZGV4ICogNCArIDFdID0gZztcblx0XHR0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMl0gPSBiO1xuXHRcdHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAzXSA9IGE7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2VuZXJhdGVzIGtlcm5lbCBzdHJpbmcgZm9yIHRoaXMga2VybmVsIHByb2dyYW0uXG5cdCAqXG5cdCAqIDxwPklmIHN1Yi1rZXJuZWxzIGFyZSBzdXBwbGllZCwgdGhleSBhcmUgYWxzbyBmYWN0b3JlZCBpbi5cblx0ICogVGhpcyBzdHJpbmcgY2FuIGJlIHNhdmVkIGJ5IGNhbGxpbmcgdGhlIGB0b1N0cmluZ2AgbWV0aG9kXG5cdCAqIGFuZCB0aGVuIGNhbiBiZSByZXVzZWQgbGF0ZXIuPC9wPlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcblx0ICpcblx0ICovXG5cdGdldEtlcm5lbFN0cmluZygpIHtcblx0XHRpZiAodGhpcy5fa2VybmVsU3RyaW5nICE9PSBudWxsKSByZXR1cm4gdGhpcy5fa2VybmVsU3RyaW5nO1xuXG5cdFx0bGV0IGtlcm5lbFRocmVhZFN0cmluZyA9IG51bGw7XG5cdFx0bGV0IHtcblx0XHRcdHRyYW5zbGF0ZWRTb3VyY2VzXG5cdFx0fSA9IHRoaXM7XG5cdFx0aWYgKHRyYW5zbGF0ZWRTb3VyY2VzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRyYW5zbGF0ZWRTb3VyY2VzID0gdHJhbnNsYXRlZFNvdXJjZXMuZmlsdGVyKGZuID0+IHtcblx0XHRcdFx0aWYgKC9eZnVuY3Rpb24vLnRlc3QoZm4pKSByZXR1cm4gZm47XG5cdFx0XHRcdGtlcm5lbFRocmVhZFN0cmluZyA9IGZuO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRrZXJuZWxUaHJlYWRTdHJpbmcgPSB0cmFuc2xhdGVkU291cmNlcy5zaGlmdCgpO1xuXHRcdH1cblx0XHRjb25zdCBrZXJuZWxTdHJpbmcgPSB0aGlzLl9rZXJuZWxTdHJpbmcgPSBgICBjb25zdCBMT09QX01BWCA9ICR7IHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSB9XG4gIGNvbnN0IGNvbnN0YW50cyA9IHRoaXMuY29uc3RhbnRzO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHJldHVybiAoJHsgdGhpcy5hcmd1bWVudE5hbWVzLm1hcChhcmd1bWVudE5hbWUgPT4gJ3VzZXJfJyArIGFyZ3VtZW50TmFtZSkuam9pbignLCAnKSB9KSA9PiB7XG4gICAgJHsgdGhpcy5fcHJvY2Vzc0NvbnN0YW50cygpIH1cbiAgICAkeyB0aGlzLl9wcm9jZXNzQXJndW1lbnRzKCkgfVxuICAgICR7IHRoaXMuZ3JhcGhpY2FsID8gdGhpcy5fZ3JhcGhpY2FsS2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIDogdGhpcy5fcmVzdWx0S2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIH1cbiAgICAkeyB0cmFuc2xhdGVkU291cmNlcy5sZW5ndGggPiAwID8gdHJhbnNsYXRlZFNvdXJjZXMuam9pbignXFxuJykgOiAnJyB9XG4gIH07YDtcblx0XHRyZXR1cm4ga2VybmVsU3RyaW5nO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFJldHVybnMgdGhlICpwcmUtY29tcGlsZWQqIEtlcm5lbCBhcyBhIEpTIE9iamVjdCBTdHJpbmcsIHRoYXQgY2FuIGJlIHJldXNlZC5cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBjcHVLZXJuZWxTdHJpbmcodGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IHRoZSBtYXhpbXVtIGxvb3Agc2l6ZSBTdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuXHQgKi9cblx0X2dldExvb3BNYXhTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgP1xuXHRcdFx0YCAkeyBwYXJzZUludCh0aGlzLmxvb3BNYXhJdGVyYXRpb25zKSB9O2AgOlxuXHRcdFx0JyAxMDAwOydcblx0XHQpO1xuXHR9XG5cblx0X3Byb2Nlc3NDb25zdGFudHMoKSB7XG5cdFx0aWYgKCF0aGlzLmNvbnN0YW50cykgcmV0dXJuICcnO1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cdFx0Zm9yIChsZXQgcCBpbiB0aGlzLmNvbnN0YW50cykge1xuXHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuY29uc3RhbnRUeXBlc1twXTtcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9pbWFnZVRvMkRBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9pbWFnZVRvM0RBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnSW5wdXQnOlxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9LnZhbHVlO1xcbmApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9O1xcbmApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuXHR9XG5cblx0X3Byb2Nlc3NBcmd1bWVudHMoKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHN3aXRjaCAodGhpcy5hcmd1bWVudFR5cGVzW2ldKSB7XG5cdFx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYCAgICB1c2VyXyR7dGhpcy5hcmd1bWVudE5hbWVzW2ldfSA9IHRoaXMuX2ltYWdlVG8yREFycmF5KHVzZXJfJHt0aGlzLmFyZ3VtZW50TmFtZXNbaV19KTtcXG5gKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGAgICAgdXNlcl8ke3RoaXMuYXJndW1lbnROYW1lc1tpXX0gPSB0aGlzLl9pbWFnZVRvM0RBcnJheSh1c2VyXyR7dGhpcy5hcmd1bWVudE5hbWVzW2ldfSk7XFxuYCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0XHRyZXN1bHQucHVzaChgICAgIHVzZXJfJHt0aGlzLmFyZ3VtZW50TmFtZXNbaV19ID0gdXNlcl8ke3RoaXMuYXJndW1lbnROYW1lc1tpXX0udmFsdWU7XFxuYCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQuam9pbignJyk7XG5cdH1cblxuXHRfaW1hZ2VUbzJEQXJyYXkoaW1hZ2UpIHtcblx0XHRjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcblx0XHRpZiAoY2FudmFzLndpZHRoIDwgaW1hZ2Uud2lkdGgpIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoY2FudmFzLmhlaWdodCA8IGltYWdlLmhlaWdodCkge1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblx0XHR9XG5cdFx0Y29uc3QgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcdGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdGNvbnN0IHBpeGVsc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpLmRhdGE7XG5cdFx0Y29uc3QgaW1hZ2VBcnJheSA9IG5ldyBBcnJheShpbWFnZS5oZWlnaHQpO1xuXHRcdGxldCBpbmRleCA9IDA7XG5cdFx0Zm9yIChsZXQgeSA9IGltYWdlLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG5cdFx0XHRjb25zdCByb3cgPSBpbWFnZUFycmF5W3ldID0gbmV3IEFycmF5KGltYWdlLndpZHRoKTtcblx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgaW1hZ2Uud2lkdGg7IHgrKykge1xuXHRcdFx0XHRjb25zdCBwaXhlbCA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cdFx0XHRcdHBpeGVsWzBdID0gcGl4ZWxzRGF0YVtpbmRleCsrXSAvIDI1NTsgLy8gclxuXHRcdFx0XHRwaXhlbFsxXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IC8vIGdcblx0XHRcdFx0cGl4ZWxbMl0gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyAvLyBiXG5cdFx0XHRcdHBpeGVsWzNdID0gcGl4ZWxzRGF0YVtpbmRleCsrXSAvIDI1NTsgLy8gYVxuXHRcdFx0XHRyb3dbeF0gPSBwaXhlbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGltYWdlQXJyYXk7XG5cdH1cblxuXHRnZXRQaXhlbHMoKSB7XG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQxOTczMjg5LzEzMjQwMzlcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLm91dHB1dDtcblx0XHRjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMiB8IDA7IC8vIHRoZSB8IDAga2VlcHMgdGhlIHJlc3VsdCBhbiBpbnRcblx0XHRjb25zdCBieXRlc1BlclJvdyA9IHdpZHRoICogNDtcblx0XHQvLyBtYWtlIGEgdGVtcCBidWZmZXIgdG8gaG9sZCBvbmUgcm93XG5cdFx0Y29uc3QgdGVtcCA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogNCk7XG5cdFx0Y29uc3QgcGl4ZWxzID0gdGhpcy5faW1hZ2VEYXRhLmRhdGEuc2xpY2UoMCk7XG5cdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCBoYWxmSGVpZ2h0OyArK3kpIHtcblx0XHRcdHZhciB0b3BPZmZzZXQgPSB5ICogYnl0ZXNQZXJSb3c7XG5cdFx0XHR2YXIgYm90dG9tT2Zmc2V0ID0gKGhlaWdodCAtIHkgLSAxKSAqIGJ5dGVzUGVyUm93O1xuXG5cdFx0XHQvLyBtYWtlIGNvcHkgb2YgYSByb3cgb24gdGhlIHRvcCBoYWxmXG5cdFx0XHR0ZW1wLnNldChwaXhlbHMuc3ViYXJyYXkodG9wT2Zmc2V0LCB0b3BPZmZzZXQgKyBieXRlc1BlclJvdykpO1xuXG5cdFx0XHQvLyBjb3B5IGEgcm93IGZyb20gdGhlIGJvdHRvbSBoYWxmIHRvIHRoZSB0b3Bcblx0XHRcdHBpeGVscy5jb3B5V2l0aGluKHRvcE9mZnNldCwgYm90dG9tT2Zmc2V0LCBib3R0b21PZmZzZXQgKyBieXRlc1BlclJvdyk7XG5cblx0XHRcdC8vIGNvcHkgdGhlIGNvcHkgb2YgdGhlIHRvcCBoYWxmIHJvdyB0byB0aGUgYm90dG9tIGhhbGZcblx0XHRcdHBpeGVscy5zZXQodGVtcCwgYm90dG9tT2Zmc2V0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHBpeGVscztcblx0fVxuXG5cdF9pbWFnZVRvM0RBcnJheShpbWFnZXMpIHtcblx0XHRjb25zdCBpbWFnZXNBcnJheSA9IG5ldyBBcnJheShpbWFnZXMubGVuZ3RoKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aW1hZ2VzQXJyYXlbaV0gPSB0aGlzLl9pbWFnZVRvMkRBcnJheShpbWFnZXNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gaW1hZ2VzQXJyYXk7XG5cdH1cblxuXHRfcmVzdWx0S2VybmVsQm9keShrZXJuZWxTdHJpbmcpIHtcblx0XHRzd2l0Y2ggKHRoaXMub3V0cHV0Lmxlbmd0aCkge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVzdWx0S2VybmVsMURMb29wKGtlcm5lbFN0cmluZykgKyB0aGlzLl9rZXJuZWxPdXRwdXQoKTtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Jlc3VsdEtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpICsgdGhpcy5fa2VybmVsT3V0cHV0KCk7XG5cdFx0XHRjYXNlIDM6XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXN1bHRLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSArIHRoaXMuX2tlcm5lbE91dHB1dCgpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBzaXplIGtlcm5lbCcpO1xuXHRcdH1cblx0fVxuXG5cdF9ncmFwaGljYWxLZXJuZWxCb2R5KGtlcm5lbFRocmVhZFN0cmluZykge1xuXHRcdHN3aXRjaCAodGhpcy5vdXRwdXQubGVuZ3RoKSB7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHJldHVybiB0aGlzLl9ncmFwaGljYWxLZXJuZWwyRExvb3Aoa2VybmVsVGhyZWFkU3RyaW5nKSArIHRoaXMuX2dyYXBoaWNhbE91dHB1dCgpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBzaXplIGtlcm5lbCcpO1xuXHRcdH1cblx0fVxuXG5cdF9ncmFwaGljYWxPdXRwdXQoKSB7XG5cdFx0cmV0dXJuIGBcbiAgICB0aGlzLl9pbWFnZURhdGEuZGF0YS5zZXQodGhpcy5fY29sb3JEYXRhKTtcbiAgICB0aGlzLmNvbnRleHQucHV0SW1hZ2VEYXRhKHRoaXMuX2ltYWdlRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO2Bcblx0fVxuXG5cdF9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKSB7XG5cdFx0c3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcblx0XHRcdGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0cmV0dXJuICdGbG9hdDMyQXJyYXknO1xuXHRcdFx0Y2FzZSAnQXJyYXkoMiknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0XHRyZXR1cm4gJ0FycmF5Jztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGlmICh0aGlzLmdyYXBoaWNhbCkge1xuXHRcdFx0XHRcdHJldHVybiAnRmxvYXQzMkFycmF5Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCByZXR1cm5UeXBlICR7IHRoaXMucmV0dXJuVHlwZSB9YCk7XG5cdFx0fVxuXHR9XG5cblx0X3Jlc3VsdEtlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRvdXRwdXRcblx0XHR9ID0gdGhpcztcblx0XHRjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuXHRcdHJldHVybiBgY29uc3QgcmVzdWx0ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KCR7IG91dHB1dFswXSB9KTtcbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30oJHsgb3V0cHV0WzBdIH0pO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgJHsgb3V0cHV0WzBdIH07IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICB9YDtcblx0fVxuXG5cdF9yZXN1bHRLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0b3V0cHV0XG5cdFx0fSA9IHRoaXM7XG5cdFx0Y29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcblx0XHRyZXR1cm4gYGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSgkeyBvdXRwdXRbMV0gfSk7XG5cdFx0JHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KCR7IG91dHB1dFsxXSB9KTtcXG5gKS5qb2luKCcgICAgJykgfVxuXHRcdCR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8ICR7IG91dHB1dFsxXSB9OyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KCR7IG91dHB1dFswXSB9KTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30oJHsgb3V0cHV0WzBdIH0pO1xcbmApLmpvaW4oJycpIH1cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgJHsgb3V0cHV0WzBdIH07IHgrKykge1xuICAgICAgXHR0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcblx0fVxuXG5cdF9ncmFwaGljYWxLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0b3V0cHV0XG5cdFx0fSA9IHRoaXM7XG5cdFx0Y29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcblx0XHRyZXR1cm4gYCAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KCR7IG91dHB1dFsxXSB9KTtcXG5gKS5qb2luKCcgICAgJykgfVxuXHRcdCR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8ICR7IG91dHB1dFsxXSB9OyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WF8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KCR7IG91dHB1dFswXSB9KTtcXG5gKS5qb2luKCcnKSB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8ICR7IG91dHB1dFswXSB9OyB4KyspIHtcbiAgICAgIFx0dGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICB9XG4gICAgfWA7XG5cdH1cblxuXHRfcmVzdWx0S2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykge1xuXHRcdGNvbnN0IHtcblx0XHRcdG91dHB1dFxuXHRcdH0gPSB0aGlzO1xuXHRcdGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG5cdFx0cmV0dXJuIGBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoJHsgb3V0cHV0WzJdIH0pO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheSgkeyBvdXRwdXRbMl0gfSk7XFxuYCkuam9pbignICAgICcpIH1cbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgbGV0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9O1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCAkeyBvdXRwdXRbMl0gfTsgeisrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel0gPSBuZXcgQXJyYXkoJHsgb3V0cHV0WzFdIH0pO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFlfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt6XSA9IG5ldyBBcnJheSgkeyBvdXRwdXRbMV0gfSk7XFxuYCkuam9pbignICAgICAgJykgfVxuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCAkeyBvdXRwdXRbMV0gfTsgeSsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0WVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfSgkeyBvdXRwdXRbMF0gfSk7XG4gICAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRZXyR7c3ViS2VybmVsLm5hbWV9W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KCR7IG91dHB1dFswXSB9KTtcXG5gKS5qb2luKCcgICAgICAgICcpIH1cbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAkeyBvdXRwdXRbMF0gfTsgeCsrKSB7XG4gICAgICAgIFx0dGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1gO1xuXHR9XG5cblx0X2tlcm5lbE91dHB1dCgpIHtcblx0XHRpZiAoIXRoaXMuc3ViS2VybmVscykge1xuXHRcdFx0cmV0dXJuICdcXG4gICAgcmV0dXJuIHJlc3VsdDsnO1xuXHRcdH1cblx0XHRyZXR1cm4gYFxcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAkeyB0aGlzLnN1Yktlcm5lbHMubWFwKHN1Yktlcm5lbCA9PiBgJHsgc3ViS2VybmVsLnByb3BlcnR5IH06IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9YCkuam9pbignLFxcbiAgICAgICcpIH1cbiAgICB9O2A7XG5cdH1cblxuXHRfbWFwU3ViS2VybmVscyhmbikge1xuXHRcdHJldHVybiB0aGlzLnN1Yktlcm5lbHMgPT09IG51bGwgPyBbJyddIDpcblx0XHRcdHRoaXMuc3ViS2VybmVscy5tYXAoZm4pO1xuXHR9XG5cblxuXG5cdGRlc3Ryb3kocmVtb3ZlQ2FudmFzUmVmZXJlbmNlKSB7XG5cdFx0aWYgKHJlbW92ZUNhbnZhc1JlZmVyZW5jZSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuY2FudmFzO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7fVxuXG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG5cdFx0anNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgQ1BVRnVuY3Rpb25Ob2RlKS50b0pTT04oKTtcblx0XHRyZXR1cm4ganNvbjtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Q1BVS2VybmVsXG59OyIsIi8qKlxuICogQGRlc2MgVGhpcyBoYW5kbGVzIGFsbCB0aGUgcmF3IHN0YXRlLCBjb252ZXJ0ZWQgc3RhdGUsIGV0Yy4gb2YgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKiBbSU5URVJOQUxdIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbk5vZGVzLlxuICovXG5jbGFzcyBGdW5jdGlvbkJ1aWxkZXIge1xuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtLZXJuZWx9IGtlcm5lbFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uTm9kZX0gRnVuY3Rpb25Ob2RlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbZXh0cmFOb2RlT3B0aW9uc11cblx0ICogQHJldHVybnMgRnVuY3Rpb25CdWlsZGVyXG5cdCAqL1xuXHRzdGF0aWMgZnJvbUtlcm5lbChrZXJuZWwsIEZ1bmN0aW9uTm9kZSwgZXh0cmFOb2RlT3B0aW9ucykge1xuXHRcdGNvbnN0IHtcblx0XHRcdGFyZ3VtZW50TmFtZXMsXG5cdFx0XHRhcmd1bWVudFR5cGVzLFxuXHRcdFx0YXJndW1lbnRTaXplcyxcblx0XHRcdGFyZ3VtZW50Qml0UmF0aW9zLFxuXHRcdFx0Y29uc3RhbnRzLFxuXHRcdFx0Y29uc3RhbnRUeXBlcyxcblx0XHRcdGNvbnN0YW50Qml0UmF0aW9zLFxuXHRcdFx0ZGVidWcsXG5cdFx0XHRsb29wTWF4SXRlcmF0aW9ucyxcblx0XHRcdG5hdGl2ZUZ1bmN0aW9ucyxcblx0XHRcdG91dHB1dCxcblx0XHRcdG9wdGltaXplRmxvYXRNZW1vcnksXG5cdFx0XHRwcmVjaXNpb24sXG5cdFx0XHRwbHVnaW5zLFxuXHRcdFx0c291cmNlLFxuXHRcdFx0c3ViS2VybmVscyxcblx0XHRcdGZ1bmN0aW9ucyxcblx0XHRcdGxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQsXG5cdFx0XHRmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQsXG5cdFx0fSA9IGtlcm5lbDtcblxuXHRcdGNvbnN0IGxvb2t1cFJldHVyblR5cGUgPSAoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKSA9PiB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgbG9va3VwQXJndW1lbnRUeXBlID0gKGFyZ3VtZW50TmFtZSwgcmVxdWVzdGluZ05vZGUpID0+IHtcblx0XHRcdHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubG9va3VwQXJndW1lbnRUeXBlKGFyZ3VtZW50TmFtZSwgcmVxdWVzdGluZ05vZGUpO1xuXHRcdH07XG5cblx0XHRjb25zdCBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMgPSAoZnVuY3Rpb25OYW1lKSA9PiB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyhmdW5jdGlvbk5hbWUpO1xuXHRcdH07XG5cblx0XHRjb25zdCBsb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZSA9IChmdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpID0+IHtcblx0XHRcdHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUoZnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgbG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvID0gKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lKSA9PiB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyhmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSA9IChmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgcmVxdWVzdGluZ05vZGUpID0+IHtcblx0XHRcdGZ1bmN0aW9uQnVpbGRlci5hc3NpZ25Bcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHJlcXVlc3RpbmdOb2RlKTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgdHJpZ2dlclRyYWNrQXJndW1lbnRTeW5vbnltID0gKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpID0+IHtcblx0XHRcdGZ1bmN0aW9uQnVpbGRlci50cmFja0FyZ3VtZW50U3lub255bShmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgbG9va3VwQXJndW1lbnRTeW5vbnltID0gKG9yaWdpbkZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpID0+IHtcblx0XHRcdHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubG9va3VwQXJndW1lbnRTeW5vbnltKG9yaWdpbkZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpO1xuXHRcdH07XG5cblx0XHRjb25zdCBvbkZ1bmN0aW9uQ2FsbCA9IChmdW5jdGlvbk5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSkgPT4ge1xuXHRcdFx0ZnVuY3Rpb25CdWlsZGVyLnRyYWNrRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lKTtcblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25OZXN0ZWRGdW5jdGlvbiA9IChmblN0cmluZywgcmV0dXJuVHlwZSkgPT4ge1xuXHRcdFx0ZnVuY3Rpb25CdWlsZGVyLmFkZEZ1bmN0aW9uTm9kZShuZXcgRnVuY3Rpb25Ob2RlKGZuU3RyaW5nLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuXHRcdFx0XHRyZXR1cm5UeXBlOiByZXR1cm5UeXBlIHx8ICdOdW1iZXInLCAvLyBUT0RPOiBJIHRoaW5rIHRoaXMgbmVlZHMgcmVtb3ZlZFxuXHRcdFx0XHRsb29rdXBSZXR1cm5UeXBlLFxuXHRcdFx0XHRsb29rdXBBcmd1bWVudFR5cGUsXG5cdFx0XHRcdGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcblx0XHRcdFx0bG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUsXG5cdFx0XHRcdGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyxcblx0XHRcdFx0dHJpZ2dlckltcGx5QXJndW1lbnRUeXBlLFxuXHRcdFx0XHR0cmlnZ2VyVHJhY2tBcmd1bWVudFN5bm9ueW0sXG5cdFx0XHRcdGxvb2t1cEFyZ3VtZW50U3lub255bSxcblx0XHRcdFx0b25GdW5jdGlvbkNhbGxcblx0XHRcdH0pKSk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IG5vZGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRpc1Jvb3RLZXJuZWw6IGZhbHNlLFxuXHRcdFx0b25OZXN0ZWRGdW5jdGlvbixcblx0XHRcdGxvb2t1cFJldHVyblR5cGUsXG5cdFx0XHRsb29rdXBBcmd1bWVudFR5cGUsXG5cdFx0XHRsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG5cdFx0XHRsb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZSxcblx0XHRcdGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyxcblx0XHRcdHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcblx0XHRcdHRyaWdnZXJUcmFja0FyZ3VtZW50U3lub255bSxcblx0XHRcdGxvb2t1cEFyZ3VtZW50U3lub255bSxcblx0XHRcdG9uRnVuY3Rpb25DYWxsLFxuXHRcdFx0b3B0aW1pemVGbG9hdE1lbW9yeSxcblx0XHRcdHByZWNpc2lvbixcblx0XHRcdGNvbnN0YW50cyxcblx0XHRcdGNvbnN0YW50VHlwZXMsXG5cdFx0XHRjb25zdGFudEJpdFJhdGlvcyxcblx0XHRcdGRlYnVnLFxuXHRcdFx0bG9vcE1heEl0ZXJhdGlvbnMsXG5cdFx0XHRvdXRwdXQsXG5cdFx0XHRwbHVnaW5zLFxuXHRcdH0sIGV4dHJhTm9kZU9wdGlvbnMgfHwge30pO1xuXG5cdFx0Y29uc3Qgcm9vdE5vZGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZU9wdGlvbnMsIHtcblx0XHRcdGlzUm9vdEtlcm5lbDogdHJ1ZSxcblx0XHRcdG5hbWU6ICdrZXJuZWwnLFxuXHRcdFx0YXJndW1lbnROYW1lcyxcblx0XHRcdGFyZ3VtZW50VHlwZXMsXG5cdFx0XHRhcmd1bWVudFNpemVzLFxuXHRcdFx0YXJndW1lbnRCaXRSYXRpb3MsXG5cdFx0XHRsZWFkaW5nUmV0dXJuU3RhdGVtZW50LFxuXHRcdFx0Zm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LFxuXHRcdH0pO1xuXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmIHNvdXJjZS5mdW5jdGlvbk5vZGVzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uQnVpbGRlcigpLmZyb21KU09OKHNvdXJjZS5mdW5jdGlvbk5vZGVzLCBGdW5jdGlvbk5vZGUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJvb3ROb2RlID0gbmV3IEZ1bmN0aW9uTm9kZShzb3VyY2UsIHJvb3ROb2RlT3B0aW9ucyk7XG5cblx0XHRsZXQgZnVuY3Rpb25Ob2RlcyA9IG51bGw7XG5cdFx0aWYgKGZ1bmN0aW9ucykge1xuXHRcdFx0ZnVuY3Rpb25Ob2RlcyA9IGZ1bmN0aW9ucy5tYXAoKGZuKSA9PiBuZXcgRnVuY3Rpb25Ob2RlKGZuLnNvdXJjZSwge1xuXHRcdFx0XHRyZXR1cm5UeXBlOiBmbi5yZXR1cm5UeXBlLFxuXHRcdFx0XHRhcmd1bWVudFR5cGVzOiBmbi5hcmd1bWVudFR5cGVzLFxuXHRcdFx0XHRvdXRwdXQsXG5cdFx0XHRcdHBsdWdpbnMsXG5cdFx0XHRcdGNvbnN0YW50cyxcblx0XHRcdFx0Y29uc3RhbnRUeXBlcyxcblx0XHRcdFx0Y29uc3RhbnRCaXRSYXRpb3MsXG5cdFx0XHRcdG9wdGltaXplRmxvYXRNZW1vcnksXG5cdFx0XHRcdHByZWNpc2lvbixcblx0XHRcdFx0bG9va3VwUmV0dXJuVHlwZSxcblx0XHRcdFx0bG9va3VwQXJndW1lbnRUeXBlLFxuXHRcdFx0XHRsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG5cdFx0XHRcdGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuXHRcdFx0XHRsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8sXG5cdFx0XHRcdHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcblx0XHRcdFx0dHJpZ2dlclRyYWNrQXJndW1lbnRTeW5vbnltLFxuXHRcdFx0XHRsb29rdXBBcmd1bWVudFN5bm9ueW0sXG5cdFx0XHRcdG9uRnVuY3Rpb25DYWxsLFxuXHRcdFx0fSkpO1xuXHRcdH1cblxuXHRcdGxldCBzdWJLZXJuZWxOb2RlcyA9IG51bGw7XG5cdFx0aWYgKHN1Yktlcm5lbHMpIHtcblx0XHRcdHN1Yktlcm5lbE5vZGVzID0gc3ViS2VybmVscy5tYXAoKHN1Yktlcm5lbCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7XG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRzb3VyY2Vcblx0XHRcdFx0fSA9IHN1Yktlcm5lbDtcblx0XHRcdFx0cmV0dXJuIG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0aXNTdWJLZXJuZWw6IHRydWUsXG5cdFx0XHRcdFx0aXNSb290S2VybmVsOiBmYWxzZSxcblx0XHRcdFx0XHRyZXR1cm5UeXBlOiAnTnVtYmVyJywgLy8gVE9ETzogSSB0aGluayB0aGlzIG5lZWRzIHJlbW92ZWRcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZnVuY3Rpb25CdWlsZGVyID0gbmV3IEZ1bmN0aW9uQnVpbGRlcih7XG5cdFx0XHRrZXJuZWwsXG5cdFx0XHRyb290Tm9kZSxcblx0XHRcdGZ1bmN0aW9uTm9kZXMsXG5cdFx0XHRuYXRpdmVGdW5jdGlvbnMsXG5cdFx0XHRzdWJLZXJuZWxOb2Rlc1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uQnVpbGRlcjtcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0lGdW5jdGlvbkJ1aWxkZXJTZXR0aW5nc30gW3NldHRpbmdzXVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcblx0XHRzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuXHRcdHRoaXMua2VybmVsID0gc2V0dGluZ3Mua2VybmVsO1xuXHRcdHRoaXMucm9vdE5vZGUgPSBzZXR0aW5ncy5yb290Tm9kZTtcblx0XHR0aGlzLmZ1bmN0aW9uTm9kZXMgPSBzZXR0aW5ncy5mdW5jdGlvbk5vZGVzIHx8IFtdO1xuXHRcdHRoaXMuc3ViS2VybmVsTm9kZXMgPSBzZXR0aW5ncy5zdWJLZXJuZWxOb2RlcyB8fCBbXTtcblx0XHR0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucyB8fCBbXTtcblx0XHR0aGlzLmZ1bmN0aW9uTWFwID0ge307XG5cdFx0dGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzID0gW107XG5cdFx0dGhpcy5sb29rdXBDaGFpbiA9IFtdO1xuXHRcdHRoaXMuYXJndW1lbnRDaGFpbiA9IFtdO1xuXHRcdHRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzID0ge307XG5cblx0XHRpZiAodGhpcy5yb290Tm9kZSkge1xuXHRcdFx0dGhpcy5mdW5jdGlvbk1hcFsna2VybmVsJ10gPSB0aGlzLnJvb3ROb2RlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmZ1bmN0aW9uTm9kZXMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mdW5jdGlvbk5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuZnVuY3Rpb25NYXBbdGhpcy5mdW5jdGlvbk5vZGVzW2ldLm5hbWVdID0gdGhpcy5mdW5jdGlvbk5vZGVzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLnN1Yktlcm5lbE5vZGVzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVsTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5mdW5jdGlvbk1hcFt0aGlzLnN1Yktlcm5lbE5vZGVzW2ldLm5hbWVdID0gdGhpcy5zdWJLZXJuZWxOb2Rlc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5uYXRpdmVGdW5jdGlvbnMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgbmF0aXZlRnVuY3Rpb24gPSB0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXTtcblx0XHRcdFx0dGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLnB1c2gobmF0aXZlRnVuY3Rpb24ubmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEFkZCB0aGUgZnVuY3Rpb24gbm9kZSBkaXJlY3RseVxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uTm9kZX0gZnVuY3Rpb25Ob2RlIC0gZnVuY3Rpb25Ob2RlIHRvIGFkZFxuXHQgKlxuXHQgKi9cblx0YWRkRnVuY3Rpb25Ob2RlKGZ1bmN0aW9uTm9kZSkge1xuXHRcdHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25Ob2RlLm5hbWVdID0gZnVuY3Rpb25Ob2RlO1xuXHRcdGlmIChmdW5jdGlvbk5vZGUuaXNSb290S2VybmVsKSB7XG5cdFx0XHR0aGlzLnJvb3ROb2RlID0gZnVuY3Rpb25Ob2RlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBUcmFjZSBhbGwgdGhlIGRlcGVuZGluZyBmdW5jdGlvbnMgYmVpbmcgY2FsbGVkLCBmcm9tIGEgc2luZ2xlIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIFRoaXMgYWxsb3cgZm9yICd1bm5lZWRlZCcgZnVuY3Rpb25zIHRvIGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkIG91dC5cblx0ICogTm90ZSB0aGF0IHRoZSAwLWluZGV4LCBpcyB0aGUgc3RhcnRpbmcgZnVuY3Rpb24gdHJhY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jdGlvbk5hbWUgLSBGdW5jdGlvbiBuYW1lIHRvIHRyYWNlIGZyb20sIGRlZmF1bHQgdG8gJ2tlcm5lbCdcblx0ICogQHBhcmFtIHtTdHJpbmdbXX0gW3JldExpc3RdIC0gUmV0dXJuaW5nIGxpc3Qgb2YgZnVuY3Rpb24gbmFtZXMgdGhhdCBpcyB0cmFjZWQuIEluY2x1ZGluZyBpdHNlbGYuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtTdHJpbmdbXX0gIFJldHVybmluZyBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzIHRoYXQgaXMgdHJhY2VkLiBJbmNsdWRpbmcgaXRzZWxmLlxuXHQgKi9cblx0dHJhY2VGdW5jdGlvbkNhbGxzKGZ1bmN0aW9uTmFtZSwgcmV0TGlzdCkge1xuXHRcdGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZSB8fCAna2VybmVsJztcblx0XHRyZXRMaXN0ID0gcmV0TGlzdCB8fCBbXTtcblxuXHRcdGlmICh0aGlzLm5hdGl2ZUZ1bmN0aW9uTmFtZXMuaW5kZXhPZihmdW5jdGlvbk5hbWUpID4gLTEpIHtcblx0XHRcdGlmIChyZXRMaXN0LmluZGV4T2YoZnVuY3Rpb25OYW1lKSA9PT0gLTEpIHtcblx0XHRcdFx0cmV0TGlzdC5wdXNoKGZ1bmN0aW9uTmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0TGlzdDtcblx0XHR9XG5cblx0XHRjb25zdCBmdW5jdGlvbk5vZGUgPSB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG5cdFx0aWYgKGZ1bmN0aW9uTm9kZSkge1xuXHRcdFx0Ly8gQ2hlY2sgaWYgZnVuY3Rpb24gYWxyZWFkeSBleGlzdHNcblx0XHRcdGNvbnN0IGZ1bmN0aW9uSW5kZXggPSByZXRMaXN0LmluZGV4T2YoZnVuY3Rpb25OYW1lKTtcblx0XHRcdGlmIChmdW5jdGlvbkluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRyZXRMaXN0LnB1c2goZnVuY3Rpb25OYW1lKTtcblx0XHRcdFx0ZnVuY3Rpb25Ob2RlLnRvU3RyaW5nKCk7IC8vZW5zdXJlIEpTIHRyYWNlIGlzIGRvbmVcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbk5vZGUuY2FsbGVkRnVuY3Rpb25zLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0dGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25Ob2RlLmNhbGxlZEZ1bmN0aW9uc1tpXSwgcmV0TGlzdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBodHRwczovL2dpdGh1Yi5jb20vZ3B1anMvZ3B1LmpzL2lzc3Vlcy8yMDdcblx0XHRcdFx0ICogaWYgZGVwZW5kZW50IGZ1bmN0aW9uIGlzIGFscmVhZHkgaW4gdGhlIGxpc3QsIGJlY2F1c2UgYSBmdW5jdGlvbiBkZXBlbmRzIG9uIGl0LCBhbmQgYmVjYXVzZSBpdCBoYXNcblx0XHRcdFx0ICogYWxyZWFkeSBiZWVuIHRyYWNlZCwgd2Uga25vdyB0aGF0IHdlIG11c3QgbW92ZSB0aGUgZGVwZW5kZW50IGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHRoZSByZXRMaXN0LlxuXHRcdFx0XHQgKiAqL1xuXHRcdFx0XHRjb25zdCBkZXBlbmRhbnRGdW5jdGlvbk5hbWUgPSByZXRMaXN0LnNwbGljZShmdW5jdGlvbkluZGV4LCAxKVswXTtcblx0XHRcdFx0cmV0TGlzdC5wdXNoKGRlcGVuZGFudEZ1bmN0aW9uTmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldExpc3Q7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUmV0dXJuIHRoZSBzdHJpbmcgZm9yIGEgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IGZ1bmN0aW9uTmFtZSAtIEZ1bmN0aW9uIG5hbWUgdG8gdHJhY2UgZnJvbS4gSWYgbnVsbCwgaXQgcmV0dXJucyB0aGUgV0hPTEUgYnVpbGRlciBzdGFja1xuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZnVsbCBzdHJpbmcsIG9mIGFsbCB0aGUgdmFyaW91cyBmdW5jdGlvbnMuIFRyYWNlIG9wdGltaXplZCBpZiBmdW5jdGlvbk5hbWUgZ2l2ZW5cblx0ICovXG5cdGdldFByb3RvdHlwZVN0cmluZyhmdW5jdGlvbk5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQcm90b3R5cGVzKGZ1bmN0aW9uTmFtZSkuam9pbignXFxuJyk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUmV0dXJuIHRoZSBzdHJpbmcgZm9yIGEgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtmdW5jdGlvbk5hbWVdIC0gRnVuY3Rpb24gbmFtZSB0byB0cmFjZSBmcm9tLiBJZiBudWxsLCBpdCByZXR1cm5zIHRoZSBXSE9MRSBidWlsZGVyIHN0YWNrXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGZ1bGwgc3RyaW5nLCBvZiBhbGwgdGhlIHZhcmlvdXMgZnVuY3Rpb25zLiBUcmFjZSBvcHRpbWl6ZWQgaWYgZnVuY3Rpb25OYW1lIGdpdmVuXG5cdCAqL1xuXHRnZXRQcm90b3R5cGVzKGZ1bmN0aW9uTmFtZSkge1xuXHRcdGlmICh0aGlzLnJvb3ROb2RlKSB7XG5cdFx0XHR0aGlzLnJvb3ROb2RlLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHRcdGlmIChmdW5jdGlvbk5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyh0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUsIFtdKS5yZXZlcnNlKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5nZXRQcm90b3R5cGVzRnJvbUZ1bmN0aW9uTmFtZXMoT2JqZWN0LmtleXModGhpcy5mdW5jdGlvbk1hcCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEdldCBzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lc1xuXHQgKiBAcGFyYW0ge1N0cmluZ1tdfSBmdW5jdGlvbkxpc3QgLSBMaXN0IG9mIGZ1bmN0aW9uIHRvIGJ1aWxkIHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nLCBvZiBhbGwgdGhlIHZhcmlvdXMgZnVuY3Rpb25zLiBUcmFjZSBvcHRpbWl6ZWQgaWYgZnVuY3Rpb25OYW1lIGdpdmVuXG5cdCAqL1xuXHRnZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyhmdW5jdGlvbkxpc3QpIHtcblx0XHRjb25zdCByZXQgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uTGlzdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25MaXN0W2ldXTtcblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdHJldC5wdXNoKHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25MaXN0W2ldXS50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJldC5qb2luKCdcXG4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBSZXR1cm4gc3RyaW5nIG9mIGFsbCBmdW5jdGlvbnMgY29udmVydGVkXG5cdCAqIEBwYXJhbSB7U3RyaW5nW119IGZ1bmN0aW9uTGlzdCAtIExpc3Qgb2YgZnVuY3Rpb24gbmFtZXMgdG8gYnVpbGQgdGhlIHN0cmluZy5cblx0ICogQHJldHVybnMge0FycmF5fSBQcm90b3R5cGVzIG9mIGFsbCBmdW5jdGlvbnMgY29udmVydGVkXG5cdCAqL1xuXHRnZXRQcm90b3R5cGVzRnJvbUZ1bmN0aW9uTmFtZXMoZnVuY3Rpb25MaXN0KSB7XG5cdFx0Y29uc3QgcmV0ID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbkxpc3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTGlzdFtpXTtcblx0XHRcdGNvbnN0IGZ1bmN0aW9uSW5kZXggPSB0aGlzLm5hdGl2ZUZ1bmN0aW9uTmFtZXMuaW5kZXhPZihmdW5jdGlvbk5hbWUpO1xuXHRcdFx0aWYgKGZ1bmN0aW9uSW5kZXggPiAtMSkge1xuXHRcdFx0XHRyZXQucHVzaCh0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tmdW5jdGlvbkluZGV4XS5zb3VyY2UpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IG5vZGUgPSB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG5cdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRyZXQucHVzaChub2RlLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0dG9KU09OKCkge1xuXHRcdHJldHVybiB0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyh0aGlzLnJvb3ROb2RlLm5hbWUpLnJldmVyc2UoKS5tYXAobmFtZSA9PiB7XG5cdFx0XHRjb25zdCBuYXRpdmVJbmRleCA9IHRoaXMubmF0aXZlRnVuY3Rpb25zLmluZGV4T2YobmFtZSk7XG5cdFx0XHRpZiAobmF0aXZlSW5kZXggPiAtMSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0c291cmNlOiB0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tuYXRpdmVJbmRleF0uc291cmNlXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZnVuY3Rpb25NYXBbbmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnVuY3Rpb25NYXBbbmFtZV0udG9KU09OKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGZ1bmN0aW9uICR7IG5hbWUgfSBub3QgZm91bmRgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGZyb21KU09OKGpzb25GdW5jdGlvbk5vZGVzLCBGdW5jdGlvbk5vZGUpIHtcblx0XHR0aGlzLmZ1bmN0aW9uTWFwID0ge307XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBqc29uRnVuY3Rpb25Ob2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QganNvbkZ1bmN0aW9uTm9kZSA9IGpzb25GdW5jdGlvbk5vZGVzW2ldO1xuXHRcdFx0dGhpcy5mdW5jdGlvbk1hcFtqc29uRnVuY3Rpb25Ob2RlLnNldHRpbmdzLm5hbWVdID0gbmV3IEZ1bmN0aW9uTm9kZShqc29uRnVuY3Rpb25Ob2RlLmFzdCwganNvbkZ1bmN0aW9uTm9kZS5zZXR0aW5ncyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEdldCBzdHJpbmcgZm9yIGEgcGFydGljdWxhciBmdW5jdGlvbiBuYW1lXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jdGlvbk5hbWUgLSBGdW5jdGlvbiBuYW1lIHRvIHRyYWNlIGZyb20uIElmIG51bGwsIGl0IHJldHVybnMgdGhlIFdIT0xFIGJ1aWxkZXIgc3RhY2tcblx0ICogQHJldHVybnMge1N0cmluZ30gc2V0dGluZ3MgLSBUaGUgc3RyaW5nLCBvZiBhbGwgdGhlIHZhcmlvdXMgZnVuY3Rpb25zLiBUcmFjZSBvcHRpbWl6ZWQgaWYgZnVuY3Rpb25OYW1lIGdpdmVuXG5cdCAqL1xuXHRnZXRTdHJpbmcoZnVuY3Rpb25OYW1lKSB7XG5cdFx0aWYgKGZ1bmN0aW9uTmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U3RyaW5nRnJvbUZ1bmN0aW9uTmFtZXModGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lKS5yZXZlcnNlKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5nZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyhPYmplY3Qua2V5cyh0aGlzLmZ1bmN0aW9uTWFwKSk7XG5cdH1cblxuXHRsb29rdXBBcmd1bWVudFR5cGUoYXJndW1lbnROYW1lLCByZXF1ZXN0aW5nTm9kZSkge1xuXHRcdGNvbnN0IGluZGV4ID0gcmVxdWVzdGluZ05vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG5cdFx0aWYgKHRoaXMubG9va3VwQ2hhaW4ubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblx0XHRsZXQgbGluayA9IHRoaXMubG9va3VwQ2hhaW5bdGhpcy5sb29rdXBDaGFpbi5sZW5ndGggLSAxIC0gdGhpcy5hcmd1bWVudENoYWluLmxlbmd0aF07XG5cdFx0aWYgKCFsaW5rKSByZXR1cm4gbnVsbDtcblx0XHRjb25zdCB7XG5cdFx0XHRhc3QsXG5cdFx0XHRyZXF1ZXN0aW5nTm9kZTogcGFyZW50UmVxdWVzdGluZ05vZGVcblx0XHR9ID0gbGluaztcblx0XHRpZiAoYXN0LmFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXHRcdGNvbnN0IHVzZWRWYXJpYWJsZSA9IGFzdC5hcmd1bWVudHNbaW5kZXhdO1xuXHRcdGlmICghdXNlZFZhcmlhYmxlKSByZXR1cm4gbnVsbDtcblx0XHR0aGlzLmFyZ3VtZW50Q2hhaW4ucHVzaChhcmd1bWVudE5hbWUpO1xuXHRcdGNvbnN0IHR5cGUgPSBwYXJlbnRSZXF1ZXN0aW5nTm9kZS5nZXRUeXBlKHVzZWRWYXJpYWJsZSk7XG5cdFx0dGhpcy5hcmd1bWVudENoYWluLnBvcCgpO1xuXHRcdHJldHVybiB0eXBlO1xuXHR9XG5cblx0bG9va3VwUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUsIGFzdCwgcmVxdWVzdGluZ05vZGUpIHtcblx0XHQvLyBUT0RPOiB0cmFjayBjaXJjbGljYWwgbG9naWNcblx0XHRpZiAoYXN0LnR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgYXN0IHR5cGUgb2YgXCJDYWxsRXhwcmVzc2lvblwiLCBidXQgaXMgJHsgYXN0LnR5cGUgfWApO1xuXHRcdH1cblx0XHRpZiAodGhpcy5faXNOYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbG9va3VwTmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcblx0XHRcdGNvbnN0IG5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuXHRcdFx0aWYgKG5vZGUucmV0dXJuVHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZS5yZXR1cm5UeXBlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZ2V0IHJlYWR5IGZvciBhIHJpZGUhXG5cdFx0XHRcdHRoaXMubG9va3VwQ2hhaW4ucHVzaCh7XG5cdFx0XHRcdFx0bmFtZTogcmVxdWVzdGluZ05vZGUubmFtZSxcblx0XHRcdFx0XHRhc3QsXG5cdFx0XHRcdFx0cmVxdWVzdGluZ05vZGVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNvbnN0IHR5cGUgPSBub2RlLmdldFR5cGUobm9kZS5nZXRKc0FTVCgpKTtcblx0XHRcdFx0dGhpcy5sb29rdXBDaGFpbi5wb3AoKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUucmV0dXJuVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZnVuY3Rpb24gbm90IGZvdW5kLCBtYXliZSBuYXRpdmU/XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRfZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG5cdFx0aWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcblx0XHRcdG5ldyBFcnJvcihgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9IG5vdCBmb3VuZGApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuXHR9XG5cblx0X2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG5cdFx0cmV0dXJuIEJvb2xlYW4odGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdKTtcblx0fVxuXG5cdF9nZXROYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5uYXRpdmVGdW5jdGlvbnNbaV0ubmFtZSA9PT0gZnVuY3Rpb25OYW1lKSByZXR1cm4gdGhpcy5uYXRpdmVGdW5jdGlvbnNbaV07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0X2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG5cdFx0cmV0dXJuIEJvb2xlYW4odGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSk7XG5cdH1cblxuXHRfbG9va3VwTmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSkge1xuXHRcdGxldCBuYXRpdmVGdW5jdGlvbiA9IHRoaXMuX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG5cdFx0aWYgKG5hdGl2ZUZ1bmN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gbmF0aXZlRnVuY3Rpb24ucmV0dXJuVHlwZTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBOYXRpdmUgZnVuY3Rpb24gJHsgZnVuY3Rpb25OYW1lIH0gbm90IGZvdW5kYCk7XG5cdH1cblxuXHRsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB7XG5cdFx0aWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkuYXJndW1lbnRUeXBlcztcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkuYXJndW1lbnRUeXBlcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRsb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZShmdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudE5hbWVzW2FyZ3VtZW50SW5kZXhdO1xuXHR9XG5cblx0bG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lKSB7XG5cdFx0aWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gbm90IGZvdW5kJyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnJvb3ROb2RlLm5hbWUgPT09IGZ1bmN0aW9uTmFtZSkge1xuXHRcdFx0Y29uc3QgaSA9IHRoaXMucm9vdE5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG5cdFx0XHRpZiAoaSAhPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucm9vdE5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IGJpdCByYXRpbyBub3QgZm91bmQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG5cdFx0XHRjb25zdCBhcmd1bWVudFN5bm9ueW0gPSBub2RlLmFyZ3VtZW50U3lub255bVtub2RlLnN5bm9ueW1JbmRleF07XG5cdFx0XHRpZiAoIWFyZ3VtZW50U3lub255bSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IHN5bm9ueW0gbm90IGZvdW5kJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8oYXJndW1lbnRTeW5vbnltLmZ1bmN0aW9uTmFtZSwgYXJndW1lbnRTeW5vbnltLmFyZ3VtZW50TmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0YXNzaWduQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCByZXF1ZXN0aW5nTm9kZSkge1xuXHRcdGlmICghdGhpcy5faXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSByZXR1cm47XG5cdFx0dGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudFR5cGVzW2ldID0gYXJndW1lbnRUeXBlO1xuXHR9XG5cblx0dHJhY2tBcmd1bWVudFN5bm9ueW0oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkge1xuXHRcdGlmICghdGhpcy5faXNGdW5jdGlvbihjYWxsZWVGdW5jdGlvbk5hbWUpKSByZXR1cm47XG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGNhbGxlZUZ1bmN0aW9uTmFtZSk7XG5cdFx0aWYgKCFub2RlLmFyZ3VtZW50U3lub255bSkge1xuXHRcdFx0bm9kZS5hcmd1bWVudFN5bm9ueW0gPSB7fTtcblx0XHR9XG5cdFx0Y29uc3QgY2FsbGVlQXJndW1lbnROYW1lID0gbm9kZS5hcmd1bWVudE5hbWVzW2FyZ3VtZW50SW5kZXhdO1xuXHRcdGlmICghbm9kZS5hcmd1bWVudFN5bm9ueW1bY2FsbGVlQXJndW1lbnROYW1lXSkge1xuXHRcdFx0bm9kZS5hcmd1bWVudFN5bm9ueW1bY2FsbGVlQXJndW1lbnROYW1lXSA9IHt9O1xuXHRcdH1cblx0XHRub2RlLnN5bm9ueW1JbmRleCsrO1xuXHRcdG5vZGUuYXJndW1lbnRTeW5vbnltW25vZGUuc3lub255bUluZGV4XSA9IHtcblx0XHRcdGZ1bmN0aW9uTmFtZSxcblx0XHRcdGFyZ3VtZW50TmFtZSxcblx0XHRcdGNhbGxlZUFyZ3VtZW50TmFtZSxcblx0XHRcdGNhbGxlZUZ1bmN0aW9uTmFtZSxcblx0XHR9O1xuXHR9XG5cblx0bG9va3VwQXJndW1lbnRTeW5vbnltKG9yaWdpbkZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpIHtcblx0XHRpZiAob3JpZ2luRnVuY3Rpb25OYW1lID09PSBmdW5jdGlvbk5hbWUpIHJldHVybiBhcmd1bWVudE5hbWU7XG5cdFx0aWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHJldHVybiBudWxsO1xuXHRcdGNvbnN0IG5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuXHRcdGNvbnN0IGFyZ3VtZW50U3lub255bSA9IG5vZGUuYXJndW1lbnRTeW5vbnltW25vZGUuc3lub255bVVzZUluZGV4XTtcblx0XHRpZiAoIWFyZ3VtZW50U3lub255bSkgcmV0dXJuIG51bGw7XG5cdFx0aWYgKGFyZ3VtZW50U3lub255bS5jYWxsZWVBcmd1bWVudE5hbWUgIT09IGFyZ3VtZW50TmFtZSkgcmV0dXJuIG51bGw7XG5cdFx0bm9kZS5zeW5vbnltVXNlSW5kZXgrKztcblx0XHRpZiAob3JpZ2luRnVuY3Rpb25OYW1lICE9PSBmdW5jdGlvbk5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmxvb2t1cEFyZ3VtZW50U3lub255bShvcmlnaW5GdW5jdGlvbk5hbWUsIGFyZ3VtZW50U3lub255bS5mdW5jdGlvbk5hbWUsIGFyZ3VtZW50U3lub255bS5hcmd1bWVudE5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJndW1lbnRTeW5vbnltLmFyZ3VtZW50TmFtZTtcblx0fVxuXG5cdHRyYWNrRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lKSB7XG5cdFx0aWYgKCF0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llc1tmdW5jdGlvbk5hbWVdKSB7XG5cdFx0XHR0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llc1tmdW5jdGlvbk5hbWVdID0gbmV3IFNldCgpO1xuXHRcdH1cblx0XHR0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llc1tmdW5jdGlvbk5hbWVdLmFkZChjYWxsZWVGdW5jdGlvbk5hbWUpO1xuXHR9XG5cblx0Z2V0S2VybmVsUmVzdWx0VHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5yb290Tm9kZS5nZXRUeXBlKHRoaXMucm9vdE5vZGUuYXN0KTtcblx0fVxuXG5cdGdldFJldHVyblR5cGVzKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRcdFt0aGlzLnJvb3ROb2RlLm5hbWVdOiB0aGlzLnJvb3ROb2RlLmdldFR5cGUodGhpcy5yb290Tm9kZS5hc3QpLFxuXHRcdH07XG5cdFx0Y29uc3QgbGlzdCA9IHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKHRoaXMucm9vdE5vZGUubmFtZSk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBmdW5jdGlvbk5hbWUgPSBsaXN0W2ldO1xuXHRcdFx0Y29uc3QgZnVuY3Rpb25Ob2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuXHRcdFx0cmVzdWx0W2Z1bmN0aW9uTmFtZV0gPSBmdW5jdGlvbk5vZGUuZ2V0VHlwZShmdW5jdGlvbk5vZGUuYXN0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0RnVuY3Rpb25CdWlsZGVyXG59OyIsImNvbnN0IHtcblx0dXRpbHNcbn0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgYWNvcm4gPSByZXF1aXJlKCdhY29ybicpO1xuXG4vKipcbiAqXG4gKiBAZGVzYyBSZXByZXNlbnRzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpbnNpZGUgSlMsIHdlYkdMLCBvciBvcGVuR0wuXG4gKiA8cD5UaGlzIGhhbmRsZXMgYWxsIHRoZSByYXcgc3RhdGUsIGNvbnZlcnRlZCBzdGF0ZSwgZXRjLiBPZiBhIHNpbmdsZSBmdW5jdGlvbi48L3A+XG4gKi9cbmNsYXNzIEZ1bmN0aW9uTm9kZSB7XG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNvdXJjZVxuXHQgKiBAcGFyYW0ge0lGdW5jdGlvblNldHRpbmdzfSBbc2V0dGluZ3NdXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG5cdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignc291cmNlIHBhcmFtZXRlciBpcyBtaXNzaW5nJyk7XG5cdFx0fVxuXHRcdHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG5cblx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblx0XHR0aGlzLm5hbWUgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNldHRpbmdzLmlzUm9vdEtlcm5lbCA/XG5cdFx0XHQna2VybmVsJyA6XG5cdFx0XHQoc2V0dGluZ3MubmFtZSB8fCB1dGlscy5nZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKHNvdXJjZSkpIDogbnVsbDtcblx0XHR0aGlzLmNhbGxlZEZ1bmN0aW9ucyA9IFtdO1xuXHRcdHRoaXMuY2FsbGVkRnVuY3Rpb25zQXJndW1lbnRzID0ge307XG5cdFx0dGhpcy5jb25zdGFudHMgPSB7fTtcblx0XHR0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcblx0XHR0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG5cdFx0dGhpcy5pc1Jvb3RLZXJuZWwgPSBmYWxzZTtcblx0XHR0aGlzLmlzU3ViS2VybmVsID0gZmFsc2U7XG5cdFx0dGhpcy5kZWJ1ZyA9IG51bGw7XG5cdFx0dGhpcy5kZWNsYXJhdGlvbnMgPSB7fTtcblx0XHR0aGlzLnN0YXRlcyA9IFtdO1xuXHRcdHRoaXMubG9va3VwUmV0dXJuVHlwZSA9IG51bGw7XG5cdFx0dGhpcy5sb29rdXBBcmd1bWVudFR5cGUgPSBudWxsO1xuXHRcdHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzID0gbnVsbDtcblx0XHR0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyA9IG51bGw7XG5cdFx0dGhpcy50cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUgPSBudWxsO1xuXHRcdHRoaXMudHJpZ2dlclRyYWNrQXJndW1lbnRTeW5vbnltID0gbnVsbDtcblx0XHR0aGlzLmxvb2t1cEFyZ3VtZW50U3lub255bSA9IG51bGw7XG5cdFx0dGhpcy5vbk5lc3RlZEZ1bmN0aW9uID0gbnVsbDtcblx0XHR0aGlzLm9uRnVuY3Rpb25DYWxsID0gbnVsbDtcblx0XHR0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBudWxsO1xuXHRcdHRoaXMucHJlY2lzaW9uID0gbnVsbDtcblx0XHR0aGlzLmxvb3BNYXhJdGVyYXRpb25zID0gbnVsbDtcblx0XHR0aGlzLmFyZ3VtZW50TmFtZXMgPSAodHlwZW9mIHRoaXMuc291cmNlID09PSAnc3RyaW5nJyA/IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHRoaXMuc291cmNlKSA6IG51bGwpO1xuXHRcdHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuXHRcdHRoaXMuYXJndW1lbnRTaXplcyA9IFtdO1xuXHRcdHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBudWxsO1xuXHRcdHRoaXMucmV0dXJuVHlwZSA9IG51bGw7XG5cdFx0dGhpcy5vdXRwdXQgPSBbXTtcblx0XHR0aGlzLnBsdWdpbnMgPSBudWxsO1xuXHRcdHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG5cdFx0dGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuXG5cdFx0aWYgKHNldHRpbmdzKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHAgaW4gc2V0dGluZ3MpIHtcblx0XHRcdFx0aWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG5cdFx0XHRcdGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG5cdFx0XHRcdHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnN5bm9ueW1JbmRleCA9IC0xO1xuXHRcdHRoaXMuc3lub255bVVzZUluZGV4ID0gMDtcblx0XHR0aGlzLmFyZ3VtZW50U3lub255bSA9IHt9O1xuXHRcdHRoaXMubGl0ZXJhbFR5cGVzID0ge307XG5cblx0XHRpZiAodGhpcy5pc1Jvb3RLZXJuZWwgJiYgIXRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0dGhpcy5yZXR1cm5UeXBlID0gJ051bWJlcic7XG5cdFx0fVxuXG5cdFx0dGhpcy52YWxpZGF0ZSgpO1xuXHRcdHRoaXMuX3N0cmluZyA9IG51bGw7XG5cdFx0dGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzID0ge307XG5cdH1cblxuXHR2YWxpZGF0ZSgpIHtcblx0XHRpZiAodHlwZW9mIHRoaXMuc291cmNlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0aGlzLnNvdXJjZSBub3QgYSBzdHJpbmcnKTtcblx0XHR9XG5cblx0XHRpZiAoIXV0aWxzLmlzRnVuY3Rpb25TdHJpbmcodGhpcy5zb3VyY2UpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3RoaXMuc291cmNlIG5vdCBhIGZ1bmN0aW9uIHN0cmluZycpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5uYW1lKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3RoaXMubmFtZSBjb3VsZCBub3QgYmUgc2V0Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGggPiAwICYmIHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGggIT09IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgYXJndW1lbnRUeXBlcyBjb3VudCBvZiAkeyB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoIH0gZXhjZWVkcyAkeyB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoIH1gKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vdXRwdXQubGVuZ3RoIDwgMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0aGlzLm91dHB1dCBpcyBub3QgYmlnIGVub3VnaCcpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzSWRlbnRpZmllckNvbnN0YW50KG5hbWUpIHtcblx0XHRpZiAoIXRoaXMuY29uc3RhbnRzKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RhbnRzLmhhc093blByb3BlcnR5KG5hbWUpO1xuXHR9XG5cblx0aXNJbnB1dChhcmd1bWVudE5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5hcmd1bWVudFR5cGVzW3RoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSldID09PSAnSW5wdXQnO1xuXHR9XG5cblx0cHVzaFN0YXRlKHN0YXRlKSB7XG5cdFx0dGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG5cdH1cblxuXHRwb3BTdGF0ZShzdGF0ZSkge1xuXHRcdGlmICh0aGlzLnN0YXRlICE9PSBzdGF0ZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcG9wU3RhdGUgJHsgc3RhdGUgfSB3aGVuIGluICR7IHRoaXMuc3RhdGUgfWApO1xuXHRcdH1cblx0XHR0aGlzLnN0YXRlcy5wb3AoKTtcblx0fVxuXG5cdGlzU3RhdGUoc3RhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZSA9PT0gc3RhdGU7XG5cdH1cblxuXHRnZXQgc3RhdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdGVzW3RoaXMuc3RhdGVzLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuXHQgKiBAbmFtZSBhc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yIGJpbmFyeSBleHByZXNzaW9uLlxuXHQgKlxuXHQgKiA8cD5VdGlsaXR5IGZ1bmN0aW9uIGZvciBhc3RDYWxsRXhwcmVzc2lvbi48L3A+XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuXHQgKlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZnVuY3Rpb24gbmFtZXNwYWNlIGNhbGwsIHVucm9sbGVkXG5cdCAqL1xuXHRhc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdCkge1xuXHRcdGlmIChhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG5cdFx0XHRyZXR1cm4gYXN0Lm5hbWU7XG5cdFx0fSBlbHNlIGlmIChhc3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuXHRcdFx0cmV0dXJuICd0aGlzJztcblx0XHR9XG5cblx0XHRpZiAoYXN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuXHRcdFx0aWYgKGFzdC5vYmplY3QgJiYgYXN0LnByb3BlcnR5KSB7XG5cdFx0XHRcdC8vYmFiZWwgc25pZmZpbmdcblx0XHRcdFx0aWYgKGFzdC5vYmplY3QuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBhc3Qub2JqZWN0Lm5hbWVbMF0gPT09ICdfJykge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LnByb3BlcnR5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0dGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5vYmplY3QpICtcblx0XHRcdFx0XHQnLicgK1xuXHRcdFx0XHRcdHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QucHJvcGVydHkpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9iYWJlbCBzbmlmZmluZ1xuXHRcdGlmIChhc3QuaGFzT3duUHJvcGVydHkoJ2V4cHJlc3Npb25zJykpIHtcblx0XHRcdGNvbnN0IGZpcnN0RXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uc1swXTtcblx0XHRcdGlmIChmaXJzdEV4cHJlc3Npb24udHlwZSA9PT0gJ0xpdGVyYWwnICYmIGZpcnN0RXhwcmVzc2lvbi52YWx1ZSA9PT0gMCAmJiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LmV4cHJlc3Npb25zWzFdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGYWlsdXJlLCB1bmtub3duIGV4cHJlc3Npb25cblx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIGFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwnLCBhc3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgY2xhc3MgZnVuY3Rpb24gSlMsIGFuZCByZXR1cm5zIGl0cyBBYnN0cmFjdCBTeW50YXggVHJlZSBvYmplY3QuXG5cdCAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGNvbnZlcnQgdG8gc2hhZGVyIGNvZGVcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtpblBhcnNlcl0gLSBQYXJzZXIgdG8gdXNlLCBhc3N1bWVzIGluIHNjb3BlICdwYXJzZXInIGlmIG51bGwgb3IgdW5kZWZpbmVkXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmdW5jdGlvbiBBU1QgT2JqZWN0LCBub3RlIHRoYXQgcmVzdWx0IGlzIGNhY2hlZCB1bmRlciB0aGlzLmFzdDtcblx0ICovXG5cdGdldEpzQVNUKGluUGFyc2VyKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiB0aGlzLmFzdCA9IHRoaXMuc291cmNlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5hc3QpIHtcblx0XHRcdHJldHVybiB0aGlzLmFzdDtcblx0XHR9XG5cblx0XHRpblBhcnNlciA9IGluUGFyc2VyIHx8IGFjb3JuO1xuXHRcdGlmIChpblBhcnNlciA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgJ01pc3NpbmcgSlMgdG8gQVNUIHBhcnNlcic7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYXN0ID0gT2JqZWN0LmZyZWV6ZShpblBhcnNlci5wYXJzZShgY29uc3QgcGFyc2VyXyR7IHRoaXMubmFtZSB9ID0gJHsgdGhpcy5zb3VyY2UgfTtgLCB7XG5cdFx0XHRsb2NhdGlvbnM6IHRydWVcblx0XHR9KSk7XG5cdFx0Ly8gdGFrZSBvdXQgdGhlIGZ1bmN0aW9uIG9iamVjdCwgb3V0c2lkZSB0aGUgdmFyIGRlY2xhcmF0aW9uc1xuXHRcdGNvbnN0IGZ1bmN0aW9uQVNUID0gYXN0LmJvZHlbMF0uZGVjbGFyYXRpb25zWzBdLmluaXQ7XG5cdFx0aWYgKCFhc3QpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIEpTIGNvZGUnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hc3QgPSBmdW5jdGlvbkFTVDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBSZXR1cm4gdGhlIHR5cGUgb2YgcGFyYW1ldGVyIHNlbnQgdG8gc3ViS2VybmVsL0tlcm5lbC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXJcblx0ICogQHJldHVybnMge1N0cmluZ30gVHlwZSBvZiB0aGUgcGFyYW1ldGVyXG5cdCAqL1xuXHRnZXRWYXJpYWJsZVR5cGUobmFtZSkge1xuXHRcdGxldCB0eXBlID0gbnVsbDtcblx0XHRjb25zdCBhcmd1bWVudEluZGV4ID0gdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YobmFtZSk7XG5cdFx0aWYgKGFyZ3VtZW50SW5kZXggPT09IC0xKSB7XG5cdFx0XHRpZiAodGhpcy5kZWNsYXJhdGlvbnNbbmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdLnR5cGU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XTtcblx0XHRcdGlmIChhcmd1bWVudFR5cGUpIHtcblx0XHRcdFx0dHlwZSA9IGFyZ3VtZW50VHlwZTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5sb29rdXBBcmd1bWVudFR5cGUpIHtcblx0XHRcdFx0dHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XSA9IHRoaXMubG9va3VwQXJndW1lbnRUeXBlKG5hbWUsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXR5cGUpIHtcblx0XHRcdC8vIFRPRE86IHN0cmljdCB0eXBlIGRldGVjdGlvbiBtb2RlP1xuXHRcdFx0Ly8gdGhyb3cgbmV3IEVycm9yKGBEZWNsYXJhdGlvbiBvZiAke25hbWV9IG5vdCBmb3VuZGApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZTtcblx0fVxuXG5cdGdldENvbnN0YW50VHlwZShjb25zdGFudE5hbWUpIHtcblx0XHRpZiAodGhpcy5jb25zdGFudFR5cGVzW2NvbnN0YW50TmFtZV0pIHtcblx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmNvbnN0YW50VHlwZXNbY29uc3RhbnROYW1lXTtcblx0XHRcdGlmICh0eXBlID09PSAnRmxvYXQnKSB7XG5cdFx0XHRcdHJldHVybiAnTnVtYmVyJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aHJvdyBuZXcgRXJyb3IoYFR5cGUgZm9yIGNvbnN0YW50IFwiJHsgY29uc3RhbnROYW1lIH1cIiBub3QgZGVjbGFyZWRgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlICp1c2VyIGFyZ3VtZW50KihzdWJLZXJuZWwgYXJndW1lbnQpIGNvcnJlc3BvbmRpbmdcblx0ICogdG8gdGhlIGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBrZXJuZWxcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhcmd1bWVudFxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXJcblx0ICovXG5cdGdldEtlcm5lbEFyZ3VtZW50TmFtZShuYW1lKSB7XG5cdFx0aWYgKCF0aGlzLmxvb2t1cEFyZ3VtZW50U3lub255bSkgcmV0dXJuIG51bGw7XG5cdFx0Y29uc3QgYXJndW1lbnRJbmRleCA9IHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKG5hbWUpO1xuXHRcdGlmIChhcmd1bWVudEluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG5cdFx0cmV0dXJuIHRoaXMubG9va3VwQXJndW1lbnRTeW5vbnltKCdrZXJuZWwnLCB0aGlzLm5hbWUsIG5hbWUpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0aWYgKHRoaXMuX3N0cmluZykgcmV0dXJuIHRoaXMuX3N0cmluZztcblx0XHRyZXR1cm4gdGhpcy5fc3RyaW5nID0gdGhpcy5hc3RHZW5lcmljKHRoaXMuZ2V0SnNBU1QoKSwgW10pLmpvaW4oJycpLnRyaW0oKTtcblx0fVxuXG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBzZXR0aW5ncyA9IHtcblx0XHRcdHNvdXJjZTogdGhpcy5zb3VyY2UsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRjb25zdGFudHM6IHRoaXMuY29uc3RhbnRzLFxuXHRcdFx0Y29uc3RhbnRUeXBlczogdGhpcy5jb25zdGFudFR5cGVzLFxuXHRcdFx0aXNSb290S2VybmVsOiB0aGlzLmlzUm9vdEtlcm5lbCxcblx0XHRcdGlzU3ViS2VybmVsOiB0aGlzLmlzU3ViS2VybmVsLFxuXHRcdFx0ZGVidWc6IHRoaXMuZGVidWcsXG5cdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0bG9vcE1heEl0ZXJhdGlvbnM6IHRoaXMubG9vcE1heEl0ZXJhdGlvbnMsXG5cdFx0XHRhcmd1bWVudE5hbWVzOiB0aGlzLmFyZ3VtZW50TmFtZXMsXG5cdFx0XHRhcmd1bWVudFR5cGVzOiB0aGlzLmFyZ3VtZW50VHlwZXMsXG5cdFx0XHRhcmd1bWVudFNpemVzOiB0aGlzLmFyZ3VtZW50U2l6ZXMsXG5cdFx0XHRyZXR1cm5UeXBlOiB0aGlzLnJldHVyblR5cGUsXG5cdFx0XHRsZWFkaW5nUmV0dXJuU3RhdGVtZW50OiB0aGlzLmxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQsXG5cdFx0XHRmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQ6IHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LFxuXHRcdH07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YXN0OiB0aGlzLmFzdCxcblx0XHRcdHNldHRpbmdzXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBsb29rcyB1cCB0eXBlIGZvciBhc3QgZXhwcmVzc2lvbiB1bnRpbCBpdCdzIGZvdW5kXG5cdCAqIEBwYXJhbSBhc3Rcblx0ICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuXHQgKi9cblx0Z2V0VHlwZShhc3QpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUeXBlKGFzdFthc3QubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblx0XHRzd2l0Y2ggKGFzdC50eXBlKSB7XG5cdFx0XHRjYXNlICdCbG9ja1N0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmJvZHkpO1xuXHRcdFx0Y2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcblx0XHRcdFx0cmV0dXJuIGBBcnJheSgkeyBhc3QuZWxlbWVudHMubGVuZ3RoIH0pYDtcblx0XHRcdGNhc2UgJ0xpdGVyYWwnOlxuXHRcdFx0XHRjb25zdCBsaXRlcmFsS2V5ID0gYCR7YXN0LnN0YXJ0fSwke2FzdC5lbmR9YDtcblx0XHRcdFx0aWYgKHRoaXMubGl0ZXJhbFR5cGVzW2xpdGVyYWxLZXldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubGl0ZXJhbFR5cGVzW2xpdGVyYWxLZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFzdC52YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gJ0xpdGVyYWxJbnRlZ2VyJztcblx0XHRcdFx0fSBlbHNlIGlmIChhc3QudmFsdWUgPT09IHRydWUgfHwgYXN0LnZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiAnQm9vbGVhbic7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICdOdW1iZXInO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlICdDYWxsRXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmICh0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gJ051bWJlcic7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhc3QuY2FsbGVlIHx8ICFhc3QuY2FsbGVlLm5hbWUpIHtcblx0XHRcdFx0XHRpZiAoYXN0LmNhbGxlZS50eXBlID09PSAnU2VxdWVuY2VFeHByZXNzaW9uJyAmJiBhc3QuY2FsbGVlLmV4cHJlc3Npb25zW2FzdC5jYWxsZWUuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0ucHJvcGVydHkubmFtZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubG9va3VwUmV0dXJuVHlwZShhc3QuY2FsbGVlLmV4cHJlc3Npb25zW2FzdC5jYWxsZWUuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0ucHJvcGVydHkubmFtZSwgYXN0LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBjYWxsIGV4cHJlc3Npb24nLCBhc3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhc3QuY2FsbGVlICYmIGFzdC5jYWxsZWUubmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxvb2t1cFJldHVyblR5cGUoYXN0LmNhbGxlZS5uYW1lLCBhc3QsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBnZXRUeXBlIFR5cGUgXCIkeyBhc3QudHlwZSB9XCJgLCBhc3QpO1xuXHRcdFx0Y2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdC8vIG1vZHVsb3MgaXMgTnVtYmVyXG5cdFx0XHRcdHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG5cdFx0XHRcdFx0Y2FzZSAnJSc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ051bWJlcic7XG5cdFx0XHRcdFx0Y2FzZSAnPic6XG5cdFx0XHRcdFx0Y2FzZSAnPCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ0Jvb2xlYW4nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmxlZnQpO1xuXHRcdFx0XHRyZXR1cm4gdHlwZUxvb2t1cE1hcFt0eXBlXSB8fCB0eXBlO1xuXHRcdFx0Y2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcblx0XHRcdGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcblx0XHRcdGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5kZWNsYXJhdGlvbnNbMF0pO1xuXHRcdFx0Y2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuaWQpO1xuXHRcdFx0Y2FzZSAnSWRlbnRpZmllcic6XG5cdFx0XHRcdGlmICh0aGlzLmlzQXN0VmFyaWFibGUoYXN0KSkge1xuXHRcdFx0XHRcdGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcblx0XHRcdFx0XHRpZiAoc2lnbmF0dXJlID09PSAndmFsdWUnKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXN0Lm5hbWUpID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5uYW1lKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5kZWNsYXJhdGlvbnNbYXN0Lm5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmRlY2xhcmF0aW9uc1thc3QubmFtZV0udHlwZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFzdC5uYW1lID09PSAnSW5maW5pdHknKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdOdW1iZXInO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IG9yaWdpbiA9IHRoaXMuZmluZElkZW50aWZpZXJPcmlnaW4oYXN0KTtcblx0XHRcdFx0aWYgKG9yaWdpbiAmJiBvcmlnaW4uaW5pdCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFR5cGUob3JpZ2luLmluaXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0Y2FzZSAnUmV0dXJuU3RhdGVtZW50Jzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuXHRcdFx0Y2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmICh0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCkpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGFzdC5wcm9wZXJ0eS5uYW1lKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdjZWlsJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuICdJbnRlZ2VyJztcblx0XHRcdFx0XHRcdGNhc2UgJ2Zsb29yJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuICdJbnRlZ2VyJztcblx0XHRcdFx0XHRcdGNhc2UgJ3JvdW5kJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuICdJbnRlZ2VyJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICdOdW1iZXInO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmlzQXN0VmFyaWFibGUoYXN0KSkge1xuXHRcdFx0XHRcdGNvbnN0IHZhcmlhYmxlU2lnbmF0dXJlID0gdGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QpO1xuXHRcdFx0XHRcdHN3aXRjaCAodmFyaWFibGVTaWduYXR1cmUpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ3ZhbHVlW10nOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHlwZUxvb2t1cE1hcFt0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm5hbWUpXTtcblx0XHRcdFx0XHRcdGNhc2UgJ3ZhbHVlW11bXSc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0eXBlTG9va3VwTWFwW3RoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm5hbWUpXTtcblx0XHRcdFx0XHRcdGNhc2UgJ3ZhbHVlW11bXVtdJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHR5cGVMb29rdXBNYXBbdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWUpXTtcblx0XHRcdFx0XHRcdGNhc2UgJ3ZhbHVlW11bXVtdW10nOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHlwZUxvb2t1cE1hcFt0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWUpXTtcblx0XHRcdFx0XHRcdGNhc2UgJ3RoaXMudGhyZWFkLnZhbHVlJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuICdJbnRlZ2VyJztcblx0XHRcdFx0XHRcdGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuICdMaXRlcmFsSW50ZWdlcic7XG5cdFx0XHRcdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmdldENvbnN0YW50VHlwZShhc3QucHJvcGVydHkubmFtZSk7XG5cdFx0XHRcdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHR5cGVMb29rdXBNYXBbdGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKV07XG5cdFx0XHRcdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHlwZUxvb2t1cE1hcFt0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKV07XG5cdFx0XHRcdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0eXBlTG9va3VwTWFwW3RoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKV07XG5cdFx0XHRcdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXVtdJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHR5cGVMb29rdXBNYXBbdGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKV07XG5cdFx0XHRcdFx0XHRjYXNlICdmbigpW10nOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHlwZUxvb2t1cE1hcFt0aGlzLmdldFR5cGUoYXN0Lm9iamVjdCldO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZm4oKVtdW10nOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHlwZUxvb2t1cE1hcFt0aGlzLmdldFR5cGUoYXN0Lm9iamVjdCldO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZm4oKVtdW11bXSc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0eXBlTG9va3VwTWFwW3RoaXMuZ2V0VHlwZShhc3Qub2JqZWN0KV07XG5cdFx0XHRcdFx0XHRjYXNlICd2YWx1ZS52YWx1ZSc6XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmlzQXN0TWF0aFZhcmlhYmxlKGFzdCkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJ051bWJlcic7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0c3dpdGNoIChhc3QucHJvcGVydHkubmFtZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3InOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHR5cGVMb29rdXBNYXBbdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5uYW1lKV07XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZyc6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHlwZUxvb2t1cE1hcFt0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm5hbWUpXTtcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0eXBlTG9va3VwTWFwW3RoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5vYmplY3QubmFtZSldO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHR5cGVMb29rdXBNYXBbdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5uYW1lKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhc2UgJ1tdW10nOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJ051bWJlcic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuaGFuZGxlZCBnZXRUeXBlIE1lbWJlckV4cHJlc3Npb24nLCBhc3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuaGFuZGxlZCBnZXRUeXBlIE1lbWJlckV4cHJlc3Npb24nLCBhc3QpO1xuXHRcdFx0Y2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuY29uc2VxdWVudCk7XG5cdFx0XHRjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcblx0XHRcdGNhc2UgJ0Z1bmN0aW9uRXhwcmVzc2lvbic6XG5cdFx0XHRcdGNvbnN0IGxhc3RSZXR1cm4gPSB0aGlzLmZpbmRMYXN0UmV0dXJuKGFzdC5ib2R5KTtcblx0XHRcdFx0aWYgKGxhc3RSZXR1cm4pIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUeXBlKGxhc3RSZXR1cm4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0Y2FzZSAnSWZTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5jb25zZXF1ZW50KTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBnZXRUeXBlIFR5cGUgXCIkeyBhc3QudHlwZSB9XCJgLCBhc3QpO1xuXHRcdH1cblx0fVxuXG5cdGlzQXN0TWF0aFZhcmlhYmxlKGFzdCkge1xuXHRcdGNvbnN0IG1hdGhQcm9wZXJ0aWVzID0gW1xuXHRcdFx0J0UnLFxuXHRcdFx0J1BJJyxcblx0XHRcdCdTUVJUMicsXG5cdFx0XHQnU1FSVDFfMicsXG5cdFx0XHQnTE4yJyxcblx0XHRcdCdMTjEwJyxcblx0XHRcdCdMT0cyRScsXG5cdFx0XHQnTE9HMTBFJyxcblx0XHRdO1xuXHRcdHJldHVybiBhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG5cdFx0XHRhc3Qub2JqZWN0ICYmIGFzdC5vYmplY3QudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG5cdFx0XHRhc3Qub2JqZWN0Lm5hbWUgPT09ICdNYXRoJyAmJlxuXHRcdFx0YXN0LnByb3BlcnR5ICYmXG5cdFx0XHRhc3QucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG5cdFx0XHRtYXRoUHJvcGVydGllcy5pbmRleE9mKGFzdC5wcm9wZXJ0eS5uYW1lKSA+IC0xO1xuXHR9XG5cblx0aXNBc3RNYXRoRnVuY3Rpb24oYXN0KSB7XG5cdFx0Y29uc3QgbWF0aEZ1bmN0aW9ucyA9IFtcblx0XHRcdCdhYnMnLFxuXHRcdFx0J2Fjb3MnLFxuXHRcdFx0J2FzaW4nLFxuXHRcdFx0J2F0YW4nLFxuXHRcdFx0J2F0YW4yJyxcblx0XHRcdCdjZWlsJyxcblx0XHRcdCdjb3MnLFxuXHRcdFx0J2V4cCcsXG5cdFx0XHQnZmxvb3InLFxuXHRcdFx0J2xvZycsXG5cdFx0XHQnbG9nMicsXG5cdFx0XHQnbWF4Jyxcblx0XHRcdCdtaW4nLFxuXHRcdFx0J3BvdycsXG5cdFx0XHQncmFuZG9tJyxcblx0XHRcdCdyb3VuZCcsXG5cdFx0XHQnc2lnbicsXG5cdFx0XHQnc2luJyxcblx0XHRcdCdzcXJ0Jyxcblx0XHRcdCd0YW4nLFxuXHRcdF07XG5cdFx0cmV0dXJuIGFzdC50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nICYmXG5cdFx0XHRhc3QuY2FsbGVlICYmXG5cdFx0XHRhc3QuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJlxuXHRcdFx0YXN0LmNhbGxlZS5vYmplY3QgJiZcblx0XHRcdGFzdC5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuXHRcdFx0YXN0LmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ01hdGgnICYmXG5cdFx0XHRhc3QuY2FsbGVlLnByb3BlcnR5ICYmXG5cdFx0XHRhc3QuY2FsbGVlLnByb3BlcnR5LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuXHRcdFx0bWF0aEZ1bmN0aW9ucy5pbmRleE9mKGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSkgPiAtMTtcblx0fVxuXG5cdGlzQXN0VmFyaWFibGUoYXN0KSB7XG5cdFx0cmV0dXJuIGFzdC50eXBlID09PSAnSWRlbnRpZmllcicgfHwgYXN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJztcblx0fVxuXG5cdGlzU2FmZShhc3QpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1NhZmVEZXBlbmRlbmNpZXModGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0KSk7XG5cdH1cblxuXHRpc1NhZmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG5cdFx0cmV0dXJuIGRlcGVuZGVuY2llcyAmJiBkZXBlbmRlbmNpZXMuZXZlcnkgPyBkZXBlbmRlbmNpZXMuZXZlcnkoZGVwZW5kZW5jeSA9PiBkZXBlbmRlbmN5LmlzU2FmZSkgOiB0cnVlO1xuXHR9XG5cblx0Z2V0RGVwZW5kZW5jaWVzKGFzdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpIHtcblx0XHRpZiAoIWRlcGVuZGVuY2llcykge1xuXHRcdFx0ZGVwZW5kZW5jaWVzID0gW107XG5cdFx0fVxuXHRcdGlmICghYXN0KSByZXR1cm4gbnVsbDtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmdldERlcGVuZGVuY2llcyhhc3RbaV0sIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkZXBlbmRlbmNpZXM7XG5cdFx0fVxuXHRcdHN3aXRjaCAoYXN0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ0xpdGVyYWwnOlxuXHRcdFx0XHRkZXBlbmRlbmNpZXMucHVzaCh7XG5cdFx0XHRcdFx0b3JpZ2luOiAnbGl0ZXJhbCcsXG5cdFx0XHRcdFx0dmFsdWU6IGFzdC52YWx1ZSxcblx0XHRcdFx0XHRpc1NhZmU6IGlzTm90U2FmZSA9PT0gdHJ1ZSA/IGZhbHNlIDogYXN0LnZhbHVlID4gLUluZmluaXR5ICYmIGFzdC52YWx1ZSA8IEluZmluaXR5ICYmICFpc05hTihhc3QudmFsdWUpXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRvcic6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuaW5pdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuXHRcdFx0Y2FzZSAnSWRlbnRpZmllcic6XG5cdFx0XHRcdGlmICh0aGlzLmRlY2xhcmF0aW9uc1thc3QubmFtZV0pIHtcblx0XHRcdFx0XHRkZXBlbmRlbmNpZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBhc3QubmFtZSxcblx0XHRcdFx0XHRcdG9yaWdpbjogJ2RlY2xhcmF0aW9uJyxcblx0XHRcdFx0XHRcdGlzU2FmZTogaXNOb3RTYWZlID8gZmFsc2UgOiB0aGlzLmlzU2FmZURlcGVuZGVuY2llcyh0aGlzLmRlY2xhcmF0aW9uc1thc3QubmFtZV0uZGVwZW5kZW5jaWVzKSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhc3QubmFtZSkgPiAtMSkge1xuXHRcdFx0XHRcdGRlcGVuZGVuY2llcy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6IGFzdC5uYW1lLFxuXHRcdFx0XHRcdFx0b3JpZ2luOiAnYXJndW1lbnQnLFxuXHRcdFx0XHRcdFx0aXNTYWZlOiBmYWxzZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmJvZHkuYm9keVthc3QuYm9keS5ib2R5Lmxlbmd0aCAtIDFdLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG5cdFx0XHRjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmFyZ3VtZW50LCBkZXBlbmRlbmNpZXMpO1xuXHRcdFx0Y2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGlzTm90U2FmZSA9IChhc3Qub3BlcmF0b3IgPT09ICcvJyB8fCBhc3Qub3BlcmF0b3IgPT09ICcqJyk7XG5cdFx0XHRcdHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5sZWZ0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG5cdFx0XHRcdHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5yaWdodCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuXHRcdFx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXHRcdFx0Y2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmFyZ3VtZW50LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG5cdFx0XHRjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5kZWNsYXJhdGlvbnMsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcblx0XHRcdGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGRlcGVuZGVuY2llcy5wdXNoKHtcblx0XHRcdFx0XHRvcmlnaW46ICdkZWNsYXJhdGlvbicsXG5cdFx0XHRcdFx0aXNTYWZlOiB0cnVlLFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGRlcGVuZGVuY2llcztcblx0XHRcdGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcblx0XHRcdFx0ZGVwZW5kZW5jaWVzLnB1c2goe1xuXHRcdFx0XHRcdG9yaWdpbjogJ2Z1bmN0aW9uJyxcblx0XHRcdFx0XHRpc1NhZmU6IHRydWUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXHRcdFx0Y2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG5cdFx0XHRcdGNvbnN0IGRldGFpbHMgPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKGFzdCk7XG5cdFx0XHRcdGlmIChkZXRhaWxzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRldGFpbHMudHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIHR5cGUgJHsgYXN0LnR5cGUgfSBpbiBnZXRBbGxWYXJpYWJsZXNgLCBhc3QpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXHR9XG5cblx0Z2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KSB7XG5cdFx0aWYgKCF0aGlzLmlzQXN0VmFyaWFibGUoYXN0KSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBhc3Qgb2YgdHlwZSBcIiR7IGFzdC50eXBlIH1cIiBpcyBub3QgYSB2YXJpYWJsZSBzaWduYXR1cmVgKTtcblx0XHR9XG5cdFx0aWYgKGFzdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcblx0XHRcdHJldHVybiAndmFsdWUnO1xuXHRcdH1cblx0XHRjb25zdCBzaWduYXR1cmUgPSBbXTtcblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0aWYgKCFhc3QpIGJyZWFrO1xuXHRcdFx0aWYgKGFzdC5jb21wdXRlZCkge1xuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnW10nKTtcblx0XHRcdH0gZWxzZSBpZiAoYXN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcblx0XHRcdFx0c2lnbmF0dXJlLnVuc2hpZnQoJ3RoaXMnKTtcblx0XHRcdH0gZWxzZSBpZiAoYXN0LnByb3BlcnR5ICYmIGFzdC5wcm9wZXJ0eS5uYW1lKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRhc3QucHJvcGVydHkubmFtZSA9PT0gJ3gnIHx8XG5cdFx0XHRcdFx0YXN0LnByb3BlcnR5Lm5hbWUgPT09ICd5JyB8fFxuXHRcdFx0XHRcdGFzdC5wcm9wZXJ0eS5uYW1lID09PSAneidcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0c2lnbmF0dXJlLnVuc2hpZnQoJy52YWx1ZScpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdGFzdC5wcm9wZXJ0eS5uYW1lID09PSAnY29uc3RhbnRzJyB8fFxuXHRcdFx0XHRcdGFzdC5wcm9wZXJ0eS5uYW1lID09PSAndGhyZWFkJyB8fFxuXHRcdFx0XHRcdGFzdC5wcm9wZXJ0eS5uYW1lID09PSAnb3V0cHV0J1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRzaWduYXR1cmUudW5zaGlmdCgnLicgKyBhc3QucHJvcGVydHkubmFtZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2lnbmF0dXJlLnVuc2hpZnQoJy52YWx1ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFzdC5uYW1lKSB7XG5cdFx0XHRcdHNpZ25hdHVyZS51bnNoaWZ0KCd2YWx1ZScpO1xuXHRcdFx0fSBlbHNlIGlmIChhc3QuY2FsbGVlICYmIGFzdC5jYWxsZWUubmFtZSkge1xuXHRcdFx0XHRzaWduYXR1cmUudW5zaGlmdCgnZm4oKScpO1xuXHRcdFx0fSBlbHNlIGlmIChhc3QuZWxlbWVudHMpIHtcblx0XHRcdFx0c2lnbmF0dXJlLnVuc2hpZnQoJ1tdJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzaWduYXR1cmUudW5zaGlmdCgndW5rbm93bicpO1xuXHRcdFx0fVxuXHRcdFx0YXN0ID0gYXN0Lm9iamVjdDtcblx0XHR9XG5cblx0XHRjb25zdCBzaWduYXR1cmVTdHJpbmcgPSBzaWduYXR1cmUuam9pbignJyk7XG5cdFx0Y29uc3QgYWxsb3dlZEV4cHJlc3Npb25zID0gW1xuXHRcdFx0J3ZhbHVlJyxcblx0XHRcdCd2YWx1ZVtdJyxcblx0XHRcdCd2YWx1ZVtdW10nLFxuXHRcdFx0J3ZhbHVlW11bXVtdJyxcblx0XHRcdCd2YWx1ZVtdW11bXVtdJyxcblx0XHRcdCd2YWx1ZS52YWx1ZScsXG5cdFx0XHQndGhpcy50aHJlYWQudmFsdWUnLFxuXHRcdFx0J3RoaXMub3V0cHV0LnZhbHVlJyxcblx0XHRcdCd0aGlzLmNvbnN0YW50cy52YWx1ZScsXG5cdFx0XHQndGhpcy5jb25zdGFudHMudmFsdWVbXScsXG5cdFx0XHQndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJyxcblx0XHRcdCd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXScsXG5cdFx0XHQndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW11bXScsXG5cdFx0XHQnZm4oKVtdJyxcblx0XHRcdCdmbigpW11bXScsXG5cdFx0XHQnZm4oKVtdW11bXScsXG5cdFx0XHQnW11bXScsXG5cdFx0XTtcblx0XHRpZiAoYWxsb3dlZEV4cHJlc3Npb25zLmluZGV4T2Yoc2lnbmF0dXJlU3RyaW5nKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gc2lnbmF0dXJlU3RyaW5nO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGJ1aWxkKCkge1xuXHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubGVuZ3RoID4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciBnZW5lcmljYWxseSB0byBpdHMgcmVzcGVjdGl2ZSBmdW5jdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBwYXJzZWQgc3RyaW5nIGFycmF5XG5cdCAqL1xuXHRhc3RHZW5lcmljKGFzdCwgcmV0QXJyKSB7XG5cdFx0aWYgKGFzdCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTlVMTCBhc3QnLCBhc3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdFtpXSwgcmV0QXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKGFzdC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0Y2FzZSAnTGl0ZXJhbCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0TGl0ZXJhbChhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdJZGVudGlmaWVyJzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RJZGVudGlmaWVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdEV4cHJlc3Npb25TdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdFbXB0eVN0YXRlbWVudCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0RW1wdHlTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdCbG9ja1N0YXRlbWVudCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdJZlN0YXRlbWVudCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdCcmVha1N0YXRlbWVudCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0QnJlYWtTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0Q29udGludWVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdGb3JTdGF0ZW1lbnQnOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdEZvclN0YXRlbWVudChhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ1doaWxlU3RhdGVtZW50Jzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RXaGlsZVN0YXRlbWVudChhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdERvV2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RWYXJpYWJsZURlY2xhcmF0aW9uKGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0Y2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RWYXJpYWJsZURlY2xhcmF0b3IoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdUaGlzRXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdFNlcXVlbmNlRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0VW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0Y2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0VXBkYXRlRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RMb2dpY2FsRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdDYWxsRXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdEFycmF5RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50Jzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3REZWJ1Z2dlclN0YXRlbWVudChhc3QsIHJldEFycik7XG5cdFx0XHRcdGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBhc3QgdHlwZSA6ICcgKyBhc3QudHlwZSwgYXN0KTtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCAqIEBkZXNjIFRvIHRocm93IHRoZSBBU1QgZXJyb3IsIHdpdGggaXRzIGxvY2F0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3IgLSB0aGUgZXJyb3IgbWVzc2FnZSBvdXRwdXRcblx0ICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHdoZXJlIHRoZSBlcnJvciBpc1xuXHQgKi9cblx0YXN0RXJyb3JPdXRwdXQoZXJyb3IsIGFzdCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcblx0XHR9XG5cblx0XHRjb25zdCBkZWJ1Z1N0cmluZyA9IHV0aWxzLmdldEFzdFN0cmluZyh0aGlzLnNvdXJjZSwgYXN0KTtcblx0XHRjb25zdCBsZWFkaW5nU291cmNlID0gdGhpcy5zb3VyY2Uuc3Vic3RyKGFzdC5zdGFydCk7XG5cdFx0Y29uc3Qgc3BsaXRMaW5lcyA9IGxlYWRpbmdTb3VyY2Uuc3BsaXQoL1xcbi8pO1xuXHRcdGNvbnN0IGxpbmVCZWZvcmUgPSBzcGxpdExpbmVzLmxlbmd0aCA+IDAgPyBzcGxpdExpbmVzW3NwbGl0TGluZXMubGVuZ3RoIC0gMV0gOiAwO1xuXHRcdHJldHVybiBuZXcgRXJyb3IoYCR7ZXJyb3J9IG9uIGxpbmUgJHsgc3BsaXRMaW5lcy5sZW5ndGggfSwgcG9zaXRpb24gJHsgbGluZUJlZm9yZS5sZW5ndGggfTpcXG4gJHsgZGVidWdTdHJpbmcgfWApO1xuXHR9XG5cblx0YXN0RGVidWdnZXJTdGF0ZW1lbnQoYXJyTm9kZSwgcmV0QXJyKSB7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdGFzdENvbmRpdGlvbmFsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdGlmIChhc3QudHlwZSAhPT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05vdCBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24nLCBhc3QpO1xuXHRcdH1cblx0XHRyZXRBcnIucHVzaCgnKCcpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaCgnPycpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaCgnOicpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuXHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgdG8gaXRzICpuYW1lZCBmdW5jdGlvbiBkZWNsYXJhdGlvbipcblx0ICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0RnVuY3Rpb25EZWNsYXJhdGlvbihhc3QsIHJldEFycikge1xuXHRcdGlmICh0aGlzLm9uTmVzdGVkRnVuY3Rpb24pIHtcblx0XHRcdGxldCByZXR1cm5UeXBlID0gdGhpcy5nZXRUeXBlKGFzdCk7XG5cdFx0XHRpZiAocmV0dXJuVHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuXHRcdFx0XHRyZXR1cm5UeXBlID0gJ051bWJlcic7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm9uTmVzdGVkRnVuY3Rpb24odXRpbHMuZ2V0QXN0U3RyaW5nKHRoaXMuc291cmNlLCBhc3QpLCByZXR1cm5UeXBlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHRhc3RGdW5jdGlvbkV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cdGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0YXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuXHRcdHRoaXMubGl0ZXJhbFR5cGVzW2Ake2FzdC5zdGFydH0sJHthc3QuZW5kfWBdID0gJ051bWJlcic7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHRhc3RCaW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHRhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0YXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqZ2VuZXJpYyBleHByZXNzaW9uKiBzdGF0ZW1lbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVzTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0RXhwcmVzc2lvblN0YXRlbWVudChlc05vZGUsIHJldEFycikge1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhlc05vZGUuZXhwcmVzc2lvbiwgcmV0QXJyKTtcblx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yIGFuICpFbXB0eSogU3RhdGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0RW1wdHlTdGF0ZW1lbnQoZU5vZGUsIHJldEFycikge1xuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0YXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cdGFzdElmU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKkJyZWFrKiBTdGF0ZW1lbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGJyTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0QnJlYWtTdGF0ZW1lbnQoYnJOb2RlLCByZXRBcnIpIHtcblx0XHRyZXRBcnIucHVzaCgnYnJlYWs7Jyk7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKkNvbnRpbnVlKiBTdGF0ZW1lbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGNyTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0Q29udGludWVTdGF0ZW1lbnQoY3JOb2RlLCByZXRBcnIpIHtcblx0XHRyZXRBcnIucHVzaCgnY29udGludWU7XFxuJyk7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHRhc3RGb3JTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cdGFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHRhc3REb1doaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlZhcmlhYmxlIERlY2xhcmF0aW9uKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFyRGVjTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJEZWNOb2RlLCByZXRBcnIpIHtcblx0XHRjb25zdCBkZWNsYXJhdGlvbnMgPSB2YXJEZWNOb2RlLmRlY2xhcmF0aW9ucztcblx0XHRpZiAoIWRlY2xhcmF0aW9ucyB8fCAhZGVjbGFyYXRpb25zWzBdIHx8ICFkZWNsYXJhdGlvbnNbMF0uaW5pdCkge1xuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgdmFyRGVjTm9kZSk7XG5cdFx0fVxuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGNvbnN0IGZpcnN0RGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbnNbMF07XG5cdFx0Y29uc3QgaW5pdCA9IGZpcnN0RGVjbGFyYXRpb24uaW5pdDtcblx0XHRsZXQgdHlwZSA9IHRoaXMuaXNTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpID8gJ0ludGVnZXInIDogdGhpcy5nZXRUeXBlKGluaXQpO1xuXHRcdGlmICh0eXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG5cdFx0XHQvLyBXZSBoYWQgdGhlIGNob2ljZSB0byBnbyBlaXRoZXIgZmxvYXQgb3IgaW50LCBjaG9vc2luZyBmbG9hdFxuXHRcdFx0dHlwZSA9ICdOdW1iZXInO1xuXHRcdH1cblx0XHRjb25zdCBtYXJrdXBUeXBlID0gdHlwZU1hcFt0eXBlXTtcblx0XHRpZiAoIW1hcmt1cFR5cGUpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYE1hcmt1cCB0eXBlICR7IG1hcmt1cFR5cGUgfSBub3QgaGFuZGxlZGAsIHZhckRlY05vZGUpO1xuXHRcdH1cblx0XHRsZXQgZGVwZW5kZW5jaWVzID0gdGhpcy5nZXREZXBlbmRlbmNpZXMoZmlyc3REZWNsYXJhdGlvbi5pbml0KTtcblx0XHR0aGlzLmRlY2xhcmF0aW9uc1tmaXJzdERlY2xhcmF0aW9uLmlkLm5hbWVdID0gT2JqZWN0LmZyZWV6ZSh7XG5cdFx0XHR0eXBlLFxuXHRcdFx0ZGVwZW5kZW5jaWVzLFxuXHRcdFx0aXNTYWZlOiBkZXBlbmRlbmNpZXMuZXZlcnkoZGVwZW5kZW5jeSA9PiBkZXBlbmRlbmN5LmlzU2FmZSlcblx0XHR9KTtcblx0XHRjb25zdCBpbml0UmVzdWx0ID0gW2Ake3R5cGV9IHVzZXJfJHtmaXJzdERlY2xhcmF0aW9uLmlkLm5hbWV9PWBdO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhpbml0LCBpbml0UmVzdWx0KTtcblx0XHRyZXN1bHQucHVzaChpbml0UmVzdWx0LmpvaW4oJycpKTtcblxuXHRcdC8vIGZpcnN0IGRlY2xhcmF0aW9uIGlzIGRvbmUsIG5vdyBhbnkgYWRkZWQgb25lcyBzZXR1cFxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcblx0XHRcdGRlcGVuZGVuY2llcyA9IHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGRlY2xhcmF0aW9uKTtcblx0XHRcdHRoaXMuZGVjbGFyYXRpb25zW2RlY2xhcmF0aW9uLmlkLm5hbWVdID0gT2JqZWN0LmZyZWV6ZSh7XG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdGRlcGVuZGVuY2llcyxcblx0XHRcdFx0aXNTYWZlOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoZGVjbGFyYXRpb24sIHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0cmV0QXJyLnB1c2gocmV0QXJyLCByZXN1bHQuam9pbignLCcpKTtcblx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpWYXJpYWJsZSBEZWNsYXJhdG9yKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaVZhckRlY05vZGUgLSBBbiBhc3QgTm9kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcblx0ICovXG5cdGFzdFZhcmlhYmxlRGVjbGFyYXRvcihpVmFyRGVjTm9kZSwgcmV0QXJyKSB7XG5cdFx0dGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmlkLCByZXRBcnIpO1xuXHRcdGlmIChpVmFyRGVjTm9kZS5pbml0ICE9PSBudWxsKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgnPScpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmluaXQsIHJldEFycik7XG5cdFx0fVxuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0YXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cdGFzdFNlcXVlbmNlRXhwcmVzc2lvbihzTm9kZSwgcmV0QXJyKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzTm9kZS5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcsJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoc05vZGUuZXhwcmVzc2lvbnMsIHJldEFycik7XG5cdFx0fVxuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpVbmFyeSogRXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gdU5vZGUgLSBBbiBhc3QgTm9kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcblx0ICovXG5cdGFzdFVuYXJ5RXhwcmVzc2lvbih1Tm9kZSwgcmV0QXJyKSB7XG5cdFx0aWYgKHVOb2RlLnByZWZpeCkge1xuXHRcdFx0cmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlVwZGF0ZSogRXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gdU5vZGUgLSBBbiBhc3QgTm9kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcblx0ICovXG5cdGFzdFVwZGF0ZUV4cHJlc3Npb24odU5vZGUsIHJldEFycikge1xuXHRcdGlmICh1Tm9kZS5wcmVmaXgpIHtcblx0XHRcdHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpMb2dpY2FsKiBFeHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsb2dOb2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RMb2dpY2FsRXhwcmVzc2lvbihsb2dOb2RlLCByZXRBcnIpIHtcblx0XHRyZXRBcnIucHVzaCgnKCcpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLmxlZnQsIHJldEFycik7XG5cdFx0cmV0QXJyLnB1c2gobG9nTm9kZS5vcGVyYXRvcik7XG5cdFx0dGhpcy5hc3RHZW5lcmljKGxvZ05vZGUucmlnaHQsIHJldEFycik7XG5cdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cdGFzdE1lbWJlckV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cdGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXHRhc3RBcnJheUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0Z2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMoYXN0KSB7XG5cdFx0aWYgKGFzdC50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYEV4cHJlc3Npb24gJHsgYXN0LnR5cGUgfSBub3QgYSBNZW1iZXJFeHByZXNzaW9uYCwgYXN0KTtcblx0XHR9XG5cdFx0bGV0IG5hbWUgPSBudWxsO1xuXHRcdGxldCB0eXBlID0gbnVsbDtcblx0XHRjb25zdCB2YXJpYWJsZVNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcblx0XHRzd2l0Y2ggKHZhcmlhYmxlU2lnbmF0dXJlKSB7XG5cdFx0XHRjYXNlICd2YWx1ZSc6XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0Y2FzZSAndGhpcy50aHJlYWQudmFsdWUnOlxuXHRcdFx0Y2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG5cdFx0XHRcdFx0dHlwZTogJ0ludGVnZXInLFxuXHRcdFx0XHRcdG5hbWU6IGFzdC5wcm9wZXJ0eS5uYW1lXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICd2YWx1ZVtdJzpcblx0XHRcdFx0aWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuYW1lID0gYXN0Lm9iamVjdC5uYW1lO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0b3JpZ2luOiAndXNlcicsXG5cdFx0XHRcdFx0c2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcblx0XHRcdFx0XHR0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShuYW1lKSxcblx0XHRcdFx0XHR4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eVxuXHRcdFx0XHR9O1xuXHRcdFx0Y2FzZSAndmFsdWVbXVtdJzpcblx0XHRcdFx0aWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm5hbWU7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRvcmlnaW46ICd1c2VyJyxcblx0XHRcdFx0XHRzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuXHRcdFx0XHRcdHR5cGU6IHRoaXMuZ2V0VmFyaWFibGVUeXBlKG5hbWUpLFxuXHRcdFx0XHRcdHlQcm9wZXJ0eTogYXN0Lm9iamVjdC5wcm9wZXJ0eSxcblx0XHRcdFx0XHR4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcblx0XHRcdFx0fTtcblx0XHRcdGNhc2UgJ3ZhbHVlW11bXVtdJzpcblx0XHRcdFx0aWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdG9yaWdpbjogJ3VzZXInLFxuXHRcdFx0XHRcdHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG5cdFx0XHRcdFx0dHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUobmFtZSksXG5cdFx0XHRcdFx0elByb3BlcnR5OiBhc3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eSxcblx0XHRcdFx0XHR5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG5cdFx0XHRcdFx0eFByb3BlcnR5OiBhc3QucHJvcGVydHksXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICd2YWx1ZVtdW11bXVtdJzpcblx0XHRcdFx0aWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuYW1lID0gYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0b3JpZ2luOiAndXNlcicsXG5cdFx0XHRcdFx0c2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcblx0XHRcdFx0XHR0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShuYW1lKSxcblx0XHRcdFx0XHR6UHJvcGVydHk6IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5LFxuXHRcdFx0XHRcdHlQcm9wZXJ0eTogYXN0Lm9iamVjdC5wcm9wZXJ0eSxcblx0XHRcdFx0XHR4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcblx0XHRcdFx0fTtcblx0XHRcdGNhc2UgJ3ZhbHVlLnZhbHVlJzpcblx0XHRcdFx0aWYgKHR5cGVvZiBhc3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmlzQXN0TWF0aFZhcmlhYmxlKGFzdCkpIHtcblx0XHRcdFx0XHRuYW1lID0gYXN0LnByb3BlcnR5Lm5hbWU7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRvcmlnaW46ICdNYXRoJyxcblx0XHRcdFx0XHRcdHR5cGU6ICdOdW1iZXInLFxuXHRcdFx0XHRcdFx0c2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcblx0XHRcdFx0XHRjYXNlICdyJzpcblx0XHRcdFx0XHRjYXNlICdnJzpcblx0XHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0XHRcdG5hbWUgPSBhc3Qub2JqZWN0Lm5hbWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eTogYXN0LnByb3BlcnR5Lm5hbWUsXG5cdFx0XHRcdFx0XHRcdG9yaWdpbjogJ3VzZXInLFxuXHRcdFx0XHRcdFx0XHRzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiAnTnVtYmVyJ1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAndGhpcy5jb25zdGFudHMudmFsdWUnOlxuXHRcdFx0XHRpZiAodHlwZW9mIGFzdC5wcm9wZXJ0eS5uYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmFtZSA9IGFzdC5wcm9wZXJ0eS5uYW1lO1xuXHRcdFx0XHR0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG5cdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0dHlwZSxcblx0XHRcdFx0XHRvcmlnaW46ICdjb25zdGFudHMnLFxuXHRcdFx0XHRcdHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJzpcblx0XHRcdFx0aWYgKHR5cGVvZiBhc3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuYW1lID0gYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuXHRcdFx0XHR0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG5cdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0dHlwZSxcblx0XHRcdFx0XHRvcmlnaW46ICdjb25zdGFudHMnLFxuXHRcdFx0XHRcdHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG5cdFx0XHRcdFx0eFByb3BlcnR5OiBhc3QucHJvcGVydHksXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWU7XG5cdFx0XHRcdFx0dHlwZSA9IHRoaXMuZ2V0Q29uc3RhbnRUeXBlKG5hbWUpO1xuXHRcdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnQ29uc3RhbnQgaGFzIG5vIHR5cGUnLCBhc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdHR5cGUsXG5cdFx0XHRcdFx0XHRvcmlnaW46ICdjb25zdGFudHMnLFxuXHRcdFx0XHRcdFx0c2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcblx0XHRcdFx0XHRcdHlQcm9wZXJ0eTogYXN0Lm9iamVjdC5wcm9wZXJ0eSxcblx0XHRcdFx0XHRcdHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuYW1lID0gYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWU7XG5cdFx0XHRcdFx0dHlwZSA9IHRoaXMuZ2V0Q29uc3RhbnRUeXBlKG5hbWUpO1xuXHRcdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnQ29uc3RhbnQgaGFzIG5vIHR5cGUnLCBhc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdHR5cGUsXG5cdFx0XHRcdFx0XHRvcmlnaW46ICdjb25zdGFudHMnLFxuXHRcdFx0XHRcdFx0c2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcblx0XHRcdFx0XHRcdHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG5cdFx0XHRcdFx0XHR5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG5cdFx0XHRcdFx0XHR4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlICdmbigpW10nOlxuXHRcdFx0Y2FzZSAnW11bXSc6XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0c2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcblx0XHRcdFx0XHRwcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuXHRcdFx0XHR9O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcblx0XHR9XG5cdH1cblxuXHRmaW5kSWRlbnRpZmllck9yaWdpbihhc3RUb0ZpbmQpIHtcblx0XHRjb25zdCBzdGFjayA9IFt0aGlzLmFzdF07XG5cblx0XHR3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHRcdFx0Y29uc3QgYXROb2RlID0gc3RhY2tbMF07XG5cdFx0XHRpZiAoYXROb2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InICYmIGF0Tm9kZS5pZCAmJiBhdE5vZGUuaWQubmFtZSAmJiBhdE5vZGUuaWQubmFtZSA9PT0gYXN0VG9GaW5kLm5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGF0Tm9kZTtcblx0XHRcdH1cblx0XHRcdHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRpZiAoYXROb2RlLmFyZ3VtZW50KSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goYXROb2RlLmFyZ3VtZW50KTtcblx0XHRcdH0gZWxzZSBpZiAoYXROb2RlLmJvZHkpIHtcblx0XHRcdFx0c3RhY2sucHVzaChhdE5vZGUuYm9keSk7XG5cdFx0XHR9IGVsc2UgaWYgKGF0Tm9kZS5kZWNsYXJhdGlvbnMpIHtcblx0XHRcdFx0c3RhY2sucHVzaChhdE5vZGUuZGVjbGFyYXRpb25zKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhdE5vZGUpKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXROb2RlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChhdE5vZGVbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZmluZExhc3RSZXR1cm4oYXN0KSB7XG5cdFx0Y29uc3Qgc3RhY2sgPSBbYXN0IHx8IHRoaXMuYXN0XTtcblxuXHRcdHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBhdE5vZGUgPSBzdGFjay5wb3AoKTtcblx0XHRcdGlmIChhdE5vZGUudHlwZSA9PT0gJ1JldHVyblN0YXRlbWVudCcpIHtcblx0XHRcdFx0cmV0dXJuIGF0Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmIChhdE5vZGUuYXJndW1lbnQpIHtcblx0XHRcdFx0c3RhY2sucHVzaChhdE5vZGUuYXJndW1lbnQpO1xuXHRcdFx0fSBlbHNlIGlmIChhdE5vZGUuYm9keSkge1xuXHRcdFx0XHRzdGFjay5wdXNoKGF0Tm9kZS5ib2R5KTtcblx0XHRcdH0gZWxzZSBpZiAoYXROb2RlLmRlY2xhcmF0aW9ucykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGF0Tm9kZS5kZWNsYXJhdGlvbnMpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGF0Tm9kZSkpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhdE5vZGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzdGFjay5wdXNoKGF0Tm9kZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXROb2RlLmNvbnNlcXVlbnQpIHtcblx0XHRcdFx0c3RhY2sucHVzaChhdE5vZGUuY29uc2VxdWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Z2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUobmFtZSkge1xuXHRcdGlmICghdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHR0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXNbbmFtZV0gPSAwO1xuXHRcdH1cblx0XHR0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXNbbmFtZV0rKztcblx0XHRpZiAodGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWUgKyB0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXNbbmFtZV07XG5cdH1cblxuXHR2YXJXYXJuKCkge1xuXHRcdGNvbnNvbGUud2FybigndmFyIGRlY2xhcmF0aW9ucyBhcmUgZGVwcmVjYXRlZCwgd2VpcmQgdGhpbmdzIGhhcHBlbiB3aGVuIGZhbGxpbmcgYmFjayB0byBDUFUgYmVjYXVzZSB2YXIgc2NvcGUgZGlmZmVycyBpbiBqYXZhc2NyaXB0IHRoYW4gaW4gbW9zdCBsYW5ndWFnZXMuICBVc2UgY29uc3Qgb3IgbGV0Jyk7XG5cdH1cbn1cblxuY29uc3QgdHlwZUxvb2t1cE1hcCA9IHtcblx0J0FycmF5JzogJ051bWJlcicsXG5cdCdBcnJheSgyKSc6ICdOdW1iZXInLFxuXHQnQXJyYXkoMyknOiAnTnVtYmVyJyxcblx0J0FycmF5KDQpJzogJ051bWJlcicsXG5cdCdBcnJheTJEJzogJ051bWJlcicsXG5cdCdBcnJheTNEJzogJ051bWJlcicsXG5cdCdJbnB1dCc6ICdOdW1iZXInLFxuXHQnSFRNTEltYWdlJzogJ0FycmF5KDQpJyxcblx0J0hUTUxJbWFnZUFycmF5JzogJ0FycmF5KDQpJyxcblx0J051bWJlclRleHR1cmUnOiAnTnVtYmVyJyxcblx0J01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiAnTnVtYmVyJyxcblx0J0FycmF5VGV4dHVyZSgxKSc6ICdOdW1iZXInLFxuXHQnQXJyYXlUZXh0dXJlKDIpJzogJ0FycmF5KDIpJyxcblx0J0FycmF5VGV4dHVyZSgzKSc6ICdBcnJheSgzKScsXG5cdCdBcnJheVRleHR1cmUoNCknOiAnQXJyYXkoNCknLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdEZ1bmN0aW9uTm9kZVxufTsiLCJjb25zdCB7XG5cdEtlcm5lbFxufSA9IHJlcXVpcmUoJy4va2VybmVsJyk7XG5cbmNvbnN0IHtcblx0VGV4dHVyZVxufSA9IHJlcXVpcmUoJy4uL3RleHR1cmUnKTtcblxuY29uc3Qge1xuXHR1dGlsc1xufSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEdMS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcblx0c3RhdGljIGdldCBtb2RlKCkge1xuXHRcdHJldHVybiAnZ3B1Jztcblx0fVxuXG5cdHN0YXRpYyBnZXRJc0Zsb2F0UmVhZCgpIHtcblx0XHRjb25zdCBrZXJuZWxTdHJpbmcgPSBgZnVuY3Rpb24ga2VybmVsRnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9YDtcblx0XHRjb25zdCBrZXJuZWwgPSBuZXcgdGhpcyhrZXJuZWxTdHJpbmcsIHtcblx0XHRcdGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG5cdFx0XHRjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcblx0XHRcdHZhbGlkYXRlOiBmYWxzZSxcblx0XHRcdG91dHB1dDogWzFdLFxuXHRcdFx0cHJlY2lzaW9uOiAnc2luZ2xlJyxcblx0XHRcdC8vVE9ETzogbm90IHN1cmUgaG93IHRvIGhhbmRsZT9cblx0XHRcdGZsb2F0T3V0cHV0Rm9yY2U6IHRydWUsXG5cdFx0XHRyZXR1cm5UeXBlOiAnTnVtYmVyJ1xuXHRcdH0pO1xuXHRcdGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5ydW4oKTtcblx0XHRrZXJuZWwuZGVzdHJveSh0cnVlKTtcblx0XHRyZXR1cm4gcmVzdWx0WzBdID09PSAxO1xuXHR9XG5cblx0c3RhdGljIGdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSB7XG5cdFx0ZnVuY3Rpb24ga2VybmVsRnVuY3Rpb24odjEsIHYyKSB7XG5cdFx0XHRyZXR1cm4gdjFbdGhpcy50aHJlYWQueF0gLyB2Mlt0aGlzLnRocmVhZC54XTtcblx0XHR9XG5cdFx0Y29uc3Qga2VybmVsID0gbmV3IHRoaXMoa2VybmVsRnVuY3Rpb24udG9TdHJpbmcoKSwge1xuXHRcdFx0Y29udGV4dDogdGhpcy50ZXN0Q29udGV4dCxcblx0XHRcdGNhbnZhczogdGhpcy50ZXN0Q2FudmFzLFxuXHRcdFx0dmFsaWRhdGU6IGZhbHNlLFxuXHRcdFx0b3V0cHV0OiBbMl0sXG5cdFx0XHRyZXR1cm5UeXBlOiAnTnVtYmVyJyxcblx0XHRcdHByZWNpc2lvbjogJ3Vuc2lnbmVkJyxcblx0XHR9KTtcblx0XHRjb25zdCByZXN1bHQgPSBrZXJuZWwucnVuKFs2LCA2MDMwNDAxXSwgWzMsIDM5OTFdKTtcblx0XHRrZXJuZWwuZGVzdHJveSh0cnVlKTtcblx0XHQvLyBoYXZlIHdlIG5vdCBnb3Qgd2hvbGUgbnVtYmVycyBmb3IgNi8zIG9yIDYwMzA0MDEvMzk5MVxuXHRcdC8vIGFkZCBtb3JlIGhlcmUgaWYgb3RoZXJzIHNlZSB0aGlzIHByb2JsZW1cblx0XHRyZXR1cm4gcmVzdWx0WzBdID09PSAyICYmIHJlc3VsdFsxXSA9PT0gMTUxMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICovXG5cdHN0YXRpYyBnZXQgdGVzdENhbnZhcygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwidGVzdENhbnZhc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG5cdH1cblxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgXCJ0ZXN0Q29udGV4dFwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG5cdH1cblxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgXCJmZWF0dXJlc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG5cdH1cblxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqL1xuXHRzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgXCJzZXR1cEZlYXR1cmVDaGVja3NcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEZpeCBkaXZpc2lvbiBieSBmYWN0b3Igb2YgMyBGUCBhY2N1cmFjeSBidWdcblx0ICogQHBhcmFtIHtCb29sZWFufSBmaXggLSBzaG91bGQgZml4XG5cdCAqL1xuXHRzZXRGaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeShmaXgpIHtcblx0XHR0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZml4O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFRvZ2dsZSBvdXRwdXQgbW9kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZmxhZyAtICdzaW5nbGUnIG9yICd1bnNpZ25lZCdcblx0ICovXG5cdHNldFByZWNpc2lvbihmbGFnKSB7XG5cdFx0dGhpcy5wcmVjaXNpb24gPSBmbGFnO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gVE9ETzogbm90IHN1cmUgaG93IHRvIGhhbmRsZVxuXHRzZXRGbG9hdE91dHB1dEZvcmNlKGZsYWcpIHtcblx0XHR0aGlzLmZsb2F0T3V0cHV0Rm9yY2UgPSBmbGFnO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFRvZ2dsZSB0ZXh0dXJlIG91dHB1dCBtb2RlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZmxhZyAtIHRydWUgdG8gZW5hYmxlIGZsb2F0VGV4dHVyZXNcblx0ICovXG5cdHNldEZsb2F0VGV4dHVyZXMoZmxhZykge1xuXHRcdHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0RmxvYXRUZXh0dXJlcycsICdzZXRPcHRpbWl6ZUZsb2F0TWVtb3J5Jyk7XG5cdFx0dGhpcy5mbG9hdFRleHR1cmVzID0gZmxhZztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHNldE9wdGltaXplRmxvYXRNZW1vcnkoZmxhZykge1xuXHRcdHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IGZsYWc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQSBoaWdobHkgcmVhZGFibGUgdmVyeSBmb3JnaXZpbmcgbWljcm8tcGFyc2VyIGZvciBhIGdsc2wgZnVuY3Rpb24gdGhhdCBnZXRzIGFyZ3VtZW50IHR5cGVzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2Vcblx0ICogQHJldHVybnMge3thcmd1bWVudFR5cGVzOiBTdHJpbmdbXSwgYXJndW1lbnROYW1lczogU3RyaW5nW119fVxuXHQgKi9cblx0c3RhdGljIG5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKHNvdXJjZSkge1xuXHRcdGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBbXTtcblx0XHRjb25zdCBhcmd1bWVudE5hbWVzID0gW107XG5cdFx0Y29uc3Qgc3RhdGVzID0gW107XG5cdFx0Y29uc3QgaXNTdGFydGluZ1ZhcmlhYmxlTmFtZSA9IC9eW2EtekEtWl9dLztcblx0XHRjb25zdCBpc1ZhcmlhYmxlQ2hhciA9IC9bYS16QS1aXzAtOV0vO1xuXHRcdGxldCBpID0gMDtcblx0XHRsZXQgYXJndW1lbnROYW1lID0gbnVsbDtcblx0XHRsZXQgYXJndW1lbnRUeXBlID0gbnVsbDtcblx0XHR3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IGNoYXIgPSBzb3VyY2VbaV07XG5cdFx0XHRjb25zdCBuZXh0Q2hhciA9IHNvdXJjZVtpICsgMV07XG5cdFx0XHRjb25zdCBzdGF0ZSA9IHN0YXRlcy5sZW5ndGggPiAwID8gc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXSA6IG51bGw7XG5cblx0XHRcdC8vIGJlZ2luIE1VTFRJX0xJTkVfQ09NTUVOVCBoYW5kbGluZ1xuXHRcdFx0aWYgKHN0YXRlID09PSAnRlVOQ1RJT05fQVJHVU1FTlRTJyAmJiBjaGFyID09PSAnLycgJiYgbmV4dENoYXIgPT09ICcqJykge1xuXHRcdFx0XHRzdGF0ZXMucHVzaCgnTVVMVElfTElORV9DT01NRU5UJyk7XG5cdFx0XHRcdGkgKz0gMjtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSAnTVVMVElfTElORV9DT01NRU5UJyAmJiBjaGFyID09PSAnKicgJiYgbmV4dENoYXIgPT09ICcvJykge1xuXHRcdFx0XHRzdGF0ZXMucG9wKCk7XG5cdFx0XHRcdGkgKz0gMjtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBlbmQgTVVMVElfTElORV9DT01NRU5UIGhhbmRsaW5nXG5cblx0XHRcdC8vIGJlZ2luIENPTU1FTlQgaGFuZGxpbmdcblx0XHRcdGVsc2UgaWYgKHN0YXRlID09PSAnRlVOQ1RJT05fQVJHVU1FTlRTJyAmJiBjaGFyID09PSAnLycgJiYgbmV4dENoYXIgPT09ICcvJykge1xuXHRcdFx0XHRzdGF0ZXMucHVzaCgnQ09NTUVOVCcpO1xuXHRcdFx0XHRpICs9IDI7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gJ0NPTU1FTlQnICYmIGNoYXIgPT09ICdcXG4nKSB7XG5cdFx0XHRcdHN0YXRlcy5wb3AoKTtcblx0XHRcdFx0aSsrO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdC8vIGVuZCBDT01NRU5UIGhhbmRsaW5nXG5cblx0XHRcdC8vIGJlaW5nIEZVTkNUSU9OX0FSR1VNRU5UUyBoYW5kbGluZ1xuXHRcdFx0ZWxzZSBpZiAoc3RhdGUgPT09IG51bGwgJiYgY2hhciA9PT0gJygnKSB7XG5cdFx0XHRcdHN0YXRlcy5wdXNoKCdGVU5DVElPTl9BUkdVTUVOVFMnKTtcblx0XHRcdFx0aSsrO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnKSB7XG5cdFx0XHRcdGlmIChjaGFyID09PSAnKScpIHtcblx0XHRcdFx0XHRzdGF0ZXMucG9wKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNoYXIgPT09ICdmJyAmJiBuZXh0Q2hhciA9PT0gJ2wnICYmIHNvdXJjZVtpICsgMl0gPT09ICdvJyAmJiBzb3VyY2VbaSArIDNdID09PSAnYScgJiYgc291cmNlW2kgKyA0XSA9PT0gJ3QnICYmIHNvdXJjZVtpICsgNV0gPT09ICcgJykge1xuXHRcdFx0XHRcdHN0YXRlcy5wdXNoKCdERUNMQVJFX1ZBUklBQkxFJyk7XG5cdFx0XHRcdFx0YXJndW1lbnRUeXBlID0gJ2Zsb2F0Jztcblx0XHRcdFx0XHRhcmd1bWVudE5hbWUgPSAnJztcblx0XHRcdFx0XHRpICs9IDY7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hhciA9PT0gJ2knICYmIG5leHRDaGFyID09PSAnbicgJiYgc291cmNlW2kgKyAyXSA9PT0gJ3QnICYmIHNvdXJjZVtpICsgM10gPT09ICcgJykge1xuXHRcdFx0XHRcdHN0YXRlcy5wdXNoKCdERUNMQVJFX1ZBUklBQkxFJyk7XG5cdFx0XHRcdFx0YXJndW1lbnRUeXBlID0gJ2ludCc7XG5cdFx0XHRcdFx0YXJndW1lbnROYW1lID0gJyc7XG5cdFx0XHRcdFx0aSArPSA0O1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNoYXIgPT09ICd2JyAmJiBuZXh0Q2hhciA9PT0gJ2UnICYmIHNvdXJjZVtpICsgMl0gPT09ICdjJyAmJiBzb3VyY2VbaSArIDNdID09PSAnMicgJiYgc291cmNlW2kgKyA0XSA9PT0gJyAnKSB7XG5cdFx0XHRcdFx0c3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcblx0XHRcdFx0XHRhcmd1bWVudFR5cGUgPSAndmVjMic7XG5cdFx0XHRcdFx0YXJndW1lbnROYW1lID0gJyc7XG5cdFx0XHRcdFx0aSArPSA1O1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNoYXIgPT09ICd2JyAmJiBuZXh0Q2hhciA9PT0gJ2UnICYmIHNvdXJjZVtpICsgMl0gPT09ICdjJyAmJiBzb3VyY2VbaSArIDNdID09PSAnMycgJiYgc291cmNlW2kgKyA0XSA9PT0gJyAnKSB7XG5cdFx0XHRcdFx0c3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcblx0XHRcdFx0XHRhcmd1bWVudFR5cGUgPSAndmVjMyc7XG5cdFx0XHRcdFx0YXJndW1lbnROYW1lID0gJyc7XG5cdFx0XHRcdFx0aSArPSA1O1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNoYXIgPT09ICd2JyAmJiBuZXh0Q2hhciA9PT0gJ2UnICYmIHNvdXJjZVtpICsgMl0gPT09ICdjJyAmJiBzb3VyY2VbaSArIDNdID09PSAnNCcgJiYgc291cmNlW2kgKyA0XSA9PT0gJyAnKSB7XG5cdFx0XHRcdFx0c3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcblx0XHRcdFx0XHRhcmd1bWVudFR5cGUgPSAndmVjNCc7XG5cdFx0XHRcdFx0YXJndW1lbnROYW1lID0gJyc7XG5cdFx0XHRcdFx0aSArPSA1O1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBlbmQgRlVOQ1RJT05fQVJHVU1FTlRTIGhhbmRsaW5nXG5cblx0XHRcdC8vIGJlZ2luIERFQ0xBUkVfVkFSSUFCTEUgaGFuZGxpbmdcblx0XHRcdGVsc2UgaWYgKHN0YXRlID09PSAnREVDTEFSRV9WQVJJQUJMRScpIHtcblx0XHRcdFx0aWYgKGFyZ3VtZW50TmFtZSA9PT0gJycpIHtcblx0XHRcdFx0XHRpZiAoY2hhciA9PT0gJyAnKSB7XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFpc1N0YXJ0aW5nVmFyaWFibGVOYW1lLnRlc3QoY2hhcikpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigndmFyaWFibGUgbmFtZSBpcyBub3QgZXhwZWN0ZWQgc3RyaW5nJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFyZ3VtZW50TmFtZSArPSBjaGFyO1xuXHRcdFx0XHRpZiAoIWlzVmFyaWFibGVDaGFyLnRlc3QobmV4dENoYXIpKSB7XG5cdFx0XHRcdFx0c3RhdGVzLnBvcCgpO1xuXHRcdFx0XHRcdGFyZ3VtZW50TmFtZXMucHVzaChhcmd1bWVudE5hbWUpO1xuXHRcdFx0XHRcdGFyZ3VtZW50VHlwZXMucHVzaCh0eXBlTWFwW2FyZ3VtZW50VHlwZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBlbmQgREVDTEFSRV9WQVJJQUJMRSBoYW5kbGluZ1xuXG5cdFx0XHQvLyBQcm9ncmVzcyB0byBuZXh0IGNoYXJhY3RlclxuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHRpZiAoc3RhdGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignR0xTTCBmdW5jdGlvbiB3YXMgbm90IHBhcnNhYmxlJyk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRhcmd1bWVudE5hbWVzLFxuXHRcdFx0YXJndW1lbnRUeXBlcyxcblx0XHR9O1xuXHR9XG5cblx0c3RhdGljIG5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShzb3VyY2UpIHtcblx0XHRyZXR1cm4gdHlwZU1hcFtzb3VyY2UubWF0Y2goL2ludHxmbG9hdHx2ZWNbMi00XS8pWzBdXTtcblx0fVxuXG5cdHN0YXRpYyBjb21iaW5lS2VybmVscyhjb21iaW5lZEtlcm5lbCwgbGFzdEtlcm5lbCkge1xuXHRcdGNvbWJpbmVkS2VybmVsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0Y29uc3Qge1xuXHRcdFx0dGV4U2l6ZSxcblx0XHRcdGNvbnRleHQsXG5cdFx0XHR0aHJlYWREaW1cblx0XHR9ID0gbGFzdEtlcm5lbC50ZXhTaXplO1xuXHRcdGxldCByZXN1bHQ7XG5cdFx0aWYgKGxhc3RLZXJuZWwucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuXHRcdFx0Y29uc3QgdyA9IHRleFNpemVbMF07XG5cdFx0XHRjb25zdCBoID0gTWF0aC5jZWlsKHRleFNpemVbMV0gLyA0KTtcblx0XHRcdHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0ICogNCk7XG5cdFx0XHRjb250ZXh0LnJlYWRQaXhlbHMoMCwgMCwgdywgaCAqIDQsIGNvbnRleHQuUkdCQSwgY29udGV4dC5GTE9BVCwgcmVzdWx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuXHRcdFx0Y29udGV4dC5yZWFkUGl4ZWxzKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIGNvbnRleHQuUkdCQSwgY29udGV4dC5VTlNJR05FRF9CWVRFLCBieXRlcyk7XG5cdFx0XHRyZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVzLmJ1ZmZlcik7XG5cdFx0fVxuXG5cdFx0cmVzdWx0ID0gcmVzdWx0LnN1YmFycmF5KDAsIHRocmVhZERpbVswXSAqIHRocmVhZERpbVsxXSAqIHRocmVhZERpbVsyXSk7XG5cblx0XHRpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0gZWxzZSBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRyZXR1cm4gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RLZXJuZWwub3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuXHRcdFx0Y29uc3QgY3ViZSA9IHV0aWxzLnNwbGl0QXJyYXkocmVzdWx0LCBsYXN0S2VybmVsLm91dHB1dFswXSAqIGxhc3RLZXJuZWwub3V0cHV0WzFdKTtcblx0XHRcdHJldHVybiBjdWJlLm1hcChmdW5jdGlvbih4KSB7XG5cdFx0XHRcdHJldHVybiB1dGlscy5zcGxpdEFycmF5KHgsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcblx0XHRzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcblx0XHR0aGlzLnRleFNpemUgPSBudWxsO1xuXHRcdC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0byBoYW5kbGVcblx0XHR0aGlzLmZsb2F0T3V0cHV0Rm9yY2UgPSBudWxsO1xuXHRcdHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBudWxsO1xuXHRcdHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IG51bGw7XG5cdFx0dGhpcy5yZW5kZXJTdHJhdGVneSA9IG51bGw7XG5cdFx0dGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyID0gbnVsbDtcblxuXHRcdHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IG51bGw7XG5cdH1cblxuXHR0cmFuc2xhdGVTb3VyY2UoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBcInRyYW5zbGF0ZVNvdXJjZVwiIG5vdCBkZWZpbmVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuXHR9XG5cblx0cGlja1JlbmRlclN0cmF0ZWd5KGFyZ3MpIHtcblx0XHQvLyBUT0RPOiByZXBsYWNlIGJvb2xlYW4gcmV0dXJucyB3aXRoIHNldHRpbmcgYSBzdGF0ZSB0aGF0IGJlbG9uZ3Mgb24gdGhpcyB0aGF0IHJlcHJlc2VudHMgdGhlIG5lZWQgZm9yIGZhbGxiYWNrXG5cdFx0aWYgKHRoaXMuZ3JhcGhpY2FsKSByZXR1cm47XG5cdFx0aWYgKHRoaXMucHJlY2lzaW9uID09PSAndW5zaWduZWQnKSB7XG5cdFx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0XHRjYXNlICdMaXRlcmFsSW50ZWdlcic6XG5cdFx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRcdFx0aWYgKHRoaXMucGlwZWxpbmUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5QYWNrZWRUZXh0dXJlO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclRleHR1cmU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5QYWNrZWRQaXhlbFRvM0RGbG9hdDtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXIzRFBhY2tlZEZsb2F0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlclN0cmF0ZWd5ID0gcmVuZGVyU3RyYXRlZ3kuUGFja2VkUGl4ZWxUbzJERmxvYXQ7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyMkRQYWNrZWRGbG9hdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJTdHJhdGVneSA9IHJlbmRlclN0cmF0ZWd5LlBhY2tlZFBpeGVsVG9GbG9hdDtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJQYWNrZWRGbG9hdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0XHRjYXNlICdBcnJheSg0KSc6XG5cdFx0XHRcdFx0dGhpcy5vblJlcXVlc3RGYWxsYmFjayhhcmdzKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdGlmICh0aGlzLnBpcGVsaW5lKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5GbG9hdFRleHR1cmU7XG5cdFx0XHRcdHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJUZXh0dXJlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG5cdFx0XHRcdGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcblx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0XHRpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5NZW1vcnlPcHRpbWl6ZWRGbG9hdFBpeGVsVG9NZW1vcnlPcHRpbWl6ZWQzREZsb2F0O1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyTWVtb3J5T3B0aW1pemVkM0RGbG9hdDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5GbG9hdFBpeGVsVG8zREZsb2F0O1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyM0RGbG9hdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbmRlclN0cmF0ZWd5ID0gcmVuZGVyU3RyYXRlZ3kuTWVtb3J5T3B0aW1pemVkRmxvYXRQaXhlbFRvTWVtb3J5T3B0aW1pemVkMkRGbG9hdDtcblx0XHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlck1lbW9yeU9wdGltaXplZDJERmxvYXQ7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbmRlclN0cmF0ZWd5ID0gcmVuZGVyU3RyYXRlZ3kuRmxvYXRQaXhlbFRvMkRGbG9hdDtcblx0XHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlcjJERmxvYXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJTdHJhdGVneSA9IHJlbmRlclN0cmF0ZWd5Lk1lbW9yeU9wdGltaXplZEZsb2F0UGl4ZWxUb01lbW9yeU9wdGltaXplZEZsb2F0O1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyTWVtb3J5T3B0aW1pemVkRmxvYXQ7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbmRlclN0cmF0ZWd5ID0gcmVuZGVyU3RyYXRlZ3kuRmxvYXRQaXhlbFRvRmxvYXQ7XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJGbG9hdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdFx0XHRpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlclN0cmF0ZWd5ID0gcmVuZGVyU3RyYXRlZ3kuRmxvYXRQaXhlbFRvM0RBcnJheTI7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyM0RBcnJheTI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5GbG9hdFBpeGVsVG8yREFycmF5Mjtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXIyREFycmF5Mjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJTdHJhdGVneSA9IHJlbmRlclN0cmF0ZWd5LkZsb2F0UGl4ZWxUb0FycmF5Mjtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJBcnJheTI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRjYXNlICdBcnJheSgzKSc6XG5cdFx0XHRcdFx0aWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJTdHJhdGVneSA9IHJlbmRlclN0cmF0ZWd5LkZsb2F0UGl4ZWxUbzNEQXJyYXkzO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlcjNEQXJyYXkzO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlclN0cmF0ZWd5ID0gcmVuZGVyU3RyYXRlZ3kuRmxvYXRQaXhlbFRvMkRBcnJheTM7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyMkRBcnJheTM7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5GbG9hdFBpeGVsVG9BcnJheTM7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyQXJyYXkzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0XHRcdGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneS5GbG9hdFBpeGVsVG8zREFycmF5NDtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXIzREFycmF5NDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJTdHJhdGVneSA9IHJlbmRlclN0cmF0ZWd5LkZsb2F0UGl4ZWxUbzJEQXJyYXk0O1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlcjJEQXJyYXk0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlclN0cmF0ZWd5ID0gcmVuZGVyU3RyYXRlZ3kuRmxvYXRQaXhlbFRvQXJyYXk0O1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlckFycmF5NDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHByZWNpc2lvbiBvZiBcIiR7dGhpcy5wcmVjaXNpb259XCJgKTtcblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSBcIiR7dGhpcy5yZXR1cm5UeXBlfVwiYCk7XG5cdH1cblxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqIEByZXR1cm5zIFN0cmluZ1xuXHQgKi9cblx0Z2V0S2VybmVsU3RyaW5nKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRUZXh0dXJlKCkge1xuXHRcdHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG5cdFx0XHRjYXNlICdMaXRlcmFsSW50ZWdlcic6XG5cdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldE1haW5SZXN1bHROdW1iZXJUZXh0dXJlKCk7XG5cdFx0XHRjYXNlICdBcnJheSgyKSc6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRBcnJheTJUZXh0dXJlKCk7XG5cdFx0XHRjYXNlICdBcnJheSgzKSc6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRBcnJheTNUZXh0dXJlKCk7XG5cdFx0XHRjYXNlICdBcnJheSg0KSc6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRBcnJheTRUZXh0dXJlKCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCByZXR1cm5UeXBlIHR5cGUgJHsgdGhpcy5yZXR1cm5UeXBlIH1gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqIEByZXR1cm5zIFN0cmluZ1tdXG5cdCAqL1xuXHRnZXRNYWluUmVzdWx0S2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG5cdH1cblx0LyoqXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcmV0dXJucyBTdHJpbmdbXVxuXHQgKi9cblx0Z2V0TWFpblJlc3VsdFN1Yktlcm5lbE51bWJlclRleHR1cmUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuXHR9XG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybnMgU3RyaW5nW11cblx0ICovXG5cdGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcblx0fVxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqIEByZXR1cm5zIFN0cmluZ1tdXG5cdCAqL1xuXHRnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG5cdH1cblx0LyoqXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcmV0dXJucyBTdHJpbmdbXVxuXHQgKi9cblx0Z2V0TWFpblJlc3VsdEtlcm5lbEFycmF5M1RleHR1cmUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuXHR9XG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybnMgU3RyaW5nW11cblx0ICovXG5cdGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcblx0fVxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqIEByZXR1cm5zIFN0cmluZ1tdXG5cdCAqL1xuXHRnZXRNYWluUmVzdWx0S2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG5cdH1cblx0LyoqXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcmV0dXJucyBTdHJpbmdbXVxuXHQgKi9cblx0Z2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5NFRleHR1cmUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuXHR9XG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybnMgU3RyaW5nW11cblx0ICovXG5cdGdldE1haW5SZXN1bHRHcmFwaGljYWwoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuXHR9XG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybnMgU3RyaW5nW11cblx0ICovXG5cdGdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuXHR9XG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybnMgU3RyaW5nW11cblx0ICovXG5cdGdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdFN0cmluZygpIHtcblx0XHRpZiAodGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRHcmFwaGljYWwoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuXHRcdFx0aWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0TWVtb3J5T3B0aW1pemVkRmxvYXRzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0VGV4dHVyZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0UGFja2VkUGl4ZWxzKCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0TWFpblJlc3VsdE51bWJlclRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsTnVtYmVyVGV4dHVyZSgpKSArXG5cdFx0XHR1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE51bWJlclRleHR1cmUoKSk7XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0QXJyYXkyVGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkpICtcblx0XHRcdHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpKTtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRBcnJheTNUZXh0dXJlKCkge1xuXHRcdHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5M1RleHR1cmUoKSkgK1xuXHRcdFx0dXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTNUZXh0dXJlKCkpO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEFycmF5NFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsQXJyYXk0VGV4dHVyZSgpKSArXG5cdFx0XHR1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5NFRleHR1cmUoKSk7XG5cdH1cblxuXHRnZXRSZXR1cm5UZXh0dXJlVHlwZSgpIHtcblx0XHRpZiAodGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdHJldHVybiAnQXJyYXlUZXh0dXJlKDQpJztcblx0XHR9XG5cdFx0aWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuXHRcdFx0c3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ0FycmF5VGV4dHVyZSgxKSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdBcnJheSgyKSc6XG5cdFx0XHRcdFx0cmV0dXJuICdBcnJheVRleHR1cmUoMiknO1xuXHRcdFx0XHRjYXNlICdBcnJheSgzKSc6XG5cdFx0XHRcdFx0cmV0dXJuICdBcnJheVRleHR1cmUoMyknO1xuXHRcdFx0XHRjYXNlICdBcnJheSg0KSc6XG5cdFx0XHRcdFx0cmV0dXJuICdBcnJheVRleHR1cmUoNCknO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgcmV0dXJuVHlwZSAke3RoaXMucmV0dXJuVHlwZX1gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0XHRyZXR1cm4gJ051bWJlclRleHR1cmUnO1xuXHRcdFx0XHRjYXNlICdBcnJheSgyKSc6XG5cdFx0XHRcdGNhc2UgJ0FycmF5KDMpJzpcblx0XHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgcmV0dXJuVHlwZSAkeyB0aGlzLnJldHVyblR5cGUgfWApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJlbmRlclRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBUZXh0dXJlKHtcblx0XHRcdHRleHR1cmU6IHRoaXMub3V0cHV0VGV4dHVyZSxcblx0XHRcdHNpemU6IHRoaXMudGV4U2l6ZSxcblx0XHRcdGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuXHRcdFx0b3V0cHV0OiB0aGlzLm91dHB1dCxcblx0XHRcdGNvbnRleHQ6IHRoaXMuY29udGV4dCxcblx0XHRcdGdwdTogdGhpcy5ncHUsXG5cdFx0XHR0eXBlOiB0aGlzLmdldFJldHVyblRleHR1cmVUeXBlKCksXG5cdFx0fSk7XG5cdH1cblx0cmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheSgpIHtcblx0XHRpZiAodGhpcy5wcmVjaXNpb24gIT09ICd1bnNpZ25lZCcpIHRocm93IG5ldyBFcnJvcignUmVxdWlyZXMgdGhpcy5wcmVjaXNpb24gdG8gYmUgXCJ1bnNpZ25lZFwiJyk7XG5cdFx0Y29uc3Qge1xuXHRcdFx0dGV4U2l6ZSxcblx0XHRcdGNvbnRleHQ6IGdsXG5cdFx0fSA9IHRoaXM7XG5cdFx0Y29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodGV4U2l6ZVswXSAqIHRleFNpemVbMV0gKiA0KTtcblx0XHRnbC5yZWFkUGl4ZWxzKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHJlc3VsdCk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRyZWFkUGFja2VkUGl4ZWxzVG9GbG9hdDMyQXJyYXkoKSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5KCkuYnVmZmVyKTtcblx0fVxuXHRyZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpIHtcblx0XHRpZiAodGhpcy5wcmVjaXNpb24gIT09ICdzaW5nbGUnKSB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVzIHRoaXMucHJlY2lzaW9uIHRvIGJlIFwic2luZ2xlXCInKTtcblx0XHRjb25zdCB7XG5cdFx0XHR0ZXhTaXplLFxuXHRcdFx0Y29udGV4dDogZ2xcblx0XHR9ID0gdGhpcztcblx0XHRjb25zdCB3ID0gdGV4U2l6ZVswXTtcblx0XHRjb25zdCBoID0gdGV4U2l6ZVsxXTtcblx0XHRjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHcgKiBoICogNCk7XG5cdFx0Z2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnbC5GTE9BVCwgcmVzdWx0KTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdHJlYWRNZW1vcnlPcHRpbWl6ZWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCkge1xuXHRcdGlmICh0aGlzLnByZWNpc2lvbiAhPT0gJ3NpbmdsZScpIHRocm93IG5ldyBFcnJvcignUmVxdWlyZXMgdGhpcy5wcmVjaXNpb24gdG8gYmUgXCJzaW5nbGVcIicpO1xuXHRcdGNvbnN0IHtcblx0XHRcdHRleFNpemUsXG5cdFx0XHRjb250ZXh0OiBnbFxuXHRcdH0gPSB0aGlzO1xuXHRcdGNvbnN0IHcgPSB0ZXhTaXplWzBdO1xuXHRcdGNvbnN0IGggPSB0ZXhTaXplWzFdO1xuXHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0KTtcblx0XHRnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdsLkZMT0FULCByZXN1bHQpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0cmVuZGVyUGFja2VkRmxvYXQoKSB7XG5cdFx0Y29uc3QgW3hNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0cmV0dXJuIHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvRmxvYXQzMkFycmF5KCkuc3ViYXJyYXkoMCwgeE1heCk7XG5cdH1cblx0cmVuZGVyMkRQYWNrZWRGbG9hdCgpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRQYWNrZWRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpO1xuXHRcdGNvbnN0IFt4TWF4LCB5TWF4XSA9IHRoaXMub3V0cHV0O1xuXHRcdGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KHlNYXgpO1xuXHRcdGZvciAobGV0IHkgPSAwOyB5IDwgeU1heDsgeSsrKSB7XG5cdFx0XHRjb25zdCB4U3RhcnQgPSB5ICogeE1heDtcblx0XHRcdGNvbnN0IHhFbmQgPSB4U3RhcnQgKyB4TWF4O1xuXHRcdFx0eVJlc3VsdHNbeV0gPSBwaXhlbHMuc3ViYXJyYXkoeFN0YXJ0LCB4RW5kKTtcblx0XHR9XG5cdFx0cmV0dXJuIHlSZXN1bHRzO1xuXHR9XG5cdHJlbmRlcjNEUGFja2VkRmxvYXQoKSB7XG5cdFx0Y29uc3QgcGl4ZWxzID0gdGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9GbG9hdDMyQXJyYXkoKTtcblx0XHRjb25zdCBbeE1heCwgeU1heCwgek1heF0gPSB0aGlzLm91dHB1dDtcblx0XHRjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheSh6TWF4KTtcblx0XHRmb3IgKGxldCB6ID0gMDsgeiA8IHpNYXg7IHorKykge1xuXHRcdFx0Y29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoeU1heCk7XG5cdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8IHlNYXg7IHkrKykge1xuXHRcdFx0XHRjb25zdCB4U3RhcnQgPSAoeiAqIHlNYXggKiB4TWF4KSArIHkgKiB4TWF4O1xuXHRcdFx0XHRjb25zdCB4RW5kID0geFN0YXJ0ICsgeE1heDtcblx0XHRcdFx0eVJlc3VsdHNbeV0gPSBwaXhlbHMuc3ViYXJyYXkoeFN0YXJ0LCB4RW5kKTtcblx0XHRcdH1cblx0XHRcdHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG5cdFx0fVxuXHRcdHJldHVybiB6UmVzdWx0cztcblx0fVxuXHRyZW5kZXJGbG9hdCgpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHhNYXgpO1xuXHRcdGxldCBpID0gMDtcblx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHhNYXg7IHgrKykge1xuXHRcdFx0eFJlc3VsdHNbeF0gPSBwaXhlbHNbaV07XG5cdFx0XHRpICs9IDQ7XG5cdFx0fVxuXHRcdHJldHVybiB4UmVzdWx0cztcblx0fVxuXHRyZW5kZXJNZW1vcnlPcHRpbWl6ZWRGbG9hdCgpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRNZW1vcnlPcHRpbWl6ZWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0cmV0dXJuIHBpeGVscy5zdWJhcnJheSgwLCB4TWF4KTtcblx0fVxuXHRyZW5kZXIyREZsb2F0KCkge1xuXHRcdGNvbnN0IHBpeGVscyA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXkoKTtcblx0XHRjb25zdCBbeE1heCwgeU1heF0gPSB0aGlzLm91dHB1dDtcblx0XHRjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheSh5TWF4KTtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCB5TWF4OyB5KyspIHtcblx0XHRcdGNvbnN0IHhSZXN1bHRzID0gbmV3IEZsb2F0MzJBcnJheSh4TWF4KTtcblx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgeE1heDsgeCsrKSB7XG5cdFx0XHRcdHhSZXN1bHRzW3hdID0gcGl4ZWxzW2ldO1xuXHRcdFx0XHRpICs9IDQ7XG5cdFx0XHR9XG5cdFx0XHR5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuXHRcdH1cblx0XHRyZXR1cm4geVJlc3VsdHM7XG5cdH1cblx0cmVuZGVyTWVtb3J5T3B0aW1pemVkMkRGbG9hdCgpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXgsIHlNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoeU1heCk7XG5cdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCB5TWF4OyB5KyspIHtcblx0XHRcdGNvbnN0IG9mZnNldCA9IHkgKiB4TWF4O1xuXHRcdFx0eVJlc3VsdHNbeV0gPSBwaXhlbHMuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyB4TWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHlSZXN1bHRzO1xuXHR9XG5cdHJlbmRlcjNERmxvYXQoKSB7XG5cdFx0Y29uc3QgcGl4ZWxzID0gdGhpcy5yZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpO1xuXHRcdGNvbnN0IFt4TWF4LCB5TWF4LCB6TWF4XSA9IHRoaXMub3V0cHV0O1xuXHRcdGNvbnN0IHpSZXN1bHRzID0gbmV3IEFycmF5KHpNYXgpO1xuXHRcdGxldCBpID0gMDtcblx0XHRmb3IgKGxldCB6ID0gMDsgeiA8IHpNYXg7IHorKykge1xuXHRcdFx0Y29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoeU1heCk7XG5cdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8IHlNYXg7IHkrKykge1xuXHRcdFx0XHRjb25zdCB4UmVzdWx0cyA9IG5ldyBGbG9hdDMyQXJyYXkoeE1heCk7XG5cdFx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgeE1heDsgeCsrKSB7XG5cdFx0XHRcdFx0eFJlc3VsdHNbeF0gPSBwaXhlbHNbaV07XG5cdFx0XHRcdFx0aSArPSA0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHlSZXN1bHRzW3ldID0geFJlc3VsdHM7XG5cdFx0XHR9XG5cdFx0XHR6UmVzdWx0c1t6XSA9IHlSZXN1bHRzO1xuXHRcdH1cblx0XHRyZXR1cm4gelJlc3VsdHM7XG5cdH1cblx0cmVuZGVyTWVtb3J5T3B0aW1pemVkM0RGbG9hdCgpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXgsIHlNYXgsIHpNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoek1heCk7XG5cdFx0Zm9yIChsZXQgeiA9IDA7IHogPCB6TWF4OyB6KyspIHtcblx0XHRcdGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KHlNYXgpO1xuXHRcdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCB5TWF4OyB5KyspIHtcblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gKHogKiB5TWF4ICogeE1heCkgKyAoeSAqIHhNYXgpO1xuXHRcdFx0XHR5UmVzdWx0c1t5XSA9IHBpeGVscy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHhNYXgpO1xuXHRcdFx0fVxuXHRcdFx0elJlc3VsdHNbel0gPSB5UmVzdWx0cztcblx0XHR9XG5cdFx0cmV0dXJuIHpSZXN1bHRzO1xuXHR9XG5cdHJlbmRlckFycmF5MigpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkoeE1heCk7XG5cdFx0Y29uc3QgeFJlc3VsdHNNYXggPSB4TWF4ICogNDtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Zm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG5cdFx0XHR4UmVzdWx0c1tpKytdID0gcGl4ZWxzLnN1YmFycmF5KHgsIHggKyAyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHhSZXN1bHRzO1xuXHR9XG5cdHJlbmRlcjJEQXJyYXkyKCkge1xuXHRcdGNvbnN0IHBpeGVscyA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXkoKTtcblx0XHRjb25zdCBbeE1heCwgeU1heF0gPSB0aGlzLm91dHB1dDtcblx0XHRjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheSh5TWF4KTtcblx0XHRjb25zdCBYUmVzdWx0c01heCA9IHhNYXggKiA0O1xuXHRcdGZvciAobGV0IHkgPSAwOyB5IDwgeU1heDsgeSsrKSB7XG5cdFx0XHRjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh4TWF4KTtcblx0XHRcdGxldCBpID0gMDtcblx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgWFJlc3VsdHNNYXg7IHggKz0gNCkge1xuXHRcdFx0XHR4UmVzdWx0c1tpKytdID0gcGl4ZWxzLnN1YmFycmF5KHgsIHggKyAyKTtcblx0XHRcdH1cblx0XHRcdHlSZXN1bHRzW3ldID0geFJlc3VsdHM7XG5cdFx0fVxuXHRcdHJldHVybiB5UmVzdWx0cztcblx0fVxuXHRyZW5kZXIzREFycmF5MigpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXgsIHlNYXgsIHpNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgeFJlc3VsdHNNYXggPSB4TWF4ICogNDtcblx0XHRjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheSh6TWF4KTtcblx0XHRmb3IgKGxldCB6ID0gMDsgeiA8IHpNYXg7IHorKykge1xuXHRcdFx0Y29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoeU1heCk7XG5cdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8IHlNYXg7IHkrKykge1xuXHRcdFx0XHRjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh4TWF4KTtcblx0XHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHhSZXN1bHRzTWF4OyB4ICs9IDQpIHtcblx0XHRcdFx0XHR4UmVzdWx0c1tpKytdID0gcGl4ZWxzLnN1YmFycmF5KHgsIHggKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuXHRcdFx0fVxuXHRcdFx0elJlc3VsdHNbel0gPSB5UmVzdWx0cztcblx0XHR9XG5cdFx0cmV0dXJuIHpSZXN1bHRzO1xuXHR9XG5cdHJlbmRlckFycmF5MygpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkoeE1heCk7XG5cdFx0Y29uc3QgeFJlc3VsdHNNYXggPSB4TWF4ICogNDtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Zm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG5cdFx0XHR4UmVzdWx0c1tpKytdID0gcGl4ZWxzLnN1YmFycmF5KHgsIHggKyAzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHhSZXN1bHRzO1xuXHR9XG5cdHJlbmRlcjJEQXJyYXkzKCkge1xuXHRcdGNvbnN0IHBpeGVscyA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXkoKTtcblx0XHRjb25zdCBbeE1heCwgeU1heF0gPSB0aGlzLm91dHB1dDtcblx0XHRjb25zdCB4TWF4UmVzdWx0cyA9IHhNYXggKiA0O1xuXHRcdGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KHlNYXgpO1xuXHRcdGZvciAobGV0IHkgPSAwOyB5IDwgeU1heDsgeSsrKSB7XG5cdFx0XHRjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh4TWF4KTtcblx0XHRcdGxldCBpID0gMDtcblx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgeE1heFJlc3VsdHM7IHggKz0gNCkge1xuXHRcdFx0XHR4UmVzdWx0c1tpKytdID0gcGl4ZWxzLnN1YmFycmF5KHgsIHggKyAzKTtcblx0XHRcdH1cblx0XHRcdHlSZXN1bHRzW3ldID0geFJlc3VsdHM7XG5cdFx0fVxuXHRcdHJldHVybiB5UmVzdWx0cztcblx0fVxuXHRyZW5kZXIzREFycmF5MygpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXgsIHlNYXgsIHpNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgeE1heFJlc3VsdHMgPSB4TWF4ICogNDtcblx0XHRjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheSh6TWF4KTtcblx0XHRmb3IgKGxldCB6ID0gMDsgeiA8IHpNYXg7IHorKykge1xuXHRcdFx0Y29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoeU1heCk7XG5cdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8IHlNYXg7IHkrKykge1xuXHRcdFx0XHRjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh4TWF4KTtcblx0XHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHhNYXhSZXN1bHRzOyB4ICs9IDQpIHtcblx0XHRcdFx0XHR4UmVzdWx0c1tpKytdID0gcGl4ZWxzLnN1YmFycmF5KHgsIHggKyAzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuXHRcdFx0fVxuXHRcdFx0elJlc3VsdHNbel0gPSB5UmVzdWx0cztcblx0XHR9XG5cdFx0cmV0dXJuIHpSZXN1bHRzO1xuXHR9XG5cdHJlbmRlckFycmF5NCgpIHtcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCk7XG5cdFx0Y29uc3QgW3hNYXhdID0gdGhpcy5vdXRwdXQ7XG5cdFx0Y29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkoeE1heCk7XG5cdFx0Y29uc3QgeFJlc3VsdHNNYXggPSB4TWF4ICogNDtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Zm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG5cdFx0XHR4UmVzdWx0c1tpKytdID0gcGl4ZWxzLnN1YmFycmF5KHgsIHggKyA0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHhSZXN1bHRzO1xuXHR9XG5cdHJlbmRlcjJEQXJyYXk0KCkge1xuXHRcdGNvbnN0IHBpeGVscyA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXkoKTtcblx0XHRjb25zdCBbeE1heCwgeU1heF0gPSB0aGlzLm91dHB1dDtcblx0XHRjb25zdCB4TWF4UmVzdWx0ID0geE1heCAqIDQ7XG5cdFx0Y29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoeU1heCk7XG5cdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCB5TWF4OyB5KyspIHtcblx0XHRcdGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHhNYXgpO1xuXHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0Zm9yIChsZXQgeCA9IDA7IHggPCB4TWF4UmVzdWx0OyB4ICs9IDQpIHtcblx0XHRcdFx0eFJlc3VsdHNbaSsrXSA9IHBpeGVscy5zdWJhcnJheSh4LCB4ICsgNCk7XG5cdFx0XHR9XG5cdFx0XHR5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuXHRcdH1cblx0XHRyZXR1cm4geVJlc3VsdHM7XG5cdH1cblx0cmVuZGVyM0RBcnJheTQoKSB7XG5cdFx0Y29uc3QgcGl4ZWxzID0gdGhpcy5yZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpO1xuXHRcdGNvbnN0IFt4TWF4LCB5TWF4LCB6TWF4XSA9IHRoaXMub3V0cHV0O1xuXHRcdGNvbnN0IHhSZXN1bHRzTWFwID0geE1heCAqIDQ7XG5cdFx0Y29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoek1heCk7XG5cdFx0Zm9yIChsZXQgeiA9IDA7IHogPCB6TWF4OyB6KyspIHtcblx0XHRcdGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KHlNYXgpO1xuXHRcdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCB5TWF4OyB5KyspIHtcblx0XHRcdFx0Y29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkoeE1heCk7XG5cdFx0XHRcdGxldCBpID0gMDtcblx0XHRcdFx0Zm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01hcDsgeCArPSA0KSB7XG5cdFx0XHRcdFx0eFJlc3VsdHNbaSsrXSA9IHBpeGVscy5zdWJhcnJheSh4LCB4ICsgNCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0eVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcblx0XHRcdH1cblx0XHRcdHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG5cdFx0fVxuXHRcdHJldHVybiB6UmVzdWx0cztcblx0fVxuXHRnZXRQaXhlbHMoKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0Y29udGV4dDogZ2wsXG5cdFx0XHRvdXRwdXRcblx0XHR9ID0gdGhpcztcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBvdXRwdXQ7XG5cdFx0Y29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcblx0XHRnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XG5cdFx0cmV0dXJuIHBpeGVscztcblx0fVxufVxuXG5jb25zdCByZW5kZXJTdHJhdGVneSA9IE9iamVjdC5mcmVlemUoe1xuXHRQYWNrZWRQaXhlbFRvVWludDhBcnJheTogU3ltYm9sKCdQYWNrZWRQaXhlbFRvVWludDhBcnJheScpLFxuXHRQYWNrZWRQaXhlbFRvRmxvYXQ6IFN5bWJvbCgnUGFja2VkUGl4ZWxUb0Zsb2F0JyksXG5cdFBhY2tlZFBpeGVsVG8yREZsb2F0OiBTeW1ib2woJ1BhY2tlZFBpeGVsVG8yREZsb2F0JyksXG5cdFBhY2tlZFBpeGVsVG8zREZsb2F0OiBTeW1ib2woJ1BhY2tlZFBpeGVsVG8zREZsb2F0JyksXG5cdFBhY2tlZFRleHR1cmU6IFN5bWJvbCgnUGFja2VkVGV4dHVyZScpLFxuXHRGbG9hdFBpeGVsVG9GbG9hdDMyQXJyYXk6IFN5bWJvbCgnRmxvYXRQaXhlbFRvRmxvYXQzMkFycmF5JyksXG5cdEZsb2F0UGl4ZWxUb0Zsb2F0OiBTeW1ib2woJ0Zsb2F0UGl4ZWxUb0Zsb2F0JyksXG5cdEZsb2F0UGl4ZWxUbzJERmxvYXQ6IFN5bWJvbCgnRmxvYXRQaXhlbFRvMkRGbG9hdCcpLFxuXHRGbG9hdFBpeGVsVG8zREZsb2F0OiBTeW1ib2woJ0Zsb2F0UGl4ZWxUbzNERmxvYXQnKSxcblx0RmxvYXRQaXhlbFRvQXJyYXkyOiBTeW1ib2woJ0Zsb2F0UGl4ZWxUb0FycmF5MicpLFxuXHRGbG9hdFBpeGVsVG8yREFycmF5MjogU3ltYm9sKCdGbG9hdFBpeGVsVG8yREFycmF5MicpLFxuXHRGbG9hdFBpeGVsVG8zREFycmF5MjogU3ltYm9sKCdGbG9hdFBpeGVsVG8zREFycmF5MicpLFxuXHRGbG9hdFBpeGVsVG9BcnJheTM6IFN5bWJvbCgnRmxvYXRQaXhlbFRvQXJyYXkzJyksXG5cdEZsb2F0UGl4ZWxUbzJEQXJyYXkzOiBTeW1ib2woJ0Zsb2F0UGl4ZWxUbzJEQXJyYXkzJyksXG5cdEZsb2F0UGl4ZWxUbzNEQXJyYXkzOiBTeW1ib2woJ0Zsb2F0UGl4ZWxUbzNEQXJyYXkzJyksXG5cdEZsb2F0UGl4ZWxUb0FycmF5NDogU3ltYm9sKCdGbG9hdFBpeGVsVG9BcnJheTQnKSxcblx0RmxvYXRQaXhlbFRvMkRBcnJheTQ6IFN5bWJvbCgnRmxvYXRQaXhlbFRvMkRBcnJheTQnKSxcblx0RmxvYXRQaXhlbFRvM0RBcnJheTQ6IFN5bWJvbCgnRmxvYXRQaXhlbFRvM0RBcnJheTQnKSxcblx0RmxvYXRUZXh0dXJlOiBTeW1ib2woJ0Zsb2F0VGV4dHVyZScpLFxuXHRNZW1vcnlPcHRpbWl6ZWRGbG9hdFBpeGVsVG9NZW1vcnlPcHRpbWl6ZWRGbG9hdDogU3ltYm9sKCdNZW1vcnlPcHRpbWl6ZWRGbG9hdFBpeGVsVG9GbG9hdCcpLFxuXHRNZW1vcnlPcHRpbWl6ZWRGbG9hdFBpeGVsVG9NZW1vcnlPcHRpbWl6ZWQyREZsb2F0OiBTeW1ib2woJ01lbW9yeU9wdGltaXplZEZsb2F0UGl4ZWxUbzJERmxvYXQnKSxcblx0TWVtb3J5T3B0aW1pemVkRmxvYXRQaXhlbFRvTWVtb3J5T3B0aW1pemVkM0RGbG9hdDogU3ltYm9sKCdNZW1vcnlPcHRpbWl6ZWRGbG9hdFBpeGVsVG8zREZsb2F0JyksXG59KTtcblxuY29uc3QgdHlwZU1hcCA9IHtcblx0aW50OiAnSW50ZWdlcicsXG5cdGZsb2F0OiAnTnVtYmVyJyxcblx0dmVjMjogJ0FycmF5KDIpJyxcblx0dmVjMzogJ0FycmF5KDMpJyxcblx0dmVjNDogJ0FycmF5KDQpJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRHTEtlcm5lbCxcblx0cmVuZGVyU3RyYXRlZ3lcbn07IiwiY29uc3QgZ2V0Q29udGV4dCA9IHJlcXVpcmUoJ2dsJyk7XG5jb25zdCB7XG5cdFdlYkdMS2VybmVsXG59ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2tlcm5lbCcpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jbGFzcyBIZWFkbGVzc0dMS2VybmVsIGV4dGVuZHMgV2ViR0xLZXJuZWwge1xuXHRzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuXHRcdGlmIChpc1N1cHBvcnRlZCAhPT0gbnVsbCkgcmV0dXJuIGlzU3VwcG9ydGVkO1xuXHRcdHRoaXMuc2V0dXBGZWF0dXJlQ2hlY2tzKCk7XG5cdFx0aXNTdXBwb3J0ZWQgPSB0ZXN0Q29udGV4dCAhPT0gbnVsbDtcblx0XHRyZXR1cm4gaXNTdXBwb3J0ZWQ7XG5cdH1cblxuXHRzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuXHRcdHRlc3RDYW52YXMgPSBudWxsO1xuXHRcdHRlc3RFeHRlbnNpb25zID0gbnVsbDtcblx0XHRpZiAodHlwZW9mIGdldENvbnRleHQgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblx0XHR0cnkgeyAvLyBqdXN0IGluIGNhc2UsIGVkZ2UgY2FzZXNcblx0XHRcdHRlc3RDb250ZXh0ID0gZ2V0Q29udGV4dCgyLCAyLCB7XG5cdFx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoIXRlc3RDb250ZXh0IHx8ICF0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24pIHJldHVybjtcblx0XHRcdHRlc3RFeHRlbnNpb25zID0ge1xuXHRcdFx0XHRTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXInKSxcblx0XHRcdFx0U1RBQ0tHTF9kZXN0cm95X2NvbnRleHQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKSxcblx0XHRcdFx0T0VTX3RleHR1cmVfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcblx0XHRcdFx0T0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuXHRcdFx0XHRPRVNfZWxlbWVudF9pbmRleF91aW50OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSxcblx0XHRcdFx0V0VCR0xfZHJhd19idWZmZXJzOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuXHRcdFx0fTtcblx0XHRcdGZlYXR1cmVzID0gdGhpcy5nZXRGZWF0dXJlcygpO1xuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRQYXJhbWV0ZXIoY29udGV4dC5SRU5ERVJFUikgPT09ICdBTkdMRSc7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcblx0XHRjb25zdCBpc0RyYXdCdWZmZXJzID0gdGhpcy5nZXRJc0RyYXdCdWZmZXJzKCk7XG5cdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoe1xuXHRcdFx0aXNGbG9hdFJlYWQ6IHRoaXMuZ2V0SXNGbG9hdFJlYWQoKSxcblx0XHRcdGlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU6IHRoaXMuZ2V0SXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZSgpLFxuXHRcdFx0aXNUZXh0dXJlRmxvYXQ6IHRoaXMuZ2V0SXNUZXh0dXJlRmxvYXQoKSxcblx0XHRcdGlzRHJhd0J1ZmZlcnMsXG5cdFx0XHRrZXJuZWxNYXA6IGlzRHJhd0J1ZmZlcnNcblx0XHR9KTtcblx0fVxuXG5cdHN0YXRpYyBnZXRJc1RleHR1cmVGbG9hdCgpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0SXNEcmF3QnVmZmVycygpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMpO1xuXHR9XG5cblx0c3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuXHRcdHJldHVybiB0ZXN0Q2FudmFzO1xuXHR9XG5cblx0c3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcblx0XHRyZXR1cm4gdGVzdENvbnRleHQ7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuXHRcdHJldHVybiBmZWF0dXJlcztcblx0fVxuXG5cdGluaXRDYW52YXMoKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0aW5pdENvbnRleHQoKSB7XG5cdFx0Y29uc3QgY29udGV4dCA9IGdldENvbnRleHQoMiwgMiwge1xuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIGNvbnRleHQ7XG5cdH1cblxuXHRpbml0RXh0ZW5zaW9ucygpIHtcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7XG5cdFx0XHRTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyJyksXG5cdFx0XHRTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKSxcblx0XHRcdE9FU190ZXh0dXJlX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpLFxuXHRcdFx0T0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcblx0XHRcdE9FU19lbGVtZW50X2luZGV4X3VpbnQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSxcblx0XHRcdFdFQkdMX2RyYXdfYnVmZmVyczogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyksXG5cdFx0fTtcblx0fVxuXG5cdGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuXHRcdHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyID0gbnVsbDtcblx0XHR0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQgPSBudWxsO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCA9IG51bGw7XG5cdFx0dGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciA9IG51bGw7XG5cdFx0dGhpcy5leHRlbnNpb25zLk9FU19lbGVtZW50X2luZGV4X3VpbnQgPSBudWxsO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgPSBudWxsO1xuXHR9XG5cblx0c3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcblx0XHRjb25zdCBleHRlbnNpb24gPSBjb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKTtcblx0XHRpZiAoZXh0ZW5zaW9uICYmIGV4dGVuc2lvbi5kZXN0cm95KSB7XG5cdFx0XHRleHRlbnNpb24uZGVzdHJveSgpO1xuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0SGVhZGxlc3NHTEtlcm5lbFxufTsiLCJjb25zdCB7XG5cdHV0aWxzXG59ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IHtcblx0SW5wdXRcbn0gPSByZXF1aXJlKCcuLi9pbnB1dCcpO1xuXG5jbGFzcyBLZXJuZWwge1xuXHQvKipcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgXCJpc1N1cHBvcnRlZFwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwiaXNDb250ZXh0TWF0Y2hcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcblx0fVxuXG5cdHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0RmVhdHVyZXNcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcblx0fVxuXG5cdHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBcImRlc3Ryb3lDb250ZXh0XCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG5cdH1cblxuXHRzdGF0aWMgbmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBcIm5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzXCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG5cdH1cblxuXHRzdGF0aWMgbmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgXCJuYXRpdmVGdW5jdGlvblJldHVyblR5cGVcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcblx0fVxuXG5cdHN0YXRpYyBjb21iaW5lS2VybmVscygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwiY29tYmluZUtlcm5lbHNcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNvdXJjZVxuXHQgKiBAcGFyYW0gW3NldHRpbmdzXVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0aWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignc291cmNlIG5vdCBhIHN0cmluZycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF1dGlscy5pc0Z1bmN0aW9uU3RyaW5nKHNvdXJjZSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdzb3VyY2Ugbm90IGEgZnVuY3Rpb24gc3RyaW5nJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5vblJlcXVlc3RGYWxsYmFjayA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBOYW1lIG9mIHRoZSBhcmd1bWVudHMgZm91bmQgZnJvbSBwYXJzaW5nIHNvdXJjZSBhcmd1bWVudFxuXHRcdCAqIEB0eXBlIHtTdHJpbmdbXX1cblx0XHQgKi9cblx0XHR0aGlzLmFyZ3VtZW50TmFtZXMgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHNvdXJjZSkgOiBudWxsO1xuXHRcdHRoaXMuYXJndW1lbnRUeXBlcyA9IG51bGw7XG5cdFx0dGhpcy5hcmd1bWVudFNpemVzID0gbnVsbDtcblx0XHR0aGlzLmFyZ3VtZW50Qml0UmF0aW9zID0gbnVsbDtcblx0XHR0aGlzLmFyZ3VtZW50c0xlbmd0aCA9IDA7XG5cdFx0dGhpcy5jb25zdGFudHNMZW5ndGggPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZnVuY3Rpb24gc291cmNlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwncyBvdXRwdXRcblx0XHQgKiBAdHlwZSB7TnVtYmVyW119XG5cdFx0ICovXG5cdFx0dGhpcy5vdXRwdXQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVidWcgbW9kZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuZGVidWcgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEdyYXBoaWNhbCBtb2RlXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5ncmFwaGljYWwgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIE1heGltdW0gbG9vcHMgd2hlbiB1c2luZyBhcmd1bWVudCB2YWx1ZXMgdG8gcHJldmVudCBpbmZpbml0eVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBDb25zdGFudHMgdXNlZCBpbiBrZXJuZWwgdmlhIGB0aGlzLmNvbnN0YW50c2Bcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuY29uc3RhbnRzID0gbnVsbDtcblx0XHR0aGlzLmNvbnN0YW50VHlwZXMgPSBudWxsO1xuXHRcdHRoaXMuY29uc3RhbnRCaXRSYXRpb3MgPSBudWxsO1xuXHRcdHRoaXMuaGFyZGNvZGVDb25zdGFudHMgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmNhbnZhcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZXh0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0dQVX1cblx0XHQgKi9cblx0XHR0aGlzLmdwdSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtJR1BVRnVuY3Rpb25bXX1cblx0XHQgKi9cblx0XHR0aGlzLmZ1bmN0aW9ucyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtJR1BVTmF0aXZlRnVuY3Rpb25bXX1cblx0XHQgKi9cblx0XHR0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtJU3ViS2VybmVsW119XG5cdFx0ICovXG5cdFx0dGhpcy5zdWJLZXJuZWxzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy52YWxpZGF0ZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBFbmZvcmNlcyBrZXJuZWwgdG8gd3JpdGUgdG8gYSBuZXcgYXJyYXkgb3IgdGV4dHVyZSBvbiBydW5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLmltbXV0YWJsZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5mb3JjZXMga2VybmVsIHRvIHdyaXRlIHRvIGEgdGV4dHVyZSBvbiBydW5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLnBpcGVsaW5lID0gZmFsc2U7XG5cdFx0dGhpcy5wcmVjaXNpb24gPSBudWxsO1xuXG5cdFx0dGhpcy5wbHVnaW5zID0gbnVsbDtcblxuXHRcdHRoaXMucmV0dXJuVHlwZSA9IG51bGw7XG5cdFx0dGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50ID0gbnVsbDtcblx0XHR0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG5cdH1cblxuXHRtZXJnZVNldHRpbmdzKHNldHRpbmdzKSB7XG5cdFx0Zm9yIChsZXQgcCBpbiBzZXR0aW5ncykge1xuXHRcdFx0aWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwKSB8fCAhdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG5cdFx0XHRpZiAocCA9PT0gJ291dHB1dCcpIHtcblx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHNldHRpbmdzLm91dHB1dCkpIHtcblx0XHRcdFx0XHR0aGlzLnNldE91dHB1dChzZXR0aW5ncy5vdXRwdXQpOyAvLyBGbGF0dGVuIG91dHB1dCBvYmplY3Rcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChwID09PSAnZnVuY3Rpb25zJyAmJiB0eXBlb2Ygc2V0dGluZ3MuZnVuY3Rpb25zWzBdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRoaXMuZnVuY3Rpb25zID0gc2V0dGluZ3MuZnVuY3Rpb25zLm1hcChzb3VyY2UgPT4gdXRpbHMuZnVuY3Rpb25Ub0lGdW5jdGlvbihzb3VyY2UpKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzW3BdID0gc2V0dGluZ3NbcF07XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgdGhpcy5jYW52YXMgPSB0aGlzLmluaXRDYW52YXMoKTtcblx0XHRpZiAoIXRoaXMuY29udGV4dCkgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0Q29udGV4dCgpO1xuXHRcdGlmICghdGhpcy5wbHVnaW5zKSB0aGlzLnBsdWdpbnMgPSB0aGlzLmluaXRQbHVnaW5zKHNldHRpbmdzKTtcblx0fVxuXHQvKipcblx0ICogQGRlc2MgQnVpbGRzIHRoZSBLZXJuZWwsIGJ5IGNvbXBpbGluZyBGcmFnbWVudCBhbmQgVmVydGljYWwgU2hhZGVycyxcblx0ICogYW5kIGluc3RhbnRpYXRlcyB0aGUgcHJvZ3JhbS5cblx0ICogQGFic3RyYWN0XG5cdCAqL1xuXHRidWlsZCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwiYnVpbGRcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFJ1biB0aGUga2VybmVsIHByb2dyYW0sIGFuZCBzZW5kIHRoZSBvdXRwdXQgdG8gcmVuZGVyT3V0cHV0XG5cdCAqIDxwPiBUaGlzIG1ldGhvZCBjYWxscyBhIGhlbHBlciBtZXRob2QgKnJlbmRlck91dHB1dCogdG8gcmV0dXJuIHRoZSByZXN1bHQuIDwvcD5cblx0ICogQHJldHVybnMge0Zsb2F0MzJBcnJheXxGbG9hdDMyQXJyYXlbXXxGbG9hdDMyQXJyYXlbXVtdfHZvaWR9IFJlc3VsdCBUaGUgZmluYWwgb3V0cHV0IG9mIHRoZSBwcm9ncmFtLCBhcyBmbG9hdCwgYW5kIGFzIFRleHR1cmVzIGZvciByZXVzZS5cblx0ICogQGFic3RyYWN0XG5cdCAqL1xuXHRydW4oKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBcInJ1blwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YClcblx0fVxuXG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0aW5pdENhbnZhcygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwiaW5pdENhbnZhc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG5cdH1cblxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICovXG5cdGluaXRDb250ZXh0KCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgXCJpbml0Q29udGV4dFwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJRnVuY3Rpb25TZXR0aW5nc30gc2V0dGluZ3Ncblx0ICogQHJldHVybiB7T2JqZWN0fTtcblx0ICogQGFic3RyYWN0XG5cdCAqL1xuXHRpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgXCJpbml0UGx1Z2luc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgU2V0dXAgdGhlIHBhcmFtZXRlciB0eXBlcyBmb3IgdGhlIHBhcmFtZXRlcnNcblx0ICogc3VwcGxpZWQgdG8gdGhlIEtlcm5lbCBmdW5jdGlvblxuXHQgKlxuXHQgKiBAcGFyYW0ge0lBcmd1bWVudHN9IGFyZ3MgLSBUaGUgYWN0dWFsIHBhcmFtZXRlcnMgc2VudCB0byB0aGUgS2VybmVsXG5cdCAqL1xuXHRzZXR1cEFyZ3VtZW50cyhhcmdzKSB7XG5cdFx0aWYgKCF0aGlzLmFyZ3VtZW50VHlwZXMpIHtcblx0XHRcdHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnc1tpXSk7XG5cdFx0XHRcdHRoaXMuYXJndW1lbnRUeXBlcy5wdXNoKGFyZ1R5cGUgPT09ICdJbnRlZ2VyJyA/ICdOdW1iZXInIDogYXJnVHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc2V0dXAgc2l6ZXNcblx0XHR0aGlzLmFyZ3VtZW50U2l6ZXMgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuXHRcdHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBuZXcgSW50MzJBcnJheShhcmdzLmxlbmd0aCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGFyZyA9IGFyZ3NbaV07XG5cdFx0XHR0aGlzLmFyZ3VtZW50U2l6ZXNbaV0gPSBhcmcuY29uc3RydWN0b3IgPT09IElucHV0ID8gYXJnLnNpemUgOiBudWxsO1xuXHRcdFx0dGhpcy5hcmd1bWVudEJpdFJhdGlvc1tpXSA9IHRoaXMuZ2V0Qml0UmF0aW8oYXJnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgYXJndW1lbnRzIGFyZSBtaXNzLWFsaWduZWRgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0dXAgY29uc3RhbnRzXG5cdCAqL1xuXHRzZXR1cENvbnN0YW50cygpIHtcblx0XHR0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcblx0XHR0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG5cdFx0aWYgKHRoaXMuY29uc3RhbnRzKSB7XG5cdFx0XHRmb3IgKGxldCBwIGluIHRoaXMuY29uc3RhbnRzKSB7XG5cdFx0XHRcdHRoaXMuY29uc3RhbnRUeXBlc1twXSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh0aGlzLmNvbnN0YW50c1twXSk7XG5cdFx0XHRcdHRoaXMuY29uc3RhbnRCaXRSYXRpb3NbcF0gPSB0aGlzLmdldEJpdFJhdGlvKHRoaXMuY29uc3RhbnRzW3BdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIGZsYWdcblx0ICogQHJldHVybnMge0tlcm5lbH1cblx0ICovXG5cdHNldE9wdGltaXplRmxvYXRNZW1vcnkoZmxhZykge1xuXHRcdHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IGZsYWc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgU2V0IG91dHB1dCBkaW1lbnNpb25zIG9mIHRoZSBrZXJuZWwgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG91dHB1dCAtIFRoZSBvdXRwdXQgYXJyYXkgdG8gc2V0IHRoZSBrZXJuZWwgb3V0cHV0IHNpemUgdG9cblx0ICovXG5cdHNldE91dHB1dChvdXRwdXQpIHtcblx0XHRpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd4JykpIHtcblx0XHRcdGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3knKSkge1xuXHRcdFx0XHRpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd6JykpIHtcblx0XHRcdFx0XHR0aGlzLm91dHB1dCA9IFtvdXRwdXQueCwgb3V0cHV0LnksIG91dHB1dC56XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm91dHB1dCA9IFtvdXRwdXQueCwgb3V0cHV0LnldO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm91dHB1dCA9IFtvdXRwdXQueF07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBUb2dnbGUgZGVidWcgbW9kZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZsYWcgLSB0cnVlIHRvIGVuYWJsZSBkZWJ1Z1xuXHQgKi9cblx0c2V0RGVidWcoZmxhZykge1xuXHRcdHRoaXMuZGVidWcgPSBmbGFnO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFRvZ2dsZSBncmFwaGljYWwgb3V0cHV0IG1vZGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBmbGFnIC0gdHJ1ZSB0byBlbmFibGUgZ3JhcGhpY2FsIG91dHB1dFxuXHQgKi9cblx0c2V0R3JhcGhpY2FsKGZsYWcpIHtcblx0XHR0aGlzLmdyYXBoaWNhbCA9IGZsYWc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBsb29wIGl0ZXJhdGlvbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIGl0ZXJhdGlvbnMgY291bnRcblx0ICovXG5cdHNldExvb3BNYXhJdGVyYXRpb25zKG1heCkge1xuXHRcdHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgPSBtYXg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgU2V0IENvbnN0YW50c1xuXHQgKi9cblx0c2V0Q29uc3RhbnRzKGNvbnN0YW50cykge1xuXHRcdHRoaXMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7SUZ1bmN0aW9uW118S2VybmVsRnVuY3Rpb25bXX0gZnVuY3Rpb25zXG5cdCAqIEByZXR1cm5zIHtLZXJuZWx9XG5cdCAqL1xuXHRzZXRGdW5jdGlvbnMoZnVuY3Rpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBmdW5jdGlvbnNbMF0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuZnVuY3Rpb25zID0gZnVuY3Rpb25zLm1hcChzb3VyY2UgPT4gdXRpbHMuZnVuY3Rpb25Ub0lGdW5jdGlvbihzb3VyY2UpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB3cml0aW5nIHRvIHRleHR1cmUgb24vb2ZmXG5cdCAqIEBwYXJhbSBmbGFnXG5cdCAqIEByZXR1cm5zIHtLZXJuZWx9XG5cdCAqL1xuXHRzZXRQaXBlbGluZShmbGFnKSB7XG5cdFx0dGhpcy5waXBlbGluZSA9IGZsYWc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHByZWNpc2lvbiB0byAndW5zaWduZWQnIG9yICdzaW5nbGUnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnICd1bnNpZ25lZCcgb3IgJ3NpbmdsZSdcblx0ICogQHJldHVybnMge0tlcm5lbH1cblx0ICovXG5cdHNldFByZWNpc2lvbihmbGFnKSB7XG5cdFx0dGhpcy5wcmVjaXNpb24gPSBmbGFnO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0c2V0T3V0cHV0VG9UZXh0dXJlKGZsYWcpIHtcblx0XHR1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldE91dHB1dFRvVGV4dHVyZScsICdzZXRQaXBlbGluZScpO1xuXHRcdHRoaXMucGlwZWxpbmUgPSBmbGFnO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0byBpbW11dGFibGVcblx0ICogQHBhcmFtIGZsYWdcblx0ICogQHJldHVybnMge0tlcm5lbH1cblx0ICovXG5cdHNldEltbXV0YWJsZShmbGFnKSB7XG5cdFx0dGhpcy5pbW11dGFibGUgPSBmbGFnO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEJpbmQgdGhlIGNhbnZhcyB0byBrZXJuZWxcblx0ICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc1xuXHQgKi9cblx0c2V0Q2FudmFzKGNhbnZhcykge1xuXHRcdHRoaXMuY2FudmFzID0gY2FudmFzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRnZXRDYW52YXMoKSB7XG5cdFx0dXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdnZXRDYW52YXMnKTtcblx0XHRyZXR1cm4gdGhpcy5jYW52YXM7XG5cdH1cblxuXHQvKipcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGdldFdlYkdsKCkge1xuXHRcdHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnZ2V0V2ViR2wnKTtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEJpbmQgdGhlIHdlYkdMIGluc3RhbmNlIHRvIGtlcm5lbFxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gY29udGV4dCAtIHdlYkdsIGluc3RhbmNlIHRvIGJpbmRcblx0ICovXG5cdHNldENvbnRleHQoY29udGV4dCkge1xuXHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRzZXRBcmd1bWVudFR5cGVzKGFyZ3VtZW50VHlwZXMpIHtcblx0XHR0aGlzLmFyZ3VtZW50VHlwZXMgPSBhcmd1bWVudFR5cGVzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmVxdWVzdEZhbGxiYWNrKGFyZ3MpIHtcblx0XHRpZiAoIXRoaXMub25SZXF1ZXN0RmFsbGJhY2spIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgXCJvblJlcXVlc3RGYWxsYmFja1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLm9uUmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFZhbGlkYXRlIHNldHRpbmdzXG5cdCAqIEBhYnN0cmFjdFxuXHQgKi9cblx0dmFsaWRhdGVTZXR0aW5ncygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwidmFsaWRhdGVTZXR0aW5nc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG5cdH1cblxuXHQvKipcblx0ICogUnVuIGtlcm5lbCBpbiBhc3luYyBtb2RlXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPEtlcm5lbE91dHB1dD59XG5cdCAqL1xuXHRleGVjKCkge1xuXHRcdGNvbnN0IGFyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFthcmd1bWVudHNbMF1dIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YWNjZXB0KHRoaXMucnVuLmFwcGx5KHRoaXMsIGFyZ3MpKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEFkZCBhIHN1YiBrZXJuZWwgdG8gdGhlIHJvb3Qga2VybmVsIGluc3RhbmNlLlxuXHQgKiBUaGlzIGlzIHdoYXQgYGNyZWF0ZUtlcm5lbE1hcGAgdXNlcy5cblx0ICpcblx0ICogQHBhcmFtIHtJU3ViS2VybmVsfSBzdWJLZXJuZWwgLSBmdW5jdGlvbiAoYXMgYSBTdHJpbmcpIG9mIHRoZSBzdWJLZXJuZWwgdG8gYWRkXG5cdCAqL1xuXHRhZGRTdWJLZXJuZWwoc3ViS2VybmVsKSB7XG5cdFx0aWYgKHRoaXMuc3ViS2VybmVscyA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zdWJLZXJuZWxzID0gW107XG5cdFx0fVxuXHRcdGlmICghc3ViS2VybmVsLnNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInNvdXJjZVwiIHByb3BlcnR5Jyk7XG5cdFx0aWYgKCFzdWJLZXJuZWwucHJvcGVydHkgJiYgaXNOYU4oc3ViS2VybmVsLnByb3BlcnR5KSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInByb3BlcnR5XCIgcHJvcGVydHknKTtcblx0XHRpZiAoIXN1Yktlcm5lbC5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ3N1Yktlcm5lbCBtaXNzaW5nIFwibmFtZVwiIHByb3BlcnR5Jyk7XG5cdFx0dGhpcy5zdWJLZXJuZWxzLnB1c2goc3ViS2VybmVsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBEZXN0cm95cyBhbGwgbWVtb3J5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtlcm5lbFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZUNhbnZhc1JlZmVyZW5jZXMgcmVtb3ZlIGFueSBhc3NvY2lhdGVkIGNhbnZhcyByZWZlcmVuY2VzP1xuXHQgKi9cblx0ZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBcImRlc3Ryb3lcIiBjYWxsZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBiaXQgc3RvcmFnZSByYXRpbyBvZiBzb3VyY2UgdG8gdGFyZ2V0ICdidWZmZXInLCBpLmUuIGlmIDhiaXQgYXJyYXkgLT4gMzJiaXQgdGV4ID0gNFxuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldEJpdFJhdGlvKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuXHRcdFx0Ly8gOCBhbmQgMTYgYXJlIHVwY29udmVydGVkIHRvIGZsb2F0MzJcblx0XHRcdHJldHVybiA0O1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlWzBdKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBJbnB1dCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUudmFsdWUpO1xuXHRcdH1cblx0XHRzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRjYXNlIFVpbnQ4QXJyYXk6XG5cdFx0XHRjYXNlIEludDhBcnJheTpcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXHRcdFx0Y2FzZSBJbnQxNkFycmF5OlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdGNhc2UgRmxvYXQzMkFycmF5OlxuXHRcdFx0Y2FzZSBJbnQzMkFycmF5OlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIDQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGdldFBpeGVscygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0UGl4ZWxzXCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG5cdH1cblxuXHRjaGVja091dHB1dCgpIHtcblx0XHRpZiAoIXRoaXMub3V0cHV0IHx8ICFBcnJheS5pc0FycmF5KHRoaXMub3V0cHV0KSkgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwub3V0cHV0IG5vdCBhbiBhcnJheScpO1xuXHRcdGlmICh0aGlzLm91dHB1dC5sZW5ndGggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbC5vdXRwdXQgaXMgZW1wdHksIG5lZWRzIGF0IGxlYXN0IDEgdmFsdWUnKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaXNOYU4odGhpcy5vdXRwdXRbaV0pIHx8IHRoaXMub3V0cHV0W2ldIDwgMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9Lm91dHB1dFskeyBpIH1dIGluY29ycmVjdGx5IGRlZmluZWQgYXMgXFxgJHsgdGhpcy5vdXRwdXRbaV0gfVxcYCwgbmVlZHMgdG8gYmUgbnVtZXJpYywgYW5kIGdyZWF0ZXIgdGhhbiAwYCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IHNldHRpbmdzID0ge1xuXHRcdFx0b3V0cHV0OiB0aGlzLm91dHB1dCxcblx0XHRcdHRocmVhZERpbTogdGhpcy50aHJlYWREaW0sXG5cdFx0XHRwaXBlbGluZTogdGhpcy5waXBlbGluZSxcblx0XHRcdGFyZ3VtZW50TmFtZXM6IHRoaXMuYXJndW1lbnROYW1lcyxcblx0XHRcdGFyZ3VtZW50c1R5cGVzOiB0aGlzLmFyZ3VtZW50VHlwZXMsXG5cdFx0XHRhcmd1bWVudHNMZW5ndGg6IHRoaXMuYXJndW1lbnRzTGVuZ3RoLFxuXHRcdFx0Y29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcblx0XHRcdGNvbnN0YW50c0xlbmd0aDogdGhpcy5jb25zdGFudHNMZW5ndGgsXG5cdFx0XHRwbHVnaW5OYW1lczogdGhpcy5wbHVnaW5zID8gdGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLm5hbWUpIDogbnVsbCxcblx0XHRcdHJldHVyblR5cGU6IHRoaXMucmV0dXJuVHlwZSxcblx0XHR9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXR0aW5nc1xuXHRcdH07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdEtlcm5lbFxufTsiLCJjb25zdCBmcmFnbWVudFNoYWRlciA9IGBfX0hFQURFUl9fO1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xucHJlY2lzaW9uIGhpZ2hwIGludDtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG5cbmNvbnN0IGludCBMT09QX01BWCA9IF9fTE9PUF9NQVhfXztcblxuX19QTFVHSU5TX187XG5fX0NPTlNUQU5UU19fO1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG52ZWM0IHJvdW5kKHZlYzQgeCkge1xuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XG59XG5cbmZsb2F0IHJvdW5kKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGZsb29yKHggKyAwLjUpO1xufVxuXG52ZWMyIGludGVnZXJNb2QodmVjMiB4LCBmbG9hdCB5KSB7XG4gIHZlYzIgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XG4gIHZlYzMgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWM0IGludGVnZXJNb2QodmVjNCB4LCB2ZWM0IHkpIHtcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbmZsb2F0IGludGVnZXJNb2QoZmxvYXQgeCwgZmxvYXQgeSkge1xuICBmbG9hdCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcbn1cblxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0gKHkgKiBpbnQoeCAvIHkpKTtcbn1cblxuX19ESVZJREVfV0lUSF9JTlRFR0VSX0NIRUNLX187XG5cbi8vIEhlcmUgYmUgZHJhZ29ucyFcbi8vIERPIE5PVCBPUFRJTUlaRSBUSElTIENPREVcbi8vIFlPVSBXSUxMIEJSRUFLIFNPTUVUSElORyBPTiBTT01FQk9EWVxcJ1MgTUFDSElORVxuLy8gTEVBVkUgSVQgQVMgSVQgSVMsIExFU1QgWU9VIFdBU1RFIFlPVVIgT1dOIFRJTUVcbmNvbnN0IHZlYzIgTUFHSUNfVkVDID0gdmVjMigxLjAsIC0yNTYuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUiA9IHZlYzQoMS4wLCAyNTYuMCwgNjU1MzYuMCwgMC4wKTtcbmNvbnN0IHZlYzQgU0NBTEVfRkFDVE9SX0lOViA9IHZlYzQoMS4wLCAwLjAwMzkwNjI1LCAwLjAwMDAxNTI1ODc4OTA2MjUsIDAuMCk7IC8vIDEsIDEvMjU2LCAxLzY1NTM2XG5mbG9hdCBkZWNvZGUzMih2ZWM0IHRleGVsKSB7XG4gIF9fREVDT0RFMzJfRU5ESUFOTkVTU19fO1xuICB0ZXhlbCAqPSAyNTUuMDtcbiAgdmVjMiBndGUxMjg7XG4gIGd0ZTEyOC54ID0gdGV4ZWwuYiA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZ3RlMTI4LnkgPSB0ZXhlbC5hID49IDEyOC4wID8gMS4wIDogMC4wO1xuICBmbG9hdCBleHBvbmVudCA9IDIuMCAqIHRleGVsLmEgLSAxMjcuMCArIGRvdChndGUxMjgsIE1BR0lDX1ZFQyk7XG4gIGZsb2F0IHJlcyA9IGV4cDIocm91bmQoZXhwb25lbnQpKTtcbiAgdGV4ZWwuYiA9IHRleGVsLmIgLSAxMjguMCAqIGd0ZTEyOC54O1xuICByZXMgPSBkb3QodGV4ZWwsIFNDQUxFX0ZBQ1RPUikgKiBleHAyKHJvdW5kKGV4cG9uZW50LTIzLjApKSArIHJlcztcbiAgcmVzICo9IGd0ZTEyOC55ICogLTIuMCArIDEuMDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZmxvYXQgZGVjb2RlMTYodmVjNCB0ZXhlbCwgaW50IGluZGV4KSB7XG5cdGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG5cdGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yICogMjU1LjAgKyB0ZXhlbC5nICogNjUyODAuMDtcblx0aWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHRleGVsLmIgKiAyNTUuMCArIHRleGVsLmEgKiA2NTI4MC4wO1xuXHRyZXR1cm4gMC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gdGV4ZWwuciAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdGV4ZWwuZyAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYiAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAzKSByZXR1cm4gdGV4ZWwuYSAqIDI1NS4wO1xuICByZXR1cm4gMC4wO1xufVxuXG52ZWM0IGVuY29kZTMyKGZsb2F0IGYpIHtcbiAgZmxvYXQgRiA9IGFicyhmKTtcbiAgZmxvYXQgc2lnbiA9IGYgPCAwLjAgPyAxLjAgOiAwLjA7XG4gIGZsb2F0IGV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XG4gIGZsb2F0IG1hbnRpc3NhID0gKGV4cDIoLWV4cG9uZW50KSAqIEYpO1xuICAvLyBleHBvbmVudCArPSBmbG9vcihsb2cyKG1hbnRpc3NhKSk7XG4gIHZlYzQgdGV4ZWwgPSB2ZWM0KEYgKiBleHAyKDIzLjAtZXhwb25lbnQpKSAqIFNDQUxFX0ZBQ1RPUl9JTlY7XG4gIHRleGVsLnJnID0gaW50ZWdlck1vZCh0ZXhlbC5yZywgMjU2LjApO1xuICB0ZXhlbC5iID0gaW50ZWdlck1vZCh0ZXhlbC5iLCAxMjguMCk7XG4gIHRleGVsLmEgPSBleHBvbmVudCowLjUgKyA2My41O1xuICB0ZXhlbC5iYSArPSB2ZWMyKGludGVnZXJNb2QoZXhwb25lbnQrMTI3LjAsIDIuMCksIHNpZ24pICogMTI4LjA7XG4gIHRleGVsID0gZmxvb3IodGV4ZWwpO1xuICB0ZXhlbCAqPSAwLjAwMzkyMTU2OTsgLy8gMS8yNTVcbiAgX19FTkNPREUzMl9FTkRJQU5ORVNTX187XG4gIHJldHVybiB0ZXhlbDtcbn1cbi8vIERyYWdvbnMgZW5kIGhlcmVcblxuaW50IGluZGV4O1xuaXZlYzMgdGhyZWFkSWQ7XG5cbml2ZWMzIGluZGV4VG8zRChpbnQgaWR4LCBpdmVjMyB0ZXhEaW0pIHtcbiAgaW50IHogPSBpbnQoaWR4IC8gKHRleERpbS54ICogdGV4RGltLnkpKTtcbiAgaWR4IC09IHogKiBpbnQodGV4RGltLnggKiB0ZXhEaW0ueSk7XG4gIGludCB5ID0gaW50KGlkeCAvIHRleERpbS54KTtcbiAgaW50IHggPSBpbnQoaW50ZWdlck1vZChpZHgsIHRleERpbS54KSk7XG4gIHJldHVybiBpdmVjMyh4LCB5LCB6KTtcbn1cblxuZmxvYXQgZ2V0MzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xuICBpbnQgaW5kZXggPSB4eXoueCArIHRleERpbS54ICogKHh5ei55ICsgdGV4RGltLnkgKiB4eXoueik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgcmV0dXJuIGRlY29kZTMyKHRleGVsKTtcbn1cblxuZmxvYXQgZ2V0MTYoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xuICBpbnQgaW5kZXggPSB4eXoueCArIHRleERpbS54ICogKHh5ei55ICsgdGV4RGltLnkgKiB4eXoueik7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogMjtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiAyLCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTE2KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldDgoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xuICBpbnQgaW5kZXggPSB4eXoueCArIHRleERpbS54ICogKHh5ei55ICsgdGV4RGltLnkgKiB4eXoueik7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogNDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiA0LCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTgodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0TWVtb3J5T3B0aW1pemVkMzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xuICBpbnQgaW5kZXggPSB4eXoueCArIHRleERpbS54ICogKHh5ei55ICsgdGV4RGltLnkgKiB4eXoueik7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgNCk7XG4gIGluZGV4ID0gaW5kZXggLyA0O1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdGV4ZWwuZztcbiAgaWYgKGNoYW5uZWwgPT0gMikgcmV0dXJuIHRleGVsLmI7XG4gIGlmIChjaGFubmVsID09IDMpIHJldHVybiB0ZXhlbC5hO1xuICByZXR1cm4gMC4wO1xufVxuXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xuICBpbnQgaW5kZXggPSB4eXoueCArIHRleERpbS54ICogKHh5ei55ICsgdGV4RGltLnkgKiB4eXoueik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbn1cblxuZmxvYXQgZ2V0RmxvYXRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gcmVzdWx0WzBdO1xufVxuXG52ZWMyIGdldFZlYzJGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMihyZXN1bHRbMF0sIHJlc3VsdFsxXSk7XG59XG5cbnZlYzMgZ2V0VmVjM0Zyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHZlYzQgcmVzdWx0ID0gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG4gIHJldHVybiB2ZWMzKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xufVxuXG52ZWM0IGdldFZlYzRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG59XG5cbnZlYzQgYWN0dWFsQ29sb3I7XG52b2lkIGNvbG9yKGZsb2F0IHIsIGZsb2F0IGcsIGZsb2F0IGIsIGZsb2F0IGEpIHtcbiAgYWN0dWFsQ29sb3IgPSB2ZWM0KHIsZyxiLGEpO1xufVxuXG52b2lkIGNvbG9yKGZsb2F0IHIsIGZsb2F0IGcsIGZsb2F0IGIpIHtcbiAgY29sb3IocixnLGIsMS4wKTtcbn1cblxudm9pZCBjb2xvcihzYW1wbGVyMkQgaW1hZ2UpIHtcbiAgYWN0dWFsQ29sb3IgPSB0ZXh0dXJlMkQoaW1hZ2UsIHZUZXhDb29yZCk7XG59XG5cbl9fTUFJTl9DT05TVEFOVFNfXztcbl9fTUFJTl9BUkdVTUVOVFNfXztcbl9fS0VSTkVMX187XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGluZGV4ID0gaW50KHZUZXhDb29yZC5zICogZmxvYXQodVRleFNpemUueCkpICsgaW50KHZUZXhDb29yZC50ICogZmxvYXQodVRleFNpemUueSkpICogdVRleFNpemUueDtcbiAgX19NQUlOX1JFU1VMVF9fO1xufWA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRmcmFnbWVudFNoYWRlclxufTsiLCJjb25zdCB7XG5cdEZ1bmN0aW9uTm9kZVxufSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLW5vZGUnKTtcbi8vIENsb3N1cmUgY2FwdHVyZSBmb3IgdGhlIGFzdCBmdW5jdGlvbiwgcHJldmVudCBjb2xsaXNpb24gd2l0aCBleGlzdGluZyBBU1QgZnVuY3Rpb25zXG4vLyBUaGUgcHJlZml4ZXMgdG8gdXNlXG5jb25zdCBqc01hdGhQcmVmaXggPSAnTWF0aC4nO1xuY29uc3QgbG9jYWxQcmVmaXggPSAndGhpcy4nO1xuXG4vKipcbiAqIEBkZXNjIFtJTlRFUk5BTF0gVGFrZXMgaW4gYSBmdW5jdGlvbiBub2RlLCBhbmQgZG9lcyBhbGwgdGhlIEFTVCB2b29kb28gcmVxdWlyZWQgdG8gdG9TdHJpbmcgaXRzIHJlc3BlY3RpdmUgV2ViR0wgY29kZVxuICogQGV4dGVuZHMgRnVuY3Rpb25Ob2RlXG4gKiBAcmV0dXJucyB0aGUgY29udmVydGVkIFdlYkdMIGZ1bmN0aW9uIHN0cmluZ1xuICovXG5jbGFzcyBXZWJHTEZ1bmN0aW9uTm9kZSBleHRlbmRzIEZ1bmN0aW9uTm9kZSB7XG5cdGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcblx0XHRzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcblx0XHR0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gbnVsbDtcblx0XHRpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2ZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5JykpIHtcblx0XHRcdHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBzZXR0aW5ncy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgdG8gaXRzICpuYW1lZCBmdW5jdGlvbipcblx0ICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0RnVuY3Rpb25FeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0Ly8gU2V0dXAgZnVuY3Rpb24gcmV0dXJuIHR5cGUgYW5kIG5hbWVcblx0XHRpZiAodGhpcy5pc1Jvb3RLZXJuZWwpIHtcblx0XHRcdHJldEFyci5wdXNoKCd2b2lkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGxvb2tpbmcgdXAgcmV0dXJuIHR5cGUsIHRoaXMgaXMgYSBsaXR0bGUgZXhwZW5zaXZlLCBhbmQgY2FuIGJlIGF2b2lkZWQgaWYgcmV0dXJuVHlwZSBpcyBzZXRcblx0XHRcdGlmICghdGhpcy5yZXR1cm5UeXBlKSB7XG5cdFx0XHRcdGNvbnN0IGxhc3RSZXR1cm4gPSB0aGlzLmZpbmRMYXN0UmV0dXJuKCk7XG5cdFx0XHRcdGlmIChsYXN0UmV0dXJuKSB7XG5cdFx0XHRcdFx0dGhpcy5yZXR1cm5UeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5ib2R5KTtcblx0XHRcdFx0XHRpZiAodGhpcy5yZXR1cm5UeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJldHVyblR5cGUgPSAnTnVtYmVyJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRyZXR1cm5UeXBlXG5cdFx0XHR9ID0gdGhpcztcblx0XHRcdGlmICghcmV0dXJuVHlwZSkge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgndm9pZCcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHR5cGVNYXBbcmV0dXJuVHlwZV07XG5cdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlICR7cmV0dXJuVHlwZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXRBcnIucHVzaCh0eXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0QXJyLnB1c2goJyAnKTtcblx0XHRyZXRBcnIucHVzaCh0aGlzLm5hbWUpO1xuXHRcdHJldEFyci5wdXNoKCcoJyk7XG5cblx0XHRpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG5cdFx0XHQvLyBBcmd1bWVudHMgaGFuZGxpbmdcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IGFyZ3VtZW50TmFtZSA9IHRoaXMuYXJndW1lbnROYW1lc1tpXTtcblxuXHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnLCAnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgYXJndW1lbnRUeXBlID0gdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXJndW1lbnROYW1lKTtcblx0XHRcdFx0aWYgKCFhcmd1bWVudFR5cGUgfHwgYXJndW1lbnRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG5cdFx0XHRcdFx0YXJndW1lbnRUeXBlID0gJ051bWJlcic7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgdHlwZSA9IHR5cGVNYXBbYXJndW1lbnRUeXBlXTtcblx0XHRcdFx0aWYgKCF0eXBlKSB7XG5cdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXRBcnIucHVzaCh0eXBlKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJyAnKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJ3VzZXJfJyk7XG5cdFx0XHRcdHJldEFyci5wdXNoKGFyZ3VtZW50TmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRnVuY3Rpb24gb3BlbmluZ1xuXHRcdHJldEFyci5wdXNoKCcpIHtcXG4nKTtcblxuXHRcdC8vIEJvZHkgc3RhdGVtZW50IGl0ZXJhdGlvblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmJvZHkuYm9keS5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5ib2R5LmJvZHlbaV0sIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnXFxuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gRnVuY3Rpb24gY2xvc2luZ1xuXHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciB0byAqcmV0dXJuKiBzdGF0ZW1lbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0aWYgKCFhc3QuYXJndW1lbnQpIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgcmV0dXJuIHN0YXRlbWVudCcsIGFzdCk7XG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cblx0XHRpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNSb290S2VybmVsKSB7XG5cdFx0XHRcdHRoaXMucmV0dXJuVHlwZSA9ICdOdW1iZXInO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZXR1cm5UeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXInOlxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnZmxvYXQoJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyknKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcblx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXG5cdFx0XHRcdFx0XHQvLyBSdW5uaW5nIGFzdEdlbmVyaWMgZm9yY2VzIHRoZSBMaXRlcmFsSW50ZWdlciB0byBwaWNrIGEgdHlwZSwgYW5kIGhlcmUsIGlmIHdlIGFyZSByZXR1cm5pbmcgYSBmbG9hdCwgeWV0XG5cdFx0XHRcdFx0XHQvLyB0aGUgTGl0ZXJhbEludGVnZXIgaGFzIHBpY2tlZCB0byBiZSBhbiBpbnRlZ2VyIGJlY2F1c2Ugb2YgY29uc3RyYWludHMgb24gaXQgd2UgY2FzdCBpdCB0byBmbG9hdC5cblx0XHRcdFx0XHRcdGlmICh0aGlzLmdldFR5cGUoYXN0KSA9PT0gJ0ludGVnZXInKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC51bnNoaWZ0KCdmbG9hdCgnKTtcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyknKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnaW50KCcpO1xuXHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCcpJyk7XG5cdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcblx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG5cdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoMiknOlxuXHRcdFx0Y2FzZSAnSW5wdXQnOlxuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSAke3RoaXMucmV0dXJuVHlwZX1gLCBhc3QpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuXHRcdFx0cmV0QXJyLnB1c2goYGtlcm5lbFJlc3VsdCA9ICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuXHRcdFx0cmV0QXJyLnB1c2goJ3JldHVybjsnKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuaXNTdWJLZXJuZWwpIHtcblx0XHRcdHJldEFyci5wdXNoKGBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH0gPSAkeyByZXN1bHQuam9pbignJykgfTtgKTtcblx0XHRcdHJldEFyci5wdXNoKGByZXR1cm4gc3ViS2VybmVsUmVzdWx0XyR7IHRoaXMubmFtZSB9O2ApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRBcnIucHVzaChgcmV0dXJuICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpsaXRlcmFsIHZhbHVlKlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RMaXRlcmFsKGFzdCwgcmV0QXJyKSB7XG5cdFx0Ly8gUmVqZWN0IG5vbiBudW1lcmljIGxpdGVyYWxzXG5cdFx0aWYgKGlzTmFOKGFzdC52YWx1ZSkpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG5cdFx0XHRcdCdOb24tbnVtZXJpYyBsaXRlcmFsIG5vdCBzdXBwb3J0ZWQgOiAnICsgYXN0LnZhbHVlLFxuXHRcdFx0XHRhc3Rcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuXHRcdFx0aWYgKHRoaXMuaXNTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpIHx8IHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcblx0XHRcdFx0dGhpcy5saXRlcmFsVHlwZXNbYCR7YXN0LnN0YXJ0fSwke2FzdC5lbmR9YF0gPSAnSW50ZWdlcic7XG5cdFx0XHRcdHJldEFyci5wdXNoKGAke2FzdC52YWx1ZX1gKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWZsb2F0JykpIHtcblx0XHRcdFx0dGhpcy5saXRlcmFsVHlwZXNbYCR7YXN0LnN0YXJ0fSwke2FzdC5lbmR9YF0gPSAnTnVtYmVyJztcblx0XHRcdFx0cmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfS4wYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxpdGVyYWxUeXBlc1tgJHthc3Quc3RhcnR9LCR7YXN0LmVuZH1gXSA9ICdOdW1iZXInO1xuXHRcdFx0XHRyZXRBcnIucHVzaChgJHthc3QudmFsdWV9LjBgKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcblx0XHRcdHRoaXMubGl0ZXJhbFR5cGVzW2Ake2FzdC5zdGFydH0sJHthc3QuZW5kfWBdID0gJ0ludGVnZXInO1xuXHRcdFx0cmV0QXJyLnB1c2gocGFyc2VJbnQoYXN0LnJhdykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmxpdGVyYWxUeXBlc1tgJHthc3Quc3RhcnR9LCR7YXN0LmVuZH1gXSA9ICdOdW1iZXInO1xuXHRcdFx0cmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfWApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpiaW5hcnkqIGV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdGlmIChhc3Qub3BlcmF0b3IgPT09ICclJykge1xuXHRcdFx0cmV0QXJyLnB1c2goJ21vZCgnKTtcblxuXHRcdFx0Y29uc3QgbGVmdFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmxlZnQpO1xuXHRcdFx0aWYgKGxlZnRUeXBlID09PSAnSW50ZWdlcicpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goJ2Zsb2F0KCcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHR9IGVsc2UgaWYgKGxlZnRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG5cdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXRBcnIucHVzaCgnLCcpO1xuXHRcdFx0Y29uc3QgcmlnaHRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5yaWdodCk7XG5cblx0XHRcdGlmIChyaWdodFR5cGUgPT09ICdJbnRlZ2VyJykge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnZmxvYXQoJyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHR9IGVsc2UgaWYgKHJpZ2h0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuXHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0cmV0QXJyLnB1c2goJygnKTtcblx0XHRpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBhc3Qub3BlcmF0b3IgPT09ICcvJykge1xuXHRcdFx0cmV0QXJyLnB1c2goJ2Rpdl93aXRoX2ludF9jaGVjaygnKTtcblxuXHRcdFx0c3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LmxlZnQpKSB7XG5cdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXInOlxuXHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHR9XG5cblx0XHRcdHJldEFyci5wdXNoKCcsICcpO1xuXG5cdFx0XHRzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpKSB7XG5cdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcblx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHR9XG5cblx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5sZWZ0KSB8fCAnTnVtYmVyJztcblx0XHRcdGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpIHx8ICdOdW1iZXInO1xuXHRcdFx0aWYgKCFsZWZ0VHlwZSB8fCAhcmlnaHRUeXBlKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbmAsIGFzdCk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBrZXkgPSBsZWZ0VHlwZSArICcgJiAnICsgcmlnaHRUeXBlO1xuXHRcdFx0c3dpdGNoIChrZXkpIHtcblx0XHRcdFx0Y2FzZSAnSW50ZWdlciAmIEludGVnZXInOlxuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnTnVtYmVyICYgRmxvYXQnOlxuXHRcdFx0XHRjYXNlICdGbG9hdCAmIE51bWJlcic6XG5cdFx0XHRcdGNhc2UgJ0Zsb2F0ICYgRmxvYXQnOlxuXHRcdFx0XHRjYXNlICdOdW1iZXIgJiBOdW1iZXInOlxuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXIgJiBMaXRlcmFsSW50ZWdlcic6XG5cdFx0XHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0ludGVnZXIgJiBGbG9hdCc6XG5cdFx0XHRcdGNhc2UgJ0ludGVnZXIgJiBOdW1iZXInOlxuXHRcdFx0XHRcdGlmIChhc3Qub3BlcmF0b3IgPT09ICc+JyB8fCBhc3Qub3BlcmF0b3IgPT09ICc8JyAmJiBhc3QucmlnaHQudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0XHQvLyBpZiByaWdodCB2YWx1ZSBpcyBhY3R1YWxseSBhIGZsb2F0LCBkb24ndCBsb29zZSB0aGF0IGluZm9ybWF0aW9uLCBjYXN0IGxlZnQgdG8gcmlnaHQgcmF0aGVyIHRoYW4gdGhlIHVzdWFsIHJpZ2h0IHRvIGxlZnRcblx0XHRcdFx0XHRcdGlmICghTnVtYmVyLmlzSW50ZWdlcihhc3QucmlnaHQudmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG5cdFx0XHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuXHRcdFx0XHRcdGlmIChhc3QucmlnaHQudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaXRlcmFsUmVzdWx0ID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCBsaXRlcmFsUmVzdWx0KTtcblx0XHRcdFx0XHRcdGNvbnN0IGxpdGVyYWxUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5yaWdodCk7XG5cdFx0XHRcdFx0XHRpZiAobGl0ZXJhbFR5cGUgPT09ICdJbnRlZ2VyJykge1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaChsaXRlcmFsUmVzdWx0LmpvaW4oJycpKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbiB3aXRoIGxpdGVyYWxgLCBhc3QpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnaW50KCcpO1xuXHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdJbnRlZ2VyICYgTGl0ZXJhbEludGVnZXInOlxuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG5cdFx0XHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTnVtYmVyICYgSW50ZWdlcic6XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcblx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdGbG9hdCAmIExpdGVyYWxJbnRlZ2VyJzpcblx0XHRcdFx0Y2FzZSAnTnVtYmVyICYgTGl0ZXJhbEludGVnZXInOlxuXHRcdFx0XHRcdGlmICh0aGlzLmlzU3RhdGUoJ2luLWZvci1sb29wLXRlc3QnKSkge1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2ludCgnKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG5cdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcblx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXIgJiBGbG9hdCc6XG5cdFx0XHRcdGNhc2UgJ0xpdGVyYWxJbnRlZ2VyICYgTnVtYmVyJzpcblx0XHRcdFx0XHRpZiAodGhpcy5pc1N0YXRlKCdpbi1mb3ItbG9vcC10ZXN0JykgfHwgdGhpcy5pc1N0YXRlKCdpbi1mb3ItbG9vcC1pbml0JykgfHwgdGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuXHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2ludCgnKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcblx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXIgJiBJbnRlZ2VyJzpcblx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0Jvb2xlYW4gJiBCb29sZWFuJzpcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYmluYXJ5IGV4cHJlc3Npb24gYmV0d2VlbiAke2tleX1gLCBhc3QpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqaWRlbnRpZmllciogZXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gaWR0Tm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0SWRlbnRpZmllckV4cHJlc3Npb24oaWR0Tm9kZSwgcmV0QXJyKSB7XG5cdFx0aWYgKGlkdE5vZGUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJZGVudGlmaWVyRXhwcmVzc2lvbiAtIG5vdCBhbiBJZGVudGlmaWVyJywgaWR0Tm9kZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShpZHROb2RlKTtcblxuXHRcdGlmIChpZHROb2RlLm5hbWUgPT09ICdJbmZpbml0eScpIHtcblx0XHRcdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NzU0MzEyNy8xMzI0MDM5XG5cdFx0XHRyZXRBcnIucHVzaCgnMy40MDI4MjM0NjZlKzM4Jyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnQm9vbGVhbicpIHtcblx0XHRcdGlmICh0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihpZHROb2RlLm5hbWUpID4gLTEpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goYGJvb2wodXNlcl8ke2lkdE5vZGUubmFtZX0pYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8ke2lkdE5vZGUubmFtZX1gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgdXNlckFyZ3VtZW50TmFtZSA9IHRoaXMuZ2V0S2VybmVsQXJndW1lbnROYW1lKGlkdE5vZGUubmFtZSk7XG5cdFx0XHRpZiAodXNlckFyZ3VtZW50TmFtZSkge1xuXHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8ke3VzZXJBcmd1bWVudE5hbWV9YCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8ke2lkdE5vZGUubmFtZX1gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpmb3ItbG9vcCogZXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gZm9yTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgcGFyc2VkIHdlYmdsIHN0cmluZ1xuXHQgKi9cblx0YXN0Rm9yU3RhdGVtZW50KGZvck5vZGUsIHJldEFycikge1xuXHRcdGlmIChmb3JOb2RlLnR5cGUgIT09ICdGb3JTdGF0ZW1lbnQnKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIGZvciBzdGF0ZW1lbnQnLCBmb3JOb2RlKTtcblx0XHR9XG5cblx0XHRjb25zdCBpbml0QXJyID0gW107XG5cdFx0Y29uc3QgdGVzdEFyciA9IFtdO1xuXHRcdGNvbnN0IHVwZGF0ZUFyciA9IFtdO1xuXHRcdGNvbnN0IGJvZHlBcnIgPSBbXTtcblx0XHRsZXQgaXNTYWZlID0gbnVsbDtcblxuXHRcdGlmIChmb3JOb2RlLmluaXQpIHtcblx0XHRcdHRoaXMucHVzaFN0YXRlKCdpbi1mb3ItbG9vcC1pbml0Jyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5pbml0LCBpbml0QXJyKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdEFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaW5pdEFycltpXS5pbmNsdWRlcyAmJiBpbml0QXJyW2ldLmluY2x1ZGVzKCcsJykpIHtcblx0XHRcdFx0XHRpc1NhZmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb3BTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpc1NhZmUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZm9yTm9kZS50ZXN0KSB7XG5cdFx0XHR0aGlzLnB1c2hTdGF0ZSgnaW4tZm9yLWxvb3AtdGVzdCcpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdCwgdGVzdEFycik7XG5cdFx0XHR0aGlzLnBvcFN0YXRlKCdpbi1mb3ItbG9vcC10ZXN0Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlzU2FmZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChmb3JOb2RlLnVwZGF0ZSkge1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUudXBkYXRlLCB1cGRhdGVBcnIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpc1NhZmUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZm9yTm9kZS5ib2R5KSB7XG5cdFx0XHR0aGlzLnB1c2hTdGF0ZSgnbG9vcC1ib2R5Jyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LCBib2R5QXJyKTtcblx0XHRcdHRoaXMucG9wU3RhdGUoJ2xvb3AtYm9keScpO1xuXHRcdH1cblxuXHRcdC8vIGhhdmUgYWxsIHBhcnRzLCBub3cgbWFrZSB0aGVtIHNhZmVcblx0XHRpZiAoaXNTYWZlID09PSBudWxsKSB7XG5cdFx0XHRpc1NhZmUgPSB0aGlzLmlzU2FmZShmb3JOb2RlLmluaXQpICYmIHRoaXMuaXNTYWZlKGZvck5vZGUudGVzdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzU2FmZSkge1xuXHRcdFx0cmV0QXJyLnB1c2goYGZvciAoJHtpbml0QXJyLmpvaW4oJycpfTske3Rlc3RBcnIuam9pbignJyl9OyR7dXBkYXRlQXJyLmpvaW4oJycpfSl7XFxuYCk7XG5cdFx0XHRyZXRBcnIucHVzaChib2R5QXJyLmpvaW4oJycpKTtcblx0XHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuXHRcdFx0aWYgKGluaXRBcnIubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRyZXRBcnIucHVzaChpbml0QXJyLmpvaW4oJycpLCAnO1xcbicpO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG5cdFx0XHRpZiAodGVzdEFyci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKGBpZiAoISR7dGVzdEFyci5qb2luKCcnKX0pIGJyZWFrO1xcbmApO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG5cdFx0XHRyZXRBcnIucHVzaChgXFxuJHt1cGRhdGVBcnIuam9pbignJyl9O2ApO1xuXHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqd2hpbGUqIGxvb3Bcblx0ICogQHBhcmFtIHtPYmplY3R9IHdoaWxlTm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgcGFyc2VkIHdlYmdsIHN0cmluZ1xuXHQgKi9cblx0YXN0V2hpbGVTdGF0ZW1lbnQod2hpbGVOb2RlLCByZXRBcnIpIHtcblx0XHRpZiAod2hpbGVOb2RlLnR5cGUgIT09ICdXaGlsZVN0YXRlbWVudCcpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50Jywgd2hpbGVOb2RlKTtcblx0XHR9XG5cblx0XHRjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcblx0XHRyZXRBcnIucHVzaChgZm9yIChpbnQgJHtpVmFyaWFibGVOYW1lfT0wOyR7aVZhcmlhYmxlTmFtZX08TE9PUF9NQVg7JHtpVmFyaWFibGVOYW1lfSsrKXtcXG5gKTtcblx0XHRyZXRBcnIucHVzaCgnaWYgKCEnKTtcblx0XHR0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG5cdFx0cmV0QXJyLnB1c2goJykgYnJlYWs7XFxuJyk7XG5cdFx0dGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuXHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpkbyB3aGlsZSogbG9vcFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZG9XaGlsZU5vZGUgLSBBbiBhc3QgTm9kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHBhcnNlZCB3ZWJnbCBzdHJpbmdcblx0ICovXG5cdGFzdERvV2hpbGVTdGF0ZW1lbnQoZG9XaGlsZU5vZGUsIHJldEFycikge1xuXHRcdGlmIChkb1doaWxlTm9kZS50eXBlICE9PSAnRG9XaGlsZVN0YXRlbWVudCcpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JywgZG9XaGlsZU5vZGUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuXHRcdHJldEFyci5wdXNoKGBmb3IgKGludCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuXHRcdHJldEFyci5wdXNoKCdpZiAoIScpO1xuXHRcdHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuXHRcdHJldEFyci5wdXNoKCcpIGJyZWFrO1xcbicpO1xuXHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKkFzc2lnbm1lbnQqIEV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGFzc05vZGUgLSBBbiBhc3QgTm9kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcblx0ICovXG5cdGFzdEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzc05vZGUsIHJldEFycikge1xuXHRcdGlmIChhc3NOb2RlLm9wZXJhdG9yID09PSAnJT0nKSB7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJz0nKTtcblx0XHRcdHJldEFyci5wdXNoKCdtb2QoJyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJywnKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgbGVmdFR5cGUgPSB0aGlzLmdldFR5cGUoYXNzTm9kZS5sZWZ0KTtcblx0XHRcdGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3NOb2RlLnJpZ2h0KTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaChhc3NOb2RlLm9wZXJhdG9yKTtcblx0XHRcdGlmIChsZWZ0VHlwZSAhPT0gJ0ludGVnZXInICYmIHJpZ2h0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpCbG9jayogc3RhdGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBiTm9kZSAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0QmxvY2tTdGF0ZW1lbnQoYk5vZGUsIHJldEFycikge1xuXHRcdGlmICh0aGlzLmlzU3RhdGUoJ2xvb3AtYm9keScpKSB7XG5cdFx0XHR0aGlzLnB1c2hTdGF0ZSgnYmxvY2stYm9keScpOyAvLyB0aGlzIHByZXZlbnRzIHJlY3Vyc2l2ZSByZW1vdmFsIG9mIGJyYWNlc1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb3BTdGF0ZSgnYmxvY2stYm9keScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRBcnIucHVzaCgne1xcbicpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqVmFyaWFibGUgRGVjbGFyYXRpb24qXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YXJEZWNOb2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RWYXJpYWJsZURlY2xhcmF0aW9uKHZhckRlY05vZGUsIHJldEFycikge1xuXHRcdGlmICh2YXJEZWNOb2RlLmtpbmQgPT09ICd2YXInKSB7XG5cdFx0XHR0aGlzLnZhcldhcm4oKTtcblx0XHR9XG5cdFx0Y29uc3QgZGVjbGFyYXRpb25zID0gdmFyRGVjTm9kZS5kZWNsYXJhdGlvbnM7XG5cdFx0aWYgKCFkZWNsYXJhdGlvbnMgfHwgIWRlY2xhcmF0aW9uc1swXSB8fCAhZGVjbGFyYXRpb25zWzBdLmluaXQpIHtcblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIHZhckRlY05vZGUpO1xuXHRcdH1cblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRjb25zdCBmaXJzdERlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zWzBdO1xuXHRcdGNvbnN0IGluaXQgPSBmaXJzdERlY2xhcmF0aW9uLmluaXQ7XG5cdFx0Y29uc3QgYWN0dWFsVHlwZSA9IHRoaXMuZ2V0VHlwZShpbml0KTtcblx0XHRjb25zdCBpbkZvckxvb3BJbml0ID0gdGhpcy5pc1N0YXRlKCdpbi1mb3ItbG9vcC1pbml0Jyk7XG5cdFx0bGV0IHR5cGUgPSBpbkZvckxvb3BJbml0ID8gJ0ludGVnZXInIDogYWN0dWFsVHlwZTtcblx0XHRpZiAodHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuXHRcdFx0Ly8gV2UgaGFkIHRoZSBjaG9pY2UgdG8gZ28gZWl0aGVyIGZsb2F0IG9yIGludCwgY2hvb3NpbmcgZmxvYXRcblx0XHRcdHR5cGUgPSAnTnVtYmVyJztcblx0XHR9XG5cdFx0Y29uc3QgbWFya3VwVHlwZSA9IHR5cGVNYXBbdHlwZV07XG5cdFx0aWYgKCFtYXJrdXBUeXBlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBNYXJrdXAgdHlwZSAkeyBtYXJrdXBUeXBlIH0gbm90IGhhbmRsZWRgLCB2YXJEZWNOb2RlKTtcblx0XHR9XG5cdFx0bGV0IGRlcGVuZGVuY2llcyA9IHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGZpcnN0RGVjbGFyYXRpb24uaW5pdCk7XG5cdFx0Y29uc3QgaW5pdFJlc3VsdCA9IFtdO1xuXHRcdGlmIChhY3R1YWxUeXBlID09PSAnSW50ZWdlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInICYmICFpbkZvckxvb3BJbml0KSB7XG5cdFx0XHR0aGlzLmRlY2xhcmF0aW9uc1tmaXJzdERlY2xhcmF0aW9uLmlkLm5hbWVdID0gT2JqZWN0LmZyZWV6ZSh7XG5cdFx0XHRcdHR5cGU6ICdOdW1iZXInLFxuXHRcdFx0XHRkZXBlbmRlbmNpZXMsXG5cdFx0XHRcdGlzU2FmZTogdGhpcy5pc1NhZmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSxcblx0XHRcdH0pO1xuXHRcdFx0aW5pdFJlc3VsdC5wdXNoKCdmbG9hdCAnKTtcblx0XHRcdGluaXRSZXN1bHQucHVzaChgdXNlcl8ke2ZpcnN0RGVjbGFyYXRpb24uaWQubmFtZX09YCk7XG5cdFx0XHRpbml0UmVzdWx0LnB1c2goJ2Zsb2F0KCcpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGluaXQsIGluaXRSZXN1bHQpO1xuXHRcdFx0aW5pdFJlc3VsdC5wdXNoKCcpJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZGVjbGFyYXRpb25zW2ZpcnN0RGVjbGFyYXRpb24uaWQubmFtZV0gPSBPYmplY3QuZnJlZXplKHtcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0ZGVwZW5kZW5jaWVzLFxuXHRcdFx0XHRpc1NhZmU6IHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyksXG5cdFx0XHR9KTtcblx0XHRcdGluaXRSZXN1bHQucHVzaChgJHttYXJrdXBUeXBlfSBgKTtcblx0XHRcdGluaXRSZXN1bHQucHVzaChgdXNlcl8ke2ZpcnN0RGVjbGFyYXRpb24uaWQubmFtZX09YCk7XG5cdFx0XHRpZiAoYWN0dWFsVHlwZSA9PT0gJ051bWJlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG5cdFx0XHRcdGluaXRSZXN1bHQucHVzaCgnaW50KCcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoaW5pdCwgaW5pdFJlc3VsdCk7XG5cdFx0XHRcdGluaXRSZXN1bHQucHVzaCgnKScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGluaXQsIGluaXRSZXN1bHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQucHVzaChpbml0UmVzdWx0LmpvaW4oJycpKTtcblxuXHRcdC8vIGZpcnN0IGRlY2xhcmF0aW9uIGlzIGRvbmUsIG5vdyBhZGQgbXVsdGlwbGUgc3RhdGVtZW50c1xuXHRcdGxldCBsYXN0VHlwZSA9IHR5cGU7XG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW2ldO1xuXHRcdFx0Y29uc3QgbmV4dFJlc3VsdCA9IFtdO1xuXHRcdFx0aWYgKCFpbkZvckxvb3BJbml0KSB7XG5cdFx0XHRcdGxldCBwb3NzaWJsZU5ld1R5cGUgPSB0aGlzLmdldFR5cGUoZGVjbGFyYXRpb24uaW5pdCk7XG5cdFx0XHRcdGlmIChwb3NzaWJsZU5ld1R5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcblx0XHRcdFx0XHRwb3NzaWJsZU5ld1R5cGUgPSAnTnVtYmVyJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocG9zc2libGVOZXdUeXBlICE9PSBsYXN0VHlwZSkge1xuXHRcdFx0XHRcdG5leHRSZXN1bHQucHVzaCgnOycpO1xuXHRcdFx0XHRcdG5leHRSZXN1bHQucHVzaCh0eXBlTWFwW3Bvc3NpYmxlTmV3VHlwZV0sICcgJyk7XG5cdFx0XHRcdFx0bGFzdFR5cGUgPSBwb3NzaWJsZU5ld1R5cGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV4dFJlc3VsdC5wdXNoKCcsJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5leHRSZXN1bHQucHVzaCgnLCcpO1xuXHRcdFx0fVxuXHRcdFx0ZGVwZW5kZW5jaWVzID0gdGhpcy5nZXREZXBlbmRlbmNpZXMoZGVjbGFyYXRpb24pO1xuXHRcdFx0dGhpcy5kZWNsYXJhdGlvbnNbZGVjbGFyYXRpb24uaWQubmFtZV0gPSBPYmplY3QuZnJlZXplKHtcblx0XHRcdFx0dHlwZTogbGFzdFR5cGUsXG5cdFx0XHRcdGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzLFxuXHRcdFx0XHRpc1NhZmU6IHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyksXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhkZWNsYXJhdGlvbiwgbmV4dFJlc3VsdCk7XG5cdFx0XHRyZXN1bHQucHVzaChuZXh0UmVzdWx0LmpvaW4oJycpKTtcblx0XHR9XG5cblx0XHRyZXRBcnIucHVzaChyZXN1bHQuam9pbignJykpO1xuXHRcdGlmICghaW5Gb3JMb29wSW5pdCkge1xuXHRcdFx0cmV0QXJyLnB1c2goJzsnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqSWYqIFN0YXRlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gaWZOb2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RJZlN0YXRlbWVudChpZk5vZGUsIHJldEFycikge1xuXHRcdHJldEFyci5wdXNoKCdpZiAoJyk7XG5cdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS50ZXN0LCByZXRBcnIpO1xuXHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0aWYgKGlmTm9kZS5jb25zZXF1ZW50LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0QXJyLnB1c2goJyB7XFxuJyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnXFxufVxcbicpO1xuXHRcdH1cblxuXHRcdGlmIChpZk5vZGUuYWx0ZXJuYXRlKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgnZWxzZSAnKTtcblx0XHRcdGlmIChpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnIHtcXG4nKTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlRoaXMqIGV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtPYmplY3R9IHROb2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RUaGlzRXhwcmVzc2lvbih0Tm9kZSwgcmV0QXJyKSB7XG5cdFx0cmV0QXJyLnB1c2goJ3RoaXMnKTtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpNZW1iZXIqIEV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtPYmplY3R9IG1Ob2RlIC0gQW4gYXN0IE5vZGVcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RNZW1iZXJFeHByZXNzaW9uKG1Ob2RlLCByZXRBcnIpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRwcm9wZXJ0eSxcblx0XHRcdG5hbWUsXG5cdFx0XHRzaWduYXR1cmUsXG5cdFx0XHRvcmlnaW4sXG5cdFx0XHR0eXBlLFxuXHRcdFx0eFByb3BlcnR5LFxuXHRcdFx0eVByb3BlcnR5LFxuXHRcdFx0elByb3BlcnR5XG5cdFx0fSA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMobU5vZGUpO1xuXHRcdHN3aXRjaCAoc2lnbmF0dXJlKSB7XG5cdFx0XHRjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG5cdFx0XHRcdGlmIChuYW1lICE9PSAneCcgJiYgbmFtZSAhPT0gJ3knICYmIG5hbWUgIT09ICd6Jykge1xuXHRcdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbiwgZXhwZWN0ZWQgYHRoaXMudGhyZWFkLnhgLCBgdGhpcy50aHJlYWQueWAsIG9yIGB0aGlzLnRocmVhZC56YCcsIG1Ob2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXRBcnIucHVzaChgdGhyZWFkSWQuJHtuYW1lfWApO1xuXHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0Y2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuXHRcdFx0XHRzd2l0Y2ggKG5hbWUpIHtcblx0XHRcdFx0XHRjYXNlICd4Jzpcblx0XHRcdFx0XHRcdGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzBdLCAnLjAnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3knOlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMV0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMV0sICcuMCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCh0aGlzLm91dHB1dFsyXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCh0aGlzLm91dHB1dFsyXSwgJy4wJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRjYXNlICd2YWx1ZSc6XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcblx0XHRcdGNhc2UgJ3ZhbHVlW10nOlxuXHRcdFx0Y2FzZSAndmFsdWVbXVtdJzpcblx0XHRcdGNhc2UgJ3ZhbHVlW11bXVtdJzpcblx0XHRcdGNhc2UgJ3ZhbHVlW11bXVtdW10nOlxuXHRcdFx0Y2FzZSAndmFsdWUudmFsdWUnOlxuXHRcdFx0XHRpZiAob3JpZ2luID09PSAnTWF0aCcpIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaChNYXRoW25hbWVdKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAocHJvcGVydHkpIHtcblx0XHRcdFx0XHRjYXNlICdyJzpcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfS5yYCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0XHRcdGNhc2UgJ2cnOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goYHVzZXJfJHsgbmFtZSB9LmdgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH0uYmApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHRcdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfS5hYCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndGhpcy5jb25zdGFudHMudmFsdWUnOlxuXHRcdFx0Y2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG5cdFx0XHRjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuXHRcdFx0Y2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nOlxuXHRcdFx0Y2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW11bXSc6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZm4oKVtdJzpcblx0XHRcdFx0dGhpcy5hc3RDYWxsRXhwcmVzc2lvbihtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdbJyk7XG5cdFx0XHRcdHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHByb3BlcnR5KSk7XG5cdFx0XHRcdHJldEFyci5wdXNoKCddJyk7XG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRjYXNlICdbXVtdJzpcblx0XHRcdFx0dGhpcy5hc3RBcnJheUV4cHJlc3Npb24obU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnWycpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChwcm9wZXJ0eSkpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBzaW1wbGUgdHlwZXNcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0cmV0QXJyLnB1c2goYCR7IG9yaWdpbiB9XyR7IG5hbWV9YCk7XG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0QXJyLnB1c2goYGJvb2woJHsgb3JpZ2luIH1fJHsgbmFtZX0pYCk7XG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0Ly8gaGFuZGxlIG1vcmUgY29tcGxleCB0eXBlc1xuXHRcdC8vIGFyZ3VtZW50IG1heSBoYXZlIGNvbWUgZnJvbSBhIHBhcmVudFxuXHRcdGxldCBzeW5vbnltTmFtZSA9IHRoaXMuZ2V0S2VybmVsQXJndW1lbnROYW1lKG5hbWUpO1xuXG5cdFx0Y29uc3QgbWFya3VwTmFtZSA9IGAke29yaWdpbn1fJHtzeW5vbnltTmFtZSB8fCBuYW1lfWA7XG5cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdGNhc2UgJ0FycmF5KDMpJzpcblx0XHRcdGNhc2UgJ0FycmF5KDQpJzpcblx0XHRcdFx0Ly8gR2V0IGZyb20gbG9jYWwgdmVjNFxuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnWycpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh4UHJvcGVydHkpKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJ10nKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG5cdFx0XHRcdHJldEFyci5wdXNoKGBnZXRJbWFnZTNEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcblx0XHRcdFx0dGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcblx0XHRcdFx0cmV0QXJyLnB1c2goYGdldEZsb2F0RnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG5cdFx0XHRcdHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRcdHJldEFyci5wdXNoKGBnZXRWZWMyRnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG5cdFx0XHRcdHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG5cdFx0XHRcdHJldEFyci5wdXNoKGBnZXRWZWMzRnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG5cdFx0XHRcdHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHRyZXRBcnIucHVzaChgZ2V0VmVjNEZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuXHRcdFx0XHR0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdGNhc2UgJ0FycmF5MkQnOlxuXHRcdFx0Y2FzZSAnQXJyYXkzRCc6XG5cdFx0XHRjYXNlICdBcnJheTREJzpcblx0XHRcdGNhc2UgJ0lucHV0JzpcblxuXHRcdFx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdFx0Ly8gYml0UmF0aW8gaXMgYWx3YXlzIDQgaGVyZSwgamF2YXNjcmlwdCBkb2Vzbid0IHlldCBoYXZlIDggb3IgMTYgYml0IHN1cHBvcnRcblx0XHRcdFx0XHQvLyBUT0RPOiBtYWtlIDggb3IgMTYgYml0IHdvcmsgYW55d2F5IVxuXHRcdFx0XHRcdHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWQzMigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG5cdFx0XHRcdFx0dGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBiaXRSYXRpbyA9IChvcmlnaW4gPT09ICd1c2VyJyA/XG5cdFx0XHRcdFx0XHR0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyh0aGlzLm5hbWUsIG5hbWUpIDpcblx0XHRcdFx0XHRcdHRoaXMuY29uc3RhbnRCaXRSYXRpb3NbbmFtZV1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHN3aXRjaCAoYml0UmF0aW8pIHtcblx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goYGdldDgoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goYGdldDE2KCR7bWFya3VwTmFtZX0sICR7bWFya3VwTmFtZX1TaXplLCAke21hcmt1cE5hbWV9RGltLCBgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKGBnZXQzMigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgYml0IHJhdGlvIG9mICR7IGJpdFJhdGlvfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRcdHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWQzMigkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG5cdFx0XHRcdHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIG1lbWJlciBleHByZXNzaW9uIFwiJHsgdHlwZSB9XCJgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqY2FsbCogZXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyAge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRpZiAoIWFzdC5jYWxsZWUpIHtcblx0XHRcdC8vIEZhaWx1cmUsIHVua25vd24gZXhwcmVzc2lvblxuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcblx0XHRcdFx0J1Vua25vd24gQ2FsbEV4cHJlc3Npb24nLFxuXHRcdFx0XHRhc3Rcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRoZSBmdWxsIGZ1bmN0aW9uIGNhbGwsIHVucm9sbGVkXG5cdFx0bGV0IGZ1bmN0aW9uTmFtZSA9IHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QuY2FsbGVlKTtcblx0XHRjb25zdCBpc01hdGhGdW5jdGlvbiA9IGZ1bmN0aW9uTmFtZS5pbmRleE9mKGpzTWF0aFByZWZpeCkgPT09IDA7XG5cblx0XHQvLyBJdHMgYSBtYXRoIG9wZXJhdG9yLCByZW1vdmUgdGhlIHByZWZpeFxuXHRcdGlmIChpc01hdGhGdW5jdGlvbikge1xuXHRcdFx0ZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lLnNsaWNlKGpzTWF0aFByZWZpeC5sZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIEl0cyBhIGxvY2FsIGZ1bmN0aW9uLCByZW1vdmUgdGhpc1xuXHRcdGlmIChmdW5jdGlvbk5hbWUuaW5kZXhPZihsb2NhbFByZWZpeCkgPT09IDApIHtcblx0XHRcdGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZS5zbGljZShsb2NhbFByZWZpeC5sZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoaXMgaWYgZ3Jvd3MgdG8gbW9yZSB0aGFuIG9uZSwgbGV0cyB1c2UgYSBzd2l0Y2hcblx0XHRpZiAoZnVuY3Rpb25OYW1lID09PSAnYXRhbjInKSB7XG5cdFx0XHRmdW5jdGlvbk5hbWUgPSAnYXRhbic7XG5cdFx0fVxuXG5cdFx0Ly8gUmVnaXN0ZXIgdGhlIGZ1bmN0aW9uIGludG8gdGhlIGNhbGxlZCByZWdpc3RyeVxuXHRcdGlmICh0aGlzLmNhbGxlZEZ1bmN0aW9ucy5pbmRleE9mKGZ1bmN0aW9uTmFtZSkgPCAwKSB7XG5cdFx0XHR0aGlzLmNhbGxlZEZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ3JhbmRvbScgJiYgdGhpcy5wbHVnaW5zICYmIHRoaXMucGx1Z2lucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbaV07XG5cdFx0XHRcdGlmIChwbHVnaW4uZnVuY3Rpb25NYXRjaCA9PT0gJ01hdGgucmFuZG9tKCknICYmIHBsdWdpbi5mdW5jdGlvblJlcGxhY2UpIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaChwbHVnaW4uZnVuY3Rpb25SZXBsYWNlKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdHJhY2sgdGhlIGZ1bmN0aW9uIHdhcyBjYWxsZWRcblx0XHRpZiAodGhpcy5vbkZ1bmN0aW9uQ2FsbCkge1xuXHRcdFx0dGhpcy5vbkZ1bmN0aW9uQ2FsbCh0aGlzLm5hbWUsIGZ1bmN0aW9uTmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgZnVuY3Rpb25cblx0XHRyZXRBcnIucHVzaChmdW5jdGlvbk5hbWUpO1xuXG5cdFx0Ly8gT3BlbiBhcmd1bWVudHMgc3BhY2Vcblx0XHRyZXRBcnIucHVzaCgnKCcpO1xuXG5cdFx0Ly8gQWRkIHRoZSBhcmd1bWVudHNcblx0XHRpZiAoaXNNYXRoRnVuY3Rpb24pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG5cdFx0XHRcdGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG5cdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcsICcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoIChhcmd1bWVudFR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnZmxvYXQoJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHRhcmdldFR5cGVzID0gdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB8fCBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG5cdFx0XHRcdGxldCB0YXJnZXRUeXBlID0gdGFyZ2V0VHlwZXNbaV07XG5cdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcsICcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG5cdFx0XHRcdGlmICghdGFyZ2V0VHlwZSkge1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCB0aGlzKTtcblx0XHRcdFx0XHR0YXJnZXRUeXBlID0gYXJndW1lbnRUeXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAoYXJndW1lbnRUeXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdpbnQoJyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0XHRcdGlmICh0YXJnZXRUeXBlID09PSAnTnVtYmVyJyB8fCB0YXJnZXRUeXBlID09PSAnRmxvYXQnKSB7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdMaXRlcmFsSW50ZWdlcic6XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdBcnJheSgyKSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5KDQpJzpcblx0XHRcdFx0XHRcdGlmICh0YXJnZXRUeXBlID09PSBhcmd1bWVudFR5cGUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHRjYXNlICdJbnB1dCc6XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0VHlwZSA9PT0gYXJndW1lbnRUeXBlKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlclRyYWNrQXJndW1lbnRTeW5vbnltKHRoaXMubmFtZSwgYXJndW1lbnQubmFtZSwgZnVuY3Rpb25OYW1lLCBpKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGFyZ3VtZW50IGNvbWJpbmF0aW9uIG9mICR7IGFyZ3VtZW50VHlwZSB9IGFuZCAkeyB0YXJnZXRUeXBlIH1gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gQ2xvc2UgYXJndW1lbnRzIHNwYWNlXG5cdFx0cmV0QXJyLnB1c2goJyknKTtcblxuXHRcdHJldHVybiByZXRBcnI7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKkFycmF5KiBFeHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcnJOb2RlIC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG5cdCAqL1xuXHRhc3RBcnJheUV4cHJlc3Npb24oYXJyTm9kZSwgcmV0QXJyKSB7XG5cdFx0Y29uc3QgYXJyTGVuID0gYXJyTm9kZS5lbGVtZW50cy5sZW5ndGg7XG5cblx0XHRyZXRBcnIucHVzaCgndmVjJyArIGFyckxlbiArICcoJyk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcsICcpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3Qgc3ViTm9kZSA9IGFyck5vZGUuZWxlbWVudHNbaV07XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoc3ViTm9kZSwgcmV0QXJyKVxuXHRcdH1cblx0XHRyZXRBcnIucHVzaCgnKScpO1xuXG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxuXG5cdG1lbWJlckV4cHJlc3Npb25YWVooeCwgeSwgeiwgcmV0QXJyKSB7XG5cdFx0aWYgKHopIHtcblx0XHRcdHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHopLCAnLCAnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0QXJyLnB1c2goJzAsICcpO1xuXHRcdH1cblx0XHRpZiAoeSkge1xuXHRcdFx0cmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeSksICcsICcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRBcnIucHVzaCgnMCwgJyk7XG5cdFx0fVxuXHRcdHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHgpKTtcblx0XHRyZXR1cm4gcmV0QXJyO1xuXHR9XG5cblx0bWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHByb3BlcnR5KSB7XG5cdFx0aWYgKCFwcm9wZXJ0eSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBub3Qgc2V0Jyk7XG5cdFx0fVxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUocHJvcGVydHkpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuXHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuXHRcdFx0cmVzdWx0LnB1c2goJ2ludCgnKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhwcm9wZXJ0eSwgcmVzdWx0KTtcblx0XHRcdHJlc3VsdC5wdXNoKCcpJyk7XG5cdFx0XHR0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcblx0XHRcdHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhwcm9wZXJ0eSwgcmVzdWx0KTtcblx0XHRcdHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMocHJvcGVydHksIHJlc3VsdCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQuam9pbignJyk7XG5cdH1cbn1cblxuY29uc3QgdHlwZU1hcCA9IHtcblx0J0FycmF5JzogJ3NhbXBsZXIyRCcsXG5cdCdBcnJheSgyKSc6ICd2ZWMyJyxcblx0J0FycmF5KDMpJzogJ3ZlYzMnLFxuXHQnQXJyYXkoNCknOiAndmVjNCcsXG5cdCdBcnJheTJEJzogJ3NhbXBsZXIyRCcsXG5cdCdBcnJheTNEJzogJ3NhbXBsZXIyRCcsXG5cdCdCb29sZWFuJzogJ2Jvb2wnLFxuXHQnRmxvYXQnOiAnZmxvYXQnLFxuXHQnSW5wdXQnOiAnc2FtcGxlcjJEJyxcblx0J0ludGVnZXInOiAnaW50Jyxcblx0J051bWJlcic6ICdmbG9hdCcsXG5cdCdMaXRlcmFsSW50ZWdlcic6ICdmbG9hdCcsXG5cdCdOdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG5cdCdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG5cdCdBcnJheVRleHR1cmUoMSknOiAnc2FtcGxlcjJEJyxcblx0J0FycmF5VGV4dHVyZSgyKSc6ICdzYW1wbGVyMkQnLFxuXHQnQXJyYXlUZXh0dXJlKDMpJzogJ3NhbXBsZXIyRCcsXG5cdCdBcnJheVRleHR1cmUoNCknOiAnc2FtcGxlcjJEJyxcbn07XG5cbmNvbnN0IG9wZXJhdG9yTWFwID0ge1xuXHQnPT09JzogJz09Jyxcblx0JyE9PSc6ICchPSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRXZWJHTEZ1bmN0aW9uTm9kZVxufTsiLCJjb25zdCB7XG5cdHV0aWxzXG59ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHtcblx0a2VybmVsUnVuU2hvcnRjdXRcbn0gPSByZXF1aXJlKCcuLi8uLi9rZXJuZWwtcnVuLXNob3J0Y3V0Jyk7XG5cbmZ1bmN0aW9uIHJlbW92ZUZuTm9pc2UoZm4pIHtcblx0aWYgKC9eZnVuY3Rpb24gLy50ZXN0KGZuKSkge1xuXHRcdGZuID0gZm4uc3Vic3RyaW5nKDkpO1xuXHR9XG5cdHJldHVybiBmbi5yZXBsYWNlKC9bX110eXBlb2YvZywgJ3R5cGVvZicpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2lzZShzdHIpIHtcblx0cmV0dXJuIHN0clxuXHRcdC5yZXBsYWNlKC9eW0EtWmEtejIzXSsvLCAnZnVuY3Rpb24nKVxuXHRcdC5yZXBsYWNlKC9bX110eXBlb2YvZywgJ3R5cGVvZicpO1xufVxuXG5mdW5jdGlvbiBib29sVG9TdHJpbmcodmFsdWUpIHtcblx0aWYgKHZhbHVlKSB7XG5cdFx0cmV0dXJuICd0cnVlJztcblx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gJ2ZhbHNlJztcblx0fVxuXHRyZXR1cm4gJ251bGwnO1xufVxuXG5mdW5jdGlvbiB3ZWJHTEtlcm5lbFN0cmluZyhncHVLZXJuZWwsIG5hbWUpIHtcblx0cmV0dXJuIGAoKSA9PiB7XG4gICAgJHsga2VybmVsUnVuU2hvcnRjdXQudG9TdHJpbmcoKSB9O1xuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgYWxsUHJvcGVydGllc09mOiAkeyByZW1vdmVOb2lzZSh1dGlscy5hbGxQcm9wZXJ0aWVzT2YudG9TdHJpbmcoKSkgfSxcbiAgICAgIGNsb25lOiAkeyByZW1vdmVOb2lzZSh1dGlscy5jbG9uZS50b1N0cmluZygpKSB9LFxuICAgICAgc3BsaXRBcnJheTogJHsgcmVtb3ZlTm9pc2UodXRpbHMuc3BsaXRBcnJheS50b1N0cmluZygpKSB9LFxuICAgICAgZ2V0VmFyaWFibGVUeXBlOiAkeyByZW1vdmVOb2lzZSh1dGlscy5nZXRWYXJpYWJsZVR5cGUudG9TdHJpbmcoKSkgfSxcbiAgICAgIGdldERpbWVuc2lvbnM6ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmdldERpbWVuc2lvbnMudG9TdHJpbmcoKSkgfSxcbiAgICAgIGRpbVRvVGV4U2l6ZTogJHsgcmVtb3ZlTm9pc2UodXRpbHMuZGltVG9UZXhTaXplLnRvU3RyaW5nKCkpIH0sXG4gICAgICBjbG9zZXN0U3F1YXJlRGltZW5zaW9uczogJHsgcmVtb3ZlTm9pc2UodXRpbHMuY2xvc2VzdFNxdWFyZURpbWVuc2lvbnMudG9TdHJpbmcoKSkgfSxcbiAgICAgIGdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemU6ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUudG9TdHJpbmcoKSkgfSxcbiAgICAgIGdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplOiAkeyByZW1vdmVOb2lzZSh1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZS50b1N0cmluZygpKSB9LFxuICAgICAgcm91bmRUbzogJHsgcmVtb3ZlTm9pc2UodXRpbHMucm91bmRUby50b1N0cmluZygpKSB9LFxuICAgICAgZmxhdHRlblRvOiAkeyByZW1vdmVOb2lzZSh1dGlscy5mbGF0dGVuVG8udG9TdHJpbmcoKSkgfSxcbiAgICAgIGZsYXR0ZW4yZEFycmF5VG86ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmZsYXR0ZW4yZEFycmF5VG8udG9TdHJpbmcoKSkgfSxcbiAgICAgIGZsYXR0ZW4zZEFycmF5VG86ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8udG9TdHJpbmcoKSkgfSxcbiAgICAgIHN5c3RlbUVuZGlhbm5lc3M6ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmdldFN5c3RlbUVuZGlhbm5lc3MudG9TdHJpbmcoKSkgfSxcbiAgICAgIGlzQXJyYXk6ICR7IHJlbW92ZU5vaXNlKHV0aWxzLmlzQXJyYXkudG9TdHJpbmcoKSkgfVxuICAgIH07XG4gICAgY29uc3QgY2FudmFzZXMgPSBbXTtcbiAgICBjb25zdCBtYXhUZXhTaXplcyA9IHt9O1xuICAgIGxldCBUZXh0dXJlID0gZnVuY3Rpb24oKSB7fTtcbiAgICBsZXQgSW5wdXQgPSBmdW5jdGlvbigpIHt9OyBcbiAgICBjbGFzcyAkeyBuYW1lIHx8ICdLZXJuZWwnIH0ge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWF4VGV4U2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYXJndW1lbnRzTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb25zdGFudHNMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0gJHsgZ3B1S2VybmVsLmNvbnN0YW50Qml0UmF0aW9zID8gSlNPTi5zdHJpbmdpZnkoZ3B1S2VybmVsLmNvbnN0YW50Qml0UmF0aW9zKSA6ICdudWxsJyB9O1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViS2VybmVscyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViS2VybmVsTmFtZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gJHsgZ3B1S2VybmVsLmRyYXdCdWZmZXJzTWFwID8gSlNPTi5zdHJpbmdpZnkoZ3B1S2VybmVsLmRyYXdCdWZmZXJzTWFwKSA6ICdudWxsJyB9O1xuICAgICAgICB0aGlzLmVuZGlhbm5lc3MgPSAnJHsgZ3B1S2VybmVsLmVuZGlhbm5lc3MgfSc7XG4gICAgICAgIHRoaXMuZ3JhcGhpY2FsID0gJHsgYm9vbFRvU3RyaW5nKGdwdUtlcm5lbC5ncmFwaGljYWwpIH07XG4gICAgICAgIHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9ICR7IGJvb2xUb1N0cmluZyhncHVLZXJuZWwub3B0aW1pemVGbG9hdE1lbW9yeSkgfTtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSBcIiR7IGdwdUtlcm5lbC5wcmVjaXNpb24gfVwiO1xuICAgICAgICAvLyBUT0RPOiBub3Qgc3VyZSBob3cgdG8gaGFuZGxlXG4gICAgICAgIHRoaXMuZmxvYXRPdXRwdXRGb3JjZSA9ICR7IGJvb2xUb1N0cmluZyhncHVLZXJuZWwuZmxvYXRPdXRwdXRGb3JjZSkgfTtcbiAgICAgICAgdGhpcy5oYXJkY29kZUNvbnN0YW50cyA9ICR7IGJvb2xUb1N0cmluZyhncHVLZXJuZWwuaGFyZGNvZGVDb25zdGFudHMpIH07XG4gICAgICAgIHRoaXMucGlwZWxpbmUgPSAkeyBib29sVG9TdHJpbmcoZ3B1S2VybmVsLnBpcGVsaW5lKSB9O1xuICAgICAgICB0aGlzLmFyZ3VtZW50TmFtZXMgPSAkeyBKU09OLnN0cmluZ2lmeShncHVLZXJuZWwuYXJndW1lbnROYW1lcykgfTtcbiAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzID0gJHsgSlNPTi5zdHJpbmdpZnkoZ3B1S2VybmVsLmFyZ3VtZW50VHlwZXMpIH07XG4gICAgICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSAkeyBKU09OLnN0cmluZ2lmeShncHVLZXJuZWwuYXJndW1lbnRCaXRSYXRpb3MpIH07XG4gICAgICAgXG4gICAgICAgIHRoaXMudGV4U2l6ZSA9ICR7IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oZ3B1S2VybmVsLnRleFNpemUpKSB9O1xuICAgICAgICB0aGlzLm91dHB1dCA9ICR7IEpTT04uc3RyaW5naWZ5KGdwdUtlcm5lbC5vdXRwdXQpIH07XG4gICAgICAgIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IFxcYCR7IGdwdUtlcm5lbC5jb21waWxlZEZyYWdtZW50U2hhZGVyIH1cXGA7XG5cdFx0ICAgIHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXIgPSBcXGAkeyBncHVLZXJuZWwuY29tcGlsZWRWZXJ0ZXhTaGFkZXIgfVxcYDtcblx0XHQgICAgdGhpcy5yZXR1cm5UeXBlID0gJyR7IGdwdUtlcm5lbC5yZXR1cm5UeXBlIH0nO1xuXHRcdCAgICB0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZSA9IHt9O1xuXHRcdCAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuXHRcdCAgICB0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzID0gbnVsbDtcblx0XHQgICAgdGhpcy5leHRlbnNpb25zID0ge307XG5cdFx0ICAgIHRoaXMudW5pZm9ybTFmQ2FjaGUgPSB7fTtcblx0XHQgICAgdGhpcy51bmlmb3JtMWlDYWNoZSA9IHt9O1xuXHRcdCAgICB0aGlzLnVuaWZvcm0yZkNhY2hlID0ge307XG5cdFx0ICAgIHRoaXMudW5pZm9ybTJmdkNhY2hlID0ge307XG5cdFx0ICAgIHRoaXMudW5pZm9ybTJpdkNhY2hlID0ge307XG5cdFx0ICAgIHRoaXMudW5pZm9ybTNmdkNhY2hlID0ge307XG5cdFx0ICAgIHRoaXMudW5pZm9ybTNpdkNhY2hlID0ge307XG4gICAgICB9XG4gICAgICBnZXRGcmFnbWVudFNoYWRlcigpIHsgcmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlcjsgfVxuICAgICAgZ2V0VmVydGV4U2hhZGVyKCkgeyByZXR1cm4gdGhpcy5jb21waWxlZFZlcnRleFNoYWRlcjsgfVxuICAgICAgdmFsaWRhdGVTZXR0aW5ncygpIHt9XG4gICAgICBpbml0RXh0ZW5zaW9ucygpIHt9XG4gICAgICBzZXR1cEFyZ3VtZW50cygpIHt9XG4gICAgICBzZXR1cENvbnN0YW50cygpIHt9XG4gICAgICBzZXRDYW52YXMoY2FudmFzKSB7IHRoaXMuY2FudmFzID0gY2FudmFzOyByZXR1cm4gdGhpczsgfVxuICAgICAgc2V0Q29udGV4dChjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9XG4gICAgICBzZXRUZXh0dXJlKFR5cGUpIHsgVGV4dHVyZSA9IFR5cGU7IH1cbiAgICAgIHNldElucHV0KFR5cGUpIHsgSW5wdXQgPSBUeXBlOyB9XG4gICAgICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5nZXRVbmlmb3JtTG9jYXRpb24udG9TdHJpbmcoKSkgfVxuICAgICAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuYnVpbGQudG9TdHJpbmcoKSkgfVxuICAgICAgdHJhbnNsYXRlU291cmNlKCkge31cbiAgICAgIHBpY2tSZW5kZXJTdHJhdGVneSgpIHt9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5ydW4udG9TdHJpbmcoKSkgfVxuXHRcdCAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuYWRkQXJndW1lbnQudG9TdHJpbmcoKSkgfVxuXHRcdCAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuZm9ybWF0QXJyYXlUcmFuc2Zlci50b1N0cmluZygpKSB9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5jaGVja091dHB1dC50b1N0cmluZygpKSB9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5nZXRBcmd1bWVudFRleHR1cmUudG9TdHJpbmcoKSkgfVxuXHRcdCAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuZ2V0VGV4dHVyZUNhY2hlLnRvU3RyaW5nKCkpIH1cblx0XHQgICR7IHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLmdldE91dHB1dFRleHR1cmUudG9TdHJpbmcoKSkgfVxuXHRcdCAgcmVuZGVyT3V0cHV0KCkgeyAkeyB1dGlscy5nZXRGdW5jdGlvbkJvZHlGcm9tU3RyaW5nKHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLnJlbmRlck91dHB1dC50b1N0cmluZygpKSkgfSB9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5yZWFkUGFja2VkUGl4ZWxzVG9GbG9hdDMyQXJyYXkudG9TdHJpbmcoKSkgfVxuXHRcdCAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheS50b1N0cmluZygpKSB9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5yZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheS50b1N0cmluZygpKSB9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC51cGRhdGVNYXhUZXhTaXplLnRvU3RyaW5nKCkpIH1cblx0XHQgICR7IHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLl9zZXR1cE91dHB1dFRleHR1cmUudG9TdHJpbmcoKSkgfVxuXHRcdCAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuZGV0YWNoVGV4dHVyZUNhY2hlLnRvU3RyaW5nKCkpIH1cblx0XHQgICR7IHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLnNldFVuaWZvcm0xZi50b1N0cmluZygpKSB9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5zZXRVbmlmb3JtMWkudG9TdHJpbmcoKSkgfVxuXHRcdCAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuc2V0VW5pZm9ybTJmLnRvU3RyaW5nKCkpIH1cblx0XHQgICR7IHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLnNldFVuaWZvcm0yZnYudG9TdHJpbmcoKSkgfVxuXHRcdCAgJHsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuc2V0VW5pZm9ybTJpdi50b1N0cmluZygpKSB9XG5cdFx0ICAkeyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5zZXRVbmlmb3JtM2Z2LnRvU3RyaW5nKCkpIH1cblx0XHQgICR7IHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLnNldFVuaWZvcm0zaXYudG9TdHJpbmcoKSkgfVxuXHRcdCAgZ2V0UmV0dXJuVGV4dHVyZVR5cGUoKSB7IHJldHVybiBcIiR7IGdwdUtlcm5lbC5nZXRSZXR1cm5UZXh0dXJlVHlwZSgpIH1cIjsgfVxuICAgIH07XG4gICAgcmV0dXJuIGtlcm5lbFJ1blNob3J0Y3V0KG5ldyAkeyBuYW1lIHx8ICdLZXJuZWwnIH0oKSk7XG4gIH07YDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHdlYkdMS2VybmVsU3RyaW5nXG59OyIsImNvbnN0IHtcblx0R0xLZXJuZWxcbn0gPSByZXF1aXJlKCcuLi9nbC1rZXJuZWwnKTtcbmNvbnN0IHtcblx0RnVuY3Rpb25CdWlsZGVyXG59ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3Qge1xuXHRXZWJHTEZ1bmN0aW9uTm9kZVxufSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3Qge1xuXHR1dGlsc1xufSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7XG5cdFRleHR1cmVcbn0gPSByZXF1aXJlKCcuLi8uLi90ZXh0dXJlJyk7XG5jb25zdCB0cmlhbmdsZU5vaXNlID0gcmVxdWlyZSgnLi4vLi4vcGx1Z2lucy90cmlhbmdsZS1ub2lzZScpO1xuY29uc3Qge1xuXHRmcmFnbWVudFNoYWRlclxufSA9IHJlcXVpcmUoJy4vZnJhZ21lbnQtc2hhZGVyJyk7XG5jb25zdCB7XG5cdHZlcnRleFNoYWRlclxufSA9IHJlcXVpcmUoJy4vdmVydGV4LXNoYWRlcicpO1xuY29uc3Qge1xuXHR3ZWJHTEtlcm5lbFN0cmluZ1xufSA9IHJlcXVpcmUoJy4va2VybmVsLXN0cmluZycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jb25zdCBwbHVnaW5zID0gW3RyaWFuZ2xlTm9pc2VdO1xuY29uc3QgY2FudmFzZXMgPSBbXTtcbmNvbnN0IG1heFRleFNpemVzID0ge307XG5cbi8qKlxuICogQGRlc2MgS2VybmVsIEltcGxlbWVudGF0aW9uIGZvciBXZWJHTC5cbiAqIDxwPlRoaXMgYnVpbGRzIHRoZSBzaGFkZXJzIGFuZCBydW5zIHRoZW0gb24gdGhlIEdQVSxcbiAqIHRoZSBvdXRwdXRzIHRoZSByZXN1bHQgYmFjayBhcyBmbG9hdChlbmFibGVkIGJ5IGRlZmF1bHQpIGFuZCBUZXh0dXJlLjwvcD5cbiAqXG4gKiBAcHJvcCB7T2JqZWN0fSB0ZXh0dXJlQ2FjaGUgLSB3ZWJHbCBUZXh0dXJlIGNhY2hlXG4gKiBAcHJvcCB7T2JqZWN0fSB0aHJlYWREaW0gLSBUaGUgdGhyZWFkIGRpbWVuc2lvbnMsIHgsIHkgYW5kIHpcbiAqIEBwcm9wIHtPYmplY3R9IHByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZSAtIExvY2F0aW9uIG9mIHByb2dyYW0gdmFyaWFibGVzIGluIG1lbW9yeVxuICogQHByb3Age09iamVjdH0gZnJhbWVidWZmZXIgLSBXZWJnbCBmcmFtZUJ1ZmZlclxuICogQHByb3Age09iamVjdH0gYnVmZmVyIC0gV2ViR0wgYnVmZmVyXG4gKiBAcHJvcCB7T2JqZWN0fSBwcm9ncmFtIC0gVGhlIHdlYkdsIFByb2dyYW1cbiAqIEBwcm9wIHtPYmplY3R9IGZ1bmN0aW9uQnVpbGRlciAtIEZ1bmN0aW9uIEJ1aWxkZXIgaW5zdGFuY2UgYm91bmQgdG8gdGhpcyBLZXJuZWxcbiAqIEBwcm9wIHtCb29sZWFufSBwaXBlbGluZSAtIFNldCBvdXRwdXQgdHlwZSB0byBGQVNUIG1vZGUgKEdQVSB0byBHUFUgdmlhIFRleHR1cmVzKSwgaW5zdGVhZCBvZiBmbG9hdFxuICogQHByb3Age1N0cmluZ30gZW5kaWFubmVzcyAtIEVuZGlhbiBpbmZvcm1hdGlvbiBsaWtlIExpdHRsZS1lbmRpYW4sIEJpZy1lbmRpYW4uXG4gKiBAcHJvcCB7QXJyYXl9IGFyZ3VtZW50VHlwZXMgLSBUeXBlcyBvZiBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuICogQHByb3Age251bWJlcn0gYXJndW1lbnRzTGVuZ3RoIC0gTnVtYmVyIG9mIHBhcmFtZXRlcnMgc2VudCB0byB0aGUgS2VybmVsXG4gKiBAcHJvcCB7U3RyaW5nfSBjb21waWxlZEZyYWdtZW50U2hhZGVyIC0gQ29tcGlsZWQgZnJhZ21lbnQgc2hhZGVyIHN0cmluZ1xuICogQHByb3Age1N0cmluZ30gY29tcGlsZWRWZXJ0ZXhTaGFkZXIgLSBDb21waWxlZCBWZXJ0aWNhbCBzaGFkZXIgc3RyaW5nXG4gKi9cbmNsYXNzIFdlYkdMS2VybmVsIGV4dGVuZHMgR0xLZXJuZWwge1xuXHRzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuXHRcdGlmIChpc1N1cHBvcnRlZCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGlzU3VwcG9ydGVkO1xuXHRcdH1cblx0XHR0aGlzLnNldHVwRmVhdHVyZUNoZWNrcygpO1xuXHRcdGlzU3VwcG9ydGVkID0gdGhpcy5pc0NvbnRleHRNYXRjaCh0ZXN0Q29udGV4dCk7XG5cdFx0cmV0dXJuIGlzU3VwcG9ydGVkO1xuXHR9XG5cblx0c3RhdGljIHNldHVwRmVhdHVyZUNoZWNrcygpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRlc3RDYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuXHRcdH1cblx0XHRpZiAoIXRlc3RDYW52YXMpIHJldHVybjtcblx0XHR0ZXN0Q29udGV4dCA9IHRlc3RDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCB0ZXN0Q2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuXHRcdGlmICghdGVzdENvbnRleHQgfHwgIXRlc3RDb250ZXh0LmdldEV4dGVuc2lvbikgcmV0dXJuO1xuXHRcdHRlc3RFeHRlbnNpb25zID0ge1xuXHRcdFx0T0VTX3RleHR1cmVfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcblx0XHRcdE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcblx0XHRcdE9FU19lbGVtZW50X2luZGV4X3VpbnQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuXHRcdFx0V0VCR0xfZHJhd19idWZmZXJzOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuXHRcdH07XG5cdFx0ZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG5cdH1cblxuXHRzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuXHRcdGlmICh0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcblx0XHRjb25zdCBpc0RyYXdCdWZmZXJzID0gdGhpcy5nZXRJc0RyYXdCdWZmZXJzKCk7XG5cdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoe1xuXHRcdFx0aXNGbG9hdFJlYWQ6IHRoaXMuZ2V0SXNGbG9hdFJlYWQoKSxcblx0XHRcdGlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU6IHRoaXMuZ2V0SXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZSgpLFxuXHRcdFx0aXNUZXh0dXJlRmxvYXQ6IHRoaXMuZ2V0SXNUZXh0dXJlRmxvYXQoKSxcblx0XHRcdGlzRHJhd0J1ZmZlcnMsXG5cdFx0XHRrZXJuZWxNYXA6IGlzRHJhd0J1ZmZlcnMsXG5cdFx0XHRjaGFubmVsQ291bnQ6IHRoaXMuZ2V0Q2hhbm5lbENvdW50KCksXG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0SXNUZXh0dXJlRmxvYXQoKSB7XG5cdFx0cmV0dXJuIEJvb2xlYW4odGVzdEV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXQpO1xuXHR9XG5cblx0c3RhdGljIGdldElzRHJhd0J1ZmZlcnMoKSB7XG5cdFx0cmV0dXJuIEJvb2xlYW4odGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzKTtcblx0fVxuXG5cdHN0YXRpYyBnZXRDaGFubmVsQ291bnQoKSB7XG5cdFx0cmV0dXJuIHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyA/IHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycy5NQVhfRFJBV19CVUZGRVJTX1dFQkdMIDogMTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgdGVzdENhbnZhcygpIHtcblx0XHRyZXR1cm4gdGVzdENhbnZhcztcblx0fVxuXG5cdHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG5cdFx0cmV0dXJuIHRlc3RDb250ZXh0O1xuXHR9XG5cblx0c3RhdGljIGdldCBmZWF0dXJlcygpIHtcblx0XHRyZXR1cm4gZmVhdHVyZXM7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IGZyYWdtZW50U2hhZGVyKCkge1xuXHRcdHJldHVybiBmcmFnbWVudFNoYWRlcjtcblx0fVxuXG5cdHN0YXRpYyBnZXQgdmVydGV4U2hhZGVyKCkge1xuXHRcdHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG5cdH1cblxuXHRjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG5cdFx0c3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG5cdFx0dGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcblx0XHR0aGlzLnRocmVhZERpbSA9IHt9O1xuXHRcdHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlID0ge307XG5cdFx0dGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XG5cblx0XHR0aGlzLmJ1ZmZlciA9IG51bGw7XG5cdFx0dGhpcy5wcm9ncmFtID0gbnVsbDtcblx0XHR0aGlzLnBpcGVsaW5lID0gc2V0dGluZ3MucGlwZWxpbmU7XG5cdFx0dGhpcy5lbmRpYW5uZXNzID0gdXRpbHMuc3lzdGVtRW5kaWFubmVzcygpO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuXHRcdHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMgPSBudWxsO1xuXHRcdHRoaXMuYXJndW1lbnRzTGVuZ3RoID0gMDtcblx0XHR0aGlzLmNvbnN0YW50c0xlbmd0aCA9IDA7XG5cdFx0dGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMudmVydFNoYWRlciA9IG51bGw7XG5cdFx0dGhpcy5kcmF3QnVmZmVyc01hcCA9IG51bGw7XG5cdFx0dGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcblx0XHR0aGlzLm1heFRleFNpemUgPSBudWxsO1xuXHRcdHRoaXMudW5pZm9ybTFmQ2FjaGUgPSB7fTtcblx0XHR0aGlzLnVuaWZvcm0xaUNhY2hlID0ge307XG5cdFx0dGhpcy51bmlmb3JtMmZDYWNoZSA9IHt9O1xuXHRcdHRoaXMudW5pZm9ybTJmdkNhY2hlID0ge307XG5cdFx0dGhpcy51bmlmb3JtMml2Q2FjaGUgPSB7fTtcblx0XHR0aGlzLnVuaWZvcm0zZnZDYWNoZSA9IHt9O1xuXHRcdHRoaXMudW5pZm9ybTNpdkNhY2hlID0ge307XG5cblx0XHR0aGlzLm1lcmdlU2V0dGluZ3Moc291cmNlLnNldHRpbmdzIHx8IHNldHRpbmdzKTtcblx0fVxuXG5cdGluaXRDYW52YXMoKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdFx0Ly8gRGVmYXVsdCB3aWR0aCBhbmQgaGVpZ2h0LCB0byBmaXggd2ViZ2wgaXNzdWUgaW4gc2FmYXJpXG5cdFx0XHRjYW52YXMud2lkdGggPSAyO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IDI7XG5cdFx0XHRyZXR1cm4gY2FudmFzO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuXHRcdH1cblx0fVxuXG5cdGluaXRDb250ZXh0KCkge1xuXHRcdGNvbnN0IHNldHRpbmdzID0ge1xuXHRcdFx0YWxwaGE6IGZhbHNlLFxuXHRcdFx0ZGVwdGg6IGZhbHNlLFxuXHRcdFx0YW50aWFsaWFzOiBmYWxzZVxuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgc2V0dGluZ3MpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHNldHRpbmdzKTtcblx0fVxuXG5cdGluaXRQbHVnaW5zKHNldHRpbmdzKSB7XG5cdFx0Ly8gZGVmYXVsdCBwbHVnaW5zXG5cdFx0Y29uc3QgcGx1Z2luc1RvVXNlID0gW107XG5cdFx0Y29uc3Qge1xuXHRcdFx0c291cmNlXG5cdFx0fSA9IHRoaXM7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcblx0XHRcdFx0aWYgKHNvdXJjZS5tYXRjaChwbHVnaW4uZnVuY3Rpb25NYXRjaCkpIHtcblx0XHRcdFx0XHRwbHVnaW5zVG9Vc2UucHVzaChwbHVnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Ly8gYHNvdXJjZWAgaXMgZnJvbSBvYmplY3QsIGpzb25cblx0XHRcdGlmIChzZXR0aW5ncy5wbHVnaW5OYW1lcykgeyAvL1RPRE86IHBsdWdpbk5hbWVzLCBtYXkgbm90IGV4aXN0IGhlcmVcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcblx0XHRcdFx0XHRjb25zdCB1c2VQbHVnaW4gPSBzZXR0aW5ncy5wbHVnaW5OYW1lcy5zb21lKHBsdWdpbk5hbWUgPT4gcGx1Z2luTmFtZSA9PT0gcGx1Z2luLm5hbWUpO1xuXHRcdFx0XHRcdGlmICh1c2VQbHVnaW4pIHtcblx0XHRcdFx0XHRcdHBsdWdpbnNUb1VzZS5wdXNoKHBsdWdpbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwbHVnaW5zVG9Vc2U7XG5cdH1cblxuXHRpbml0RXh0ZW5zaW9ucygpIHtcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7XG5cdFx0XHRPRVNfdGV4dHVyZV9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcblx0XHRcdE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG5cdFx0XHRPRVNfZWxlbWVudF9pbmRleF91aW50OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG5cdFx0XHRXRUJHTF9kcmF3X2J1ZmZlcnM6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuXHRcdFx0V0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcblx0XHR9O1xuXHR9XG5cblx0dmFsaWRhdGVTZXR0aW5ncygpIHtcblx0XHRpZiAoIXRoaXMudmFsaWRhdGUpIHtcblx0XHRcdHRoaXMudGV4U2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcblx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyxcblx0XHRcdH0sIHRoaXMub3V0cHV0LCB0cnVlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCB7XG5cdFx0XHRmZWF0dXJlc1xuXHRcdH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHRcdGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPT09IHRydWUgJiYgIWZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Zsb2F0IHRleHR1cmVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScgJiYgdGhpcy5mbG9hdE91dHB1dEZvcmNlICE9PSB0cnVlICYmICFmZWF0dXJlcy5pc0Zsb2F0UmVhZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTaW5nbGUgcHJlY2lzaW9uIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHR9IGVsc2UgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiB0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCAmJiBmZWF0dXJlcy5pc1RleHR1cmVGbG9hdCkge1xuXHRcdFx0dGhpcy5wcmVjaXNpb24gPSBmZWF0dXJlcy5pc0Zsb2F0UmVhZCA/ICdzaW5nbGUnIDogJ3Vuc2lnbmVkJztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zdWJLZXJuZWxzICYmIHRoaXMuc3ViS2VybmVscy5sZW5ndGggPiAwICYmICF0aGlzLmV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBpbnN0YW50aWF0ZSBkcmF3IGJ1ZmZlcnMgZXh0ZW5zaW9uJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSAhZmVhdHVyZXMuaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgJiYgZmVhdHVyZXMuaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZSkge1xuXHRcdFx0dGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuY2hlY2tPdXRwdXQoKTtcblxuXHRcdGlmICghdGhpcy5vdXRwdXQgfHwgdGhpcy5vdXRwdXQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG9ubHkgc3VwcG9ydGVkIGZvciBrZXJuZWxzIHdpdGggb25seSBvbmUgaW5wdXQnKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmd1bWVudHNbMF0pO1xuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdBcnJheScpIHtcblx0XHRcdFx0dGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnTnVtYmVyVGV4dHVyZScgfHwgYXJnVHlwZSA9PT0gJ0FycmF5VGV4dHVyZSg0KScpIHtcblx0XHRcdFx0dGhpcy5vdXRwdXQgPSBhcmd1bWVudHNbMF0ub3V0cHV0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG5cdFx0XHRpZiAodGhpcy5vdXRwdXQubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignT3V0cHV0IG11c3QgaGF2ZSAyIGRpbWVuc2lvbnMgb24gZ3JhcGhpY2FsIG1vZGUnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMucHJlY2lzaW9uID09PSAncHJlY2lzaW9uJykge1xuXHRcdFx0XHR0aGlzLnByZWNpc2lvbiA9ICd1bnNpZ25lZCc7XG5cdFx0XHRcdGNvbnNvbGUud2FybignQ2Fubm90IHVzZSBncmFwaGljYWwgbW9kZSBhbmQgc2luZ2xlIHByZWNpc2lvbiBhdCB0aGUgc2FtZSB0aW1lJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGV4U2l6ZSA9IHV0aWxzLmNsb25lKHRoaXMub3V0cHV0KTtcblx0XHRcdHJldHVybjtcblx0XHR9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSBudWxsICYmIGZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG5cdFx0XHR0aGlzLnByZWNpc2lvbiA9ICdzaW5nbGUnO1xuXHRcdH1cblxuXHRcdHRoaXMudGV4U2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRmbG9hdFRleHR1cmVzOiB0aGlzLmZsb2F0VGV4dHVyZXMsXG5cdFx0XHRmbG9hdE91dHB1dDogdGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnXG5cdFx0fSwgdGhpcy5vdXRwdXQsIHRydWUpO1xuXHR9XG5cblx0dXBkYXRlTWF4VGV4U2l6ZSgpIHtcblx0XHRjb25zdCB7XG5cdFx0XHR0ZXhTaXplLFxuXHRcdFx0Y2FudmFzXG5cdFx0fSA9IHRoaXM7XG5cdFx0aWYgKHRoaXMubWF4VGV4U2l6ZSA9PT0gbnVsbCkge1xuXHRcdFx0bGV0IGNhbnZhc0luZGV4ID0gY2FudmFzZXMuaW5kZXhPZihjYW52YXMpO1xuXHRcdFx0aWYgKGNhbnZhc0luZGV4ID09PSAtMSkge1xuXHRcdFx0XHRjYW52YXNJbmRleCA9IGNhbnZhc2VzLmxlbmd0aDtcblx0XHRcdFx0Y2FudmFzZXMucHVzaChjYW52YXMpO1xuXHRcdFx0XHRtYXhUZXhTaXplc1tjYW52YXNJbmRleF0gPSBbdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXV07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm1heFRleFNpemUgPSBtYXhUZXhTaXplc1tjYW52YXNJbmRleF07XG5cdFx0fVxuXHRcdGlmICh0aGlzLm1heFRleFNpemVbMF0gPCB0ZXhTaXplWzBdKSB7XG5cdFx0XHR0aGlzLm1heFRleFNpemVbMF0gPSB0ZXhTaXplWzBdO1xuXHRcdH1cblx0XHRpZiAodGhpcy5tYXhUZXhTaXplWzFdIDwgdGV4U2l6ZVsxXSkge1xuXHRcdFx0dGhpcy5tYXhUZXhTaXplWzFdID0gdGV4U2l6ZVsxXTtcblx0XHR9XG5cdH1cblxuXHQvLyBUT0RPOiBtb3ZlIGNoYW5uZWwgY2hlY2tzIHRvIG5ldyBwbGFjZVxuXHRfb2xkdHJhbnNsYXRlU291cmNlKCkge1xuXHRcdGNvbnN0IGZ1bmN0aW9uQnVpbGRlciA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMRnVuY3Rpb25Ob2RlLCB7XG5cdFx0XHRmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuXHRcdH0pO1xuXG5cdFx0Ly8gbmVlZCB0aGlzIGxpbmUgdG8gYXV0b21hdGljYWxseSBnZXQgcmV0dXJuVHlwZVxuXHRcdGNvbnN0IHRyYW5zbGF0ZWRTb3VyY2UgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlU3RyaW5nKCdrZXJuZWwnKTtcblxuXHRcdGlmICghdGhpcy5yZXR1cm5UeXBlKSB7XG5cdFx0XHR0aGlzLnJldHVyblR5cGUgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0S2VybmVsUmVzdWx0VHlwZSgpO1xuXHRcdH1cblxuXHRcdGxldCByZXF1aXJlZENoYW5uZWxzID0gMDtcblx0XHRjb25zdCByZXR1cm5UeXBlcyA9IGZ1bmN0aW9uQnVpbGRlci5nZXRSZXR1cm5UeXBlcygpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmV0dXJuVHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHN3aXRjaCAocmV0dXJuVHlwZXNbaV0pIHtcblx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0XHRyZXF1aXJlZENoYW5uZWxzKys7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdFx0XHRyZXF1aXJlZENoYW5uZWxzICs9IDI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0FycmF5KDMpJzpcblx0XHRcdFx0XHRyZXF1aXJlZENoYW5uZWxzICs9IDM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0FycmF5KDQpJzpcblx0XHRcdFx0XHRyZXF1aXJlZENoYW5uZWxzICs9IDQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGZlYXR1cmVzICYmIHJlcXVpcmVkQ2hhbm5lbHMgPiBmZWF0dXJlcy5jaGFubmVsQ291bnQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgY2hhbm5lbHMhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IHRyYW5zbGF0ZWRTb3VyY2U7XG5cdH1cblxuXHRidWlsZCgpIHtcblx0XHR0aGlzLmluaXRFeHRlbnNpb25zKCk7XG5cdFx0dGhpcy52YWxpZGF0ZVNldHRpbmdzKCk7XG5cdFx0dGhpcy5zZXR1cENvbnN0YW50cygpO1xuXHRcdHRoaXMuc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcblx0XHR0aGlzLnVwZGF0ZU1heFRleFNpemUoKTtcblx0XHR0aGlzLnRyYW5zbGF0ZVNvdXJjZSgpO1xuXHRcdHRoaXMucGlja1JlbmRlclN0cmF0ZWd5KCk7XG5cdFx0Y29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcblx0XHRjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcblx0XHRjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcblx0XHRnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcblx0XHRpZiAodGhpcy5waXBlbGluZSAmJiB0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMubWF4VGV4U2l6ZVswXSwgdGhpcy5tYXhUZXhTaXplWzFdKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHRoaXMubWF4VGV4U2l6ZVswXTtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSB0aGlzLm1heFRleFNpemVbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMubWF4VGV4U2l6ZVswXSwgdGhpcy5tYXhUZXhTaXplWzFdKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHRoaXMubWF4VGV4U2l6ZVswXTtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSB0aGlzLm1heFRleFNpemVbMV07XG5cdFx0fVxuXHRcdGNvbnN0IHRocmVhZERpbSA9IHRoaXMudGhyZWFkRGltID0gQXJyYXkuZnJvbSh0aGlzLm91dHB1dCk7XG5cdFx0d2hpbGUgKHRocmVhZERpbS5sZW5ndGggPCAzKSB7XG5cdFx0XHR0aHJlYWREaW0ucHVzaCgxKTtcblx0XHR9XG5cblx0XHRjb25zdCBjb21waWxlZFZlcnRleFNoYWRlciA9IHRoaXMuZ2V0VmVydGV4U2hhZGVyKGFyZ3VtZW50cyk7XG5cdFx0Y29uc3QgdmVydFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcblx0XHRnbC5zaGFkZXJTb3VyY2UodmVydFNoYWRlciwgY29tcGlsZWRWZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIodmVydFNoYWRlcik7XG5cdFx0dGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcblxuXHRcdGNvbnN0IGNvbXBpbGVkRnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdldEZyYWdtZW50U2hhZGVyKGFyZ3VtZW50cyk7XG5cdFx0Y29uc3QgZnJhZ1NoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuXHRcdGdsLnNoYWRlclNvdXJjZShmcmFnU2hhZGVyLCBjb21waWxlZEZyYWdtZW50U2hhZGVyKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKGZyYWdTaGFkZXIpO1xuXHRcdHRoaXMuZnJhZ1NoYWRlciA9IGZyYWdTaGFkZXI7XG5cblx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0Y29uc29sZS5sb2coJ0dMU0wgU2hhZGVyIE91dHB1dDonKTtcblx0XHRcdGNvbnNvbGUubG9nKGNvbXBpbGVkRnJhZ21lbnRTaGFkZXIpO1xuXHRcdH1cblxuXHRcdGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciBjb21waWxpbmcgdmVydGV4IHNoYWRlcjogJyArIGdsLmdldFNoYWRlckluZm9Mb2codmVydFNoYWRlcikpO1xuXHRcdH1cblx0XHRpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnU2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY29tcGlsaW5nIGZyYWdtZW50IHNoYWRlcjogJyArIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ1NoYWRlcikpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnU2hhZGVyKTtcblx0XHRnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblx0XHR0aGlzLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHR0aGlzLmZyYW1lYnVmZmVyLndpZHRoID0gdGV4U2l6ZVswXTtcblx0XHR0aGlzLmZyYW1lYnVmZmVyLmhlaWdodCA9IHRleFNpemVbMV07XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSxcblx0XHRcdDEsIC0xLCAtMSwgMSxcblx0XHRcdDEsIDFcblx0XHRdKTtcblx0XHRjb25zdCB0ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdDAsIDAsXG5cdFx0XHQxLCAwLFxuXHRcdFx0MCwgMSxcblx0XHRcdDEsIDFcblx0XHRdKTtcblxuXHRcdGNvbnN0IHRleENvb3JkT2Zmc2V0ID0gdmVydGljZXMuYnl0ZUxlbmd0aDtcblxuXHRcdGxldCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcblx0XHRpZiAoIWJ1ZmZlcikge1xuXHRcdFx0YnVmZmVyID0gdGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLmJ5dGVMZW5ndGggKyB0ZXhDb29yZHMuYnl0ZUxlbmd0aCwgZ2wuU1RBVElDX0RSQVcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHR9XG5cblx0XHRnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGljZXMpO1xuXHRcdGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhDb29yZE9mZnNldCwgdGV4Q29vcmRzKTtcblxuXHRcdGNvbnN0IGFQb3NMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdhUG9zJyk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVBvc0xvYyk7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhUG9zTG9jLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdGNvbnN0IGFUZXhDb29yZExvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2FUZXhDb29yZCcpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFUZXhDb29yZExvYyk7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhVGV4Q29vcmRMb2MsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgdGV4Q29vcmRPZmZzZXQpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG5cblx0XHRmb3IgKGxldCBwIGluIHRoaXMuY29uc3RhbnRzKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuY29uc3RhbnRzW3BdO1xuXHRcdFx0Y29uc3QgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSk7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ0Zsb2F0JyB8fCB0eXBlID09PSAnSW50ZWdlcicgfHwgdHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Z2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXHRcdFx0dGhpcy5hZGRDb25zdGFudCh0aGlzLmNvbnN0YW50c1twXSwgdHlwZSwgcCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmltbXV0YWJsZSkge1xuXHRcdFx0dGhpcy5fc2V0dXBPdXRwdXRUZXh0dXJlKCk7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCAmJlxuXHRcdFx0XHR0aGlzLnN1Yktlcm5lbHMubGVuZ3RoID4gMFxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXModGhpcy5zdWJLZXJuZWxzLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dHJhbnNsYXRlU291cmNlKCkge1xuXHRcdGNvbnN0IGZ1bmN0aW9uQnVpbGRlciA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMRnVuY3Rpb25Ob2RlLCB7XG5cdFx0XHRmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuXHRcdH0pO1xuXHRcdHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRQcm90b3R5cGVTdHJpbmcoJ2tlcm5lbCcpO1xuXHRcdGlmICghdGhpcy5ncmFwaGljYWwgJiYgIXRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0dGhpcy5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldEtlcm5lbFJlc3VsdFR5cGUoKTtcblx0XHR9XG5cdH1cblxuXHRydW4oKSB7XG5cdFx0aWYgKHRoaXMucHJvZ3JhbSA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5idWlsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0XHRjb25zdCBhcmd1bWVudE5hbWVzID0gdGhpcy5hcmd1bWVudE5hbWVzO1xuXHRcdGNvbnN0IGFyZ3VtZW50VHlwZXMgPSB0aGlzLmFyZ3VtZW50VHlwZXM7XG5cdFx0Y29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcblx0XHRjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcblxuXHRcdGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0XHRnbC5zY2lzc29yKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ3VPdXRwdXREaW0nLCB0aGlzLnRocmVhZERpbSk7XG5cdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ3VUZXhTaXplJywgdGV4U2l6ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRVbmlmb3JtMmYoJ3JhdGlvJywgdGV4U2l6ZVswXSAvIHRoaXMubWF4VGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSAvIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG5cblx0XHR0aGlzLmFyZ3VtZW50c0xlbmd0aCA9IDA7XG5cdFx0Zm9yIChsZXQgdGV4SW5kZXggPSAwOyB0ZXhJbmRleCA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyB0ZXhJbmRleCsrKSB7XG5cdFx0XHR0aGlzLmFkZEFyZ3VtZW50KGFyZ3VtZW50c1t0ZXhJbmRleF0sIGFyZ3VtZW50VHlwZXNbdGV4SW5kZXhdLCBhcmd1bWVudE5hbWVzW3RleEluZGV4XSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucGx1Z2lucykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ldO1xuXHRcdFx0XHRpZiAocGx1Z2luLm9uQmVmb3JlUnVuKSB7XG5cdFx0XHRcdFx0cGx1Z2luLm9uQmVmb3JlUnVuKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG5cdFx0XHRpZiAodGhpcy5waXBlbGluZSkge1xuXHRcdFx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cdFx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdGlmICghdGhpcy5vdXRwdXRUZXh0dXJlIHx8IHRoaXMuaW1tdXRhYmxlKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0dXBPdXRwdXRUZXh0dXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdFx0XHRcdHJldHVybiBuZXcgVGV4dHVyZSh7XG5cdFx0XHRcdFx0dGV4dHVyZTogdGhpcy5vdXRwdXRUZXh0dXJlLFxuXHRcdFx0XHRcdHNpemU6IHRleFNpemUsXG5cdFx0XHRcdFx0ZGltZW5zaW9uczogdGhpcy50aHJlYWREaW0sXG5cdFx0XHRcdFx0b3V0cHV0OiB0aGlzLm91dHB1dCxcblx0XHRcdFx0XHRjb250ZXh0OiB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdFx0Z3B1OiB0aGlzLmdwdSxcblx0XHRcdFx0XHR0eXBlOiB0aGlzLmdldFJldHVyblRleHR1cmVUeXBlKCksXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0XHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG5cdFx0aWYgKHRoaXMuaW1tdXRhYmxlKSB7XG5cdFx0XHR0aGlzLl9zZXR1cE91dHB1dFRleHR1cmUoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG5cdFx0XHRpZiAodGhpcy5pbW11dGFibGUpIHtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLl9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKHRoaXMuc3ViS2VybmVscy5sZW5ndGgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycy5kcmF3QnVmZmVyc1dFQkdMKHRoaXMuZHJhd0J1ZmZlcnNNYXApO1xuXHRcdH1cblxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXG5cdFx0aWYgKHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMgIT09IG51bGwpIHtcblx0XHRcdGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcblx0XHRcdFx0Y29uc3Qgb3V0cHV0ID0ge1xuXHRcdFx0XHRcdHJlc3VsdDogdGhpcy5yZW5kZXJPdXRwdXQoKSxcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKHRoaXMucGlwZWxpbmUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0b3V0cHV0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSBuZXcgVGV4dHVyZSh7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmU6IHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXNbaV0sXG5cdFx0XHRcdFx0XHRcdHNpemU6IHRleFNpemUsXG5cdFx0XHRcdFx0XHRcdGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuXHRcdFx0XHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0XHRcdFx0XHRjb250ZXh0OiB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdGdwdTogdGhpcy5ncHUsXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHRoaXMuZ2V0UmV0dXJuVGV4dHVyZVR5cGUoKSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0b3V0cHV0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSBuZXcgVGV4dHVyZSh7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmU6IHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXNbaV0sXG5cdFx0XHRcdFx0XHRcdHNpemU6IHRleFNpemUsXG5cdFx0XHRcdFx0XHRcdGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuXHRcdFx0XHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0XHRcdFx0XHRjb250ZXh0OiB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdGdwdTogdGhpcy5ncHUsXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHRoaXMuZ2V0UmV0dXJuVGV4dHVyZVR5cGUoKSxcblx0XHRcdFx0XHRcdH0pLnRvQXJyYXkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJPdXRwdXQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHdlYkdsIGZ1bmN0aW9uJ3Mgb3V0cHV0LlxuXHQgKiBTaW5jZSB0aGUgcHJvZ3JhbSBydW5zIG9uIEdQVSwgd2UgbmVlZCB0byBnZXQgdGhlXG5cdCAqIG91dHB1dCBvZiB0aGUgcHJvZ3JhbSBiYWNrIHRvIENQVSBhbmQgdGhlbiByZXR1cm4gdGhlbS5cblx0ICogKk5vdGUqOiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fSByZXN1bHRcblx0ICovXG5cdC8vIHJlbmRlck91dHB1dCgpIHtcblx0Ly8gXHRjb25zdCB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuXHQvLyBcdGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuXHQvLyBcdGNvbnN0IHRocmVhZERpbSA9IHRoaXMudGhyZWFkRGltO1xuXHQvLyBcdGNvbnN0IG91dHB1dCA9IHRoaXMub3V0cHV0O1xuXHQvLyBcdGlmICh0aGlzLnBpcGVsaW5lKSB7XG5cdC8vIFx0XHRyZXR1cm4gbmV3IFRleHR1cmUoe1xuXHQvLyBcdFx0XHR0ZXh0dXJlOiB0aGlzLm91dHB1dFRleHR1cmUsXG5cdC8vIFx0XHRcdHNpemU6IHRleFNpemUsXG5cdC8vIFx0XHRcdGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuXHQvLyBcdFx0XHRvdXRwdXQsXG5cdC8vIFx0XHRcdGNvbnRleHQ6IHRoaXMuY29udGV4dCxcblx0Ly8gXHRcdFx0Z3B1OiB0aGlzLmdwdSxcblx0Ly8gXHRcdFx0dHlwZTogdGhpcy5nZXRSZXR1cm5UZXh0dXJlVHlwZSgpLFxuXHQvLyBcdFx0fSk7XG5cdC8vIFx0fSBlbHNlIHtcblx0Ly8gXHRcdGxldCByZXN1bHQ7XG5cdC8vIFx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdC8vIFx0XHRcdGNvbnN0IHcgPSB0ZXhTaXplWzBdO1xuXHQvLyBcdFx0XHRjb25zdCBoID0gTWF0aC5jZWlsKHRleFNpemVbMV0gLyA0KTtcblx0Ly8gXHRcdFx0cmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh3ICogaCAqIDQpO1xuXHQvLyBcdFx0XHRnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdsLkZMT0FULCByZXN1bHQpO1xuXHQvLyBcdFx0fSBlbHNlIHtcblx0Ly8gXHRcdFx0Y29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuXHQvLyBcdFx0XHRnbC5yZWFkUGl4ZWxzKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJ5dGVzKTtcblx0Ly8gXHRcdFx0cmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShieXRlcy5idWZmZXIpO1xuXHQvLyBcdFx0fVxuXHQvLyBcdFx0cmVzdWx0ID0gcmVzdWx0LnN1YmFycmF5KDAsIHRocmVhZERpbVswXSAqIHRocmVhZERpbVsxXSAqIHRocmVhZERpbVsyXSk7XG5cdC8vXG5cdC8vIFx0XHRpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMSkge1xuXHQvLyBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHQvLyBcdFx0fSBlbHNlIGlmIChvdXRwdXQubGVuZ3RoID09PSAyKSB7XG5cdC8vIFx0XHRcdHJldHVybiB1dGlscy5zcGxpdEFycmF5KHJlc3VsdCwgb3V0cHV0WzBdKTtcblx0Ly8gXHRcdH0gZWxzZSBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuXHQvLyBcdFx0XHRjb25zdCBjdWJlID0gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIG91dHB1dFswXSAqIG91dHB1dFsxXSk7XG5cdC8vIFx0XHRcdHJldHVybiBjdWJlLm1hcChmdW5jdGlvbih4KSB7XG5cdC8vIFx0XHRcdFx0cmV0dXJuIHV0aWxzLnNwbGl0QXJyYXkoeCwgb3V0cHV0WzBdKTtcblx0Ly8gXHRcdFx0fSk7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fVxuXHQvLyB9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFRoaXMgcmV0dXJuIGRlZmluZWQgb3V0cHV0VGV4dHVyZSwgd2hpY2ggaXMgc2V0dXAgaW4gLmJ1aWxkKCksIG9yIGlmIGltbXV0YWJsZSwgaXMgZGVmaW5lZCBpbiAucnVuKClcblx0ICogQHJldHVybnMge09iamVjdH0gT3V0cHV0IFRleHR1cmUgQ2FjaGVcblx0ICovXG5cdGdldE91dHB1dFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3V0cHV0VGV4dHVyZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBTZXR1cCBhbmQgcmVwbGFjZSBvdXRwdXQgdGV4dHVyZVxuXHQgKi9cblx0X3NldHVwT3V0cHV0VGV4dHVyZSgpIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcblx0XHRjb25zdCB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLm91dHB1dFRleHR1cmUgPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGgpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0Ly8gaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuXHRcdC8vIFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0Ly8gfSBlbHNlIHtcblx0XHQvLyBcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0Ly8gfVxuXHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdGlmICh0aGlzLnBpcGVsaW5lKSB7XG5cdFx0XHRcdC8vIFRPRE86IGludmVzdGlnYXRlIGlmIHdlYmdsMSBjYW4gaGFuZGxlIGdsLlJFRCB1c2FnZSBpbiBnbC50ZXhJbWFnZTJELCBvdGhlcndpc2UsIHNpbXBsaWZ5IHRoZSBiZWxvd1xuXHRcdFx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuXHRcdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXkoMiknOlxuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdBcnJheSgzKSc6XG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0FycmF5KDQpJzpcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGlmICghdGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgcmV0dXJuIHR5cGUnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0fVxuXHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgU2V0dXAgYW5kIHJlcGxhY2Ugc3ViLW91dHB1dCB0ZXh0dXJlc1xuXHQgKi9cblx0X3NldHVwU3ViT3V0cHV0VGV4dHVyZXMobGVuZ3RoKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG5cdFx0Y29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcblx0XHRjb25zdCBkcmF3QnVmZmVyc01hcCA9IHRoaXMuZHJhd0J1ZmZlcnNNYXAgPSBbZ2wuQ09MT1JfQVRUQUNITUVOVDBdO1xuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0dGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcblx0XHRcdGRyYXdCdWZmZXJzTWFwLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSk7XG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoICsgaSk7XG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblx0XHRcdH1cblx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgVGhpcyB1c2VzICpnZXRUZXh0dXJlQ2FjaGUqKiB0byBnZXQgdGhlIFRleHR1cmUgQ2FjaGUgb2YgdGhlIGFyZ3VtZW50IHN1cHBsaWVkXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYXJndW1lbnRcblx0ICovXG5cdGdldEFyZ3VtZW50VGV4dHVyZShuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGV4dHVyZUNhY2hlKGBBUkdVTUVOVF8ke25hbWV9YCk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUmV0dXJucyB0aGUgVGV4dHVyZSBDYWNoZSBvZiB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIChjYW4gYmUga2VybmVsLCBzdWIta2VybmVsIG9yIGFyZ3VtZW50KVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHN1Ymtlcm5lbCwgYXJndW1lbnQsIG9yIGtlcm5lbC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGV4dHVyZSBjYWNoZVxuXHQgKi9cblx0Z2V0VGV4dHVyZUNhY2hlKG5hbWUpIHtcblx0XHRpZiAodGhpcy50ZXh0dXJlQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVtuYW1lXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW25hbWVdID0gdGhpcy5jb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyByZW1vdmVzIGEgdGV4dHVyZSBmcm9tIHRoZSBrZXJuZWwncyBjYWNoZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGV4dHVyZVxuXHQgKi9cblx0ZGV0YWNoVGV4dHVyZUNhY2hlKG5hbWUpIHtcblx0XHRkZWxldGUgdGhpcy50ZXh0dXJlQ2FjaGVbbmFtZV07XG5cdH1cblxuXHRzZXRVbmlmb3JtMWYobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodGhpcy51bmlmb3JtMWZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0xZkNhY2hlW25hbWVdO1xuXHRcdFx0aWYgKHZhbHVlID09PSBjYWNoZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMudW5pZm9ybTFmQ2FjaGVbbmFtZV0gPSB2YWx1ZTtcblx0XHRjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcblx0XHR0aGlzLmNvbnRleHQudW5pZm9ybTFmKGxvYywgdmFsdWUpO1xuXHR9XG5cblx0c2V0VW5pZm9ybTFpKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMudW5pZm9ybTFpQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMWlDYWNoZVtuYW1lXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gY2FjaGUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnVuaWZvcm0xaUNhY2hlW25hbWVdID0gdmFsdWU7XG5cdFx0Y29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG5cdFx0dGhpcy5jb250ZXh0LnVuaWZvcm0xaShsb2MsIHZhbHVlKTtcblx0fVxuXG5cdHNldFVuaWZvcm0yZihuYW1lLCB2YWx1ZTEsIHZhbHVlMikge1xuXHRcdGlmICh0aGlzLnVuaWZvcm0yZkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTJmQ2FjaGVbbmFtZV07XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHZhbHVlMSA9PT0gY2FjaGVbMF0gJiZcblx0XHRcdFx0dmFsdWUyID09PSBjYWNoZVsxXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy51bmlmb3JtMmZDYWNoZVtuYW1lXSA9IFt2YWx1ZTEsIHZhbHVlMl07XG5cdFx0Y29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG5cdFx0dGhpcy5jb250ZXh0LnVuaWZvcm0yZihsb2MsIHZhbHVlMSwgdmFsdWUyKTtcblx0fVxuXG5cdHNldFVuaWZvcm0yZnYobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodGhpcy51bmlmb3JtMmZ2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMmZ2Q2FjaGVbbmFtZV07XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuXHRcdFx0XHR2YWx1ZVsxXSA9PT0gY2FjaGVbMV1cblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMudW5pZm9ybTJmdkNhY2hlW25hbWVdID0gdmFsdWU7XG5cdFx0Y29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG5cdFx0dGhpcy5jb250ZXh0LnVuaWZvcm0yZnYobG9jLCB2YWx1ZSk7XG5cdH1cblxuXHRzZXRVbmlmb3JtMml2KG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMudW5pZm9ybTJpdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTJpdkNhY2hlW25hbWVdO1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcblx0XHRcdFx0dmFsdWVbMV0gPT09IGNhY2hlWzFdXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnVuaWZvcm0yaXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuXHRcdGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuXHRcdHRoaXMuY29udGV4dC51bmlmb3JtMml2KGxvYywgdmFsdWUpO1xuXHR9XG5cblx0c2V0VW5pZm9ybTNmdihuYW1lLCB2YWx1ZSkge1xuXHRcdGlmICh0aGlzLnVuaWZvcm0zZnZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0zZnZDYWNoZVtuYW1lXTtcblx0XHRcdGlmIChcblx0XHRcdFx0dmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG5cdFx0XHRcdHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuXHRcdFx0XHR2YWx1ZVsyXSA9PT0gY2FjaGVbMl1cblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMudW5pZm9ybTNmdkNhY2hlW25hbWVdID0gdmFsdWU7XG5cdFx0Y29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG5cdFx0dGhpcy5jb250ZXh0LnVuaWZvcm0zZnYobG9jLCB2YWx1ZSk7XG5cdH1cblxuXHRzZXRVbmlmb3JtM2l2KG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMudW5pZm9ybTNpdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTNpdkNhY2hlW25hbWVdO1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcblx0XHRcdFx0dmFsdWVbMV0gPT09IGNhY2hlWzFdICYmXG5cdFx0XHRcdHZhbHVlWzJdID09PSBjYWNoZVsyXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy51bmlmb3JtM2l2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcblx0XHRjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcblx0XHR0aGlzLmNvbnRleHQudW5pZm9ybTNpdihsb2MsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBSZXR1cm4gV2ViR2xVbmlmb3JtTG9jYXRpb24gZm9yIHZhcmlvdXMgdmFyaWFibGVzXG5cdCAqIHJlbGF0ZWQgdG8gd2ViR2wgcHJvZ3JhbSwgc3VjaCBhcyB1c2VyLWRlZmluZWQgdmFyaWFibGVzLFxuXHQgKiBhcyB3ZWxsIGFzLCBkaW1lbnNpb24gc2l6ZXMsIGV0Yy5cblx0ICovXG5cdGdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKSB7XG5cdFx0aWYgKHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGVbbmFtZV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZVtuYW1lXSA9IHRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBHZW5lcmF0ZSBTaGFkZXIgYXJ0aWZhY3RzIGZvciB0aGUga2VybmVsIHByb2dyYW0uXG5cdCAqIFRoZSBmaW5hbCBvYmplY3QgY29udGFpbnMgSEVBREVSLCBLRVJORUwsIE1BSU5fUkVTVUxULCBhbmQgb3RoZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gVGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgU2hhZGVyIEFydGlmYWN0cyhDT05TVEFOVFMsIEhFQURFUiwgS0VSTkVMLCBldGMuKVxuXHQgKi9cblx0X2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdEhFQURFUjogdGhpcy5fZ2V0SGVhZGVyU3RyaW5nKCksXG5cdFx0XHRMT09QX01BWDogdGhpcy5fZ2V0TG9vcE1heFN0cmluZygpLFxuXHRcdFx0UExVR0lOUzogdGhpcy5fZ2V0UGx1Z2luc1N0cmluZygpLFxuXHRcdFx0Q09OU1RBTlRTOiB0aGlzLl9nZXRDb25zdGFudHNTdHJpbmcoKSxcblx0XHRcdERFQ09ERTMyX0VORElBTk5FU1M6IHRoaXMuX2dldERlY29kZTMyRW5kaWFubmVzc1N0cmluZygpLFxuXHRcdFx0RU5DT0RFMzJfRU5ESUFOTkVTUzogdGhpcy5fZ2V0RW5jb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCksXG5cdFx0XHRESVZJREVfV0lUSF9JTlRFR0VSX0NIRUNLOiB0aGlzLl9nZXREaXZpZGVXaXRoSW50ZWdlckNoZWNrU3RyaW5nKCksXG5cdFx0XHRNQUlOX0NPTlNUQU5UUzogdGhpcy5fZ2V0TWFpbkNvbnN0YW50c1N0cmluZygpLFxuXHRcdFx0TUFJTl9BUkdVTUVOVFM6IHRoaXMuX2dldE1haW5Bcmd1bWVudHNTdHJpbmcoYXJncyksXG5cdFx0XHRLRVJORUw6IHRoaXMuZ2V0S2VybmVsU3RyaW5nKCksXG5cdFx0XHRNQUlOX1JFU1VMVDogdGhpcy5nZXRNYWluUmVzdWx0U3RyaW5nKClcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEFkZHMga2VybmVsIHBhcmFtZXRlcnMgdG8gdGhlIEFyZ3VtZW50IFRleHR1cmUsXG5cdCAqIGJpbmRpbmcgaXQgdG8gdGhlIHdlYkdsIGluc3RhbmNlLCBldGMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl8VGV4dHVyZXxOdW1iZXJ9IHZhbHVlIC0gVGhlIGFjdHVhbCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUga2VybmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgYXJndW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhcmd1bWVudFxuXHQgKi9cblx0YWRkQXJndW1lbnQodmFsdWUsIHR5cGUsIG5hbWUpIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcblx0XHRjb25zdCBhcmd1bWVudFRleHR1cmUgPSB0aGlzLmdldEFyZ3VtZW50VGV4dHVyZShuYW1lKTtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG5cdFx0XHR0eXBlID0gdmFsdWUudHlwZTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdGNhc2UgJ0FycmF5KDMpJzpcblx0XHRcdGNhc2UgJ0FycmF5KDQpJzpcblx0XHRcdGNhc2UgJ0FycmF5MkQnOlxuXHRcdFx0Y2FzZSAnQXJyYXkzRCc6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBkaW0gPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcblx0XHRcdFx0XHRjb25zdCBiaXRSYXRpbyA9IHRoaXMuYXJndW1lbnRCaXRSYXRpb3NbdGhpcy5hcmd1bWVudHNMZW5ndGhdO1xuXHRcdFx0XHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZShkaW0sIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gdGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSAqIGJpdFJhdGlvO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVzRmxhdCA9IHRoaXMuZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZSwgbGVuZ3RoLCBGbG9hdDMyQXJyYXkpO1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXh0dXJlU2l6ZVswXSwgdGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB2YWx1ZXNGbGF0KTtcblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdihgdXNlcl8ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGB1c2VyXyR7bmFtZX1TaXplYCwgdGV4dHVyZVNpemUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYHVzZXJfJHtuYW1lfWAsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZShkaW0sIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsZW5ndGggPSB0ZXh0dXJlU2l6ZVswXSAqIHRleHR1cmVTaXplWzFdICogKDQgLyBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gdGhpcy5mb3JtYXRBcnJheVRyYW5zZmVyKHZhbHVlLCBsZW5ndGgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzRmxhdC5idWZmZXIpO1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXh0dXJlU2l6ZVswXSwgdGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYHVzZXJfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgdXNlcl8ke25hbWV9U2l6ZWAsIHRleHR1cmVTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYHVzZXJfJHtuYW1lfWAsIHZhbHVlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFmKGB1c2VyXyR7bmFtZX1gLCB2YWx1ZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0ID0gdmFsdWU7XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gdXRpbHMuZ2V0RGltZW5zaW9ucyhpbnB1dCwgdHJ1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgYml0UmF0aW8gPSB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zW3RoaXMuYXJndW1lbnRzTGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUoZGltLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlbmd0aCA9IHRleHR1cmVTaXplWzBdICogdGV4dHVyZVNpemVbMV0gKiBiaXRSYXRpbztcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlc0ZsYXQgPSB0aGlzLmZvcm1hdEFycmF5VHJhbnNmZXIoaW5wdXQudmFsdWUsIGxlbmd0aCwgRmxvYXQzMkFycmF5KTtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4dHVyZVNpemVbMF0sIHRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdmFsdWVzRmxhdCk7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYHVzZXJfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgdXNlcl8ke25hbWV9U2l6ZWAsIHRleHR1cmVTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUoZGltLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gdGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSAqICg0IC8gYml0UmF0aW8pO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVzRmxhdCA9IHRoaXMuZm9ybWF0QXJyYXlUcmFuc2ZlcihpbnB1dC52YWx1ZSwgbGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlc0ZsYXQuYnVmZmVyKTtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4dHVyZVNpemVbMF0sIHRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBidWZmZXIpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGB1c2VyXyR7bmFtZX1EaW1gLCBkaW0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYHVzZXJfJHtuYW1lfVNpemVgLCB0ZXh0dXJlU2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgdXNlcl8ke25hbWV9YCwgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnSFRNTEltYWdlJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0SW1hZ2UgPSB2YWx1ZTtcblx0XHRcdFx0XHRjb25zdCBkaW0gPSBbaW5wdXRJbWFnZS53aWR0aCwgaW5wdXRJbWFnZS5oZWlnaHQsIDFdO1xuXHRcdFx0XHRcdGNvbnN0IHNpemUgPSBbaW5wdXRJbWFnZS53aWR0aCwgaW5wdXRJbWFnZS5oZWlnaHRdO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblx0XHRcdFx0XHQvLyBVcGxvYWQgdGhlIGltYWdlIGludG8gdGhlIHRleHR1cmUuXG5cdFx0XHRcdFx0Y29uc3QgbWlwTGV2ZWwgPSAwOyAvLyB0aGUgbGFyZ2VzdCBtaXBcblx0XHRcdFx0XHRjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7IC8vIGZvcm1hdCB3ZSB3YW50IGluIHRoZSB0ZXh0dXJlXG5cdFx0XHRcdFx0Y29uc3Qgc3JjRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdGNvbnN0IHNyY1R5cGUgPSBnbC5VTlNJR05FRF9CWVRFOyAvLyB0eXBlIG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0XHRcdG1pcExldmVsLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQsXG5cdFx0XHRcdFx0XHRzcmNGb3JtYXQsXG5cdFx0XHRcdFx0XHRzcmNUeXBlLFxuXHRcdFx0XHRcdFx0aW5wdXRJbWFnZSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGB1c2VyXyR7bmFtZX1EaW1gLCBkaW0pO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgdXNlcl8ke25hbWV9U2l6ZWAsIHNpemUpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG5cdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMiknOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBpbnB1dFRleHR1cmUgPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoaW5wdXRUZXh0dXJlLmNvbnRleHQgIT09IHRoaXMuY29udGV4dCkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudCAkeyBuYW1lfSAoJHsgdHlwZSB9KSBtdXN0IGJlIGZyb20gc2FtZSBjb250ZXh0YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IGRpbSA9IGlucHV0VGV4dHVyZS5kaW1lbnNpb25zO1xuXHRcdFx0XHRcdGNvbnN0IHNpemUgPSBpbnB1dFRleHR1cmUuc2l6ZTtcblxuXHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYHVzZXJfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGB1c2VyXyR7bmFtZX1TaXplYCwgc2l6ZSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYHVzZXJfJHtuYW1lfWAsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0VGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50ICR7IG5hbWV9ICgkeyB0eXBlIH0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdihgdXNlcl8ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYHVzZXJfJHtuYW1lfVNpemVgLCBzaXplKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgdXNlcl8ke25hbWV9YCwgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB2YWx1ZSA/IDEgOiAwKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICcgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHRoaXMuYXJndW1lbnRzTGVuZ3RoKys7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgQWRkcyBrZXJuZWwgcGFyYW1ldGVycyB0byB0aGUgQXJndW1lbnQgVGV4dHVyZSxcblx0ICogYmluZGluZyBpdCB0byB0aGUgY29udGV4dCwgZXRjLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fFRleHR1cmV8TnVtYmVyfSB2YWx1ZSAtIFRoZSBhY3R1YWwgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIGtlcm5lbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFR5cGUgb2YgdGhlIGFyZ3VtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYXJndW1lbnRcblx0ICovXG5cdGFkZENvbnN0YW50KHZhbHVlLCB0eXBlLCBuYW1lKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG5cdFx0Y29uc3QgY29uc3RhbnRUZXh0dXJlID0gdGhpcy5nZXRBcmd1bWVudFRleHR1cmUobmFtZSk7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuXHRcdFx0dHlwZSA9IHZhbHVlLnR5cGU7XG5cdFx0fVxuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoMiknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0Y2FzZSAnQXJyYXkyRCc6XG5cdFx0XHRjYXNlICdBcnJheTNEJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRpbSA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuXHRcdFx0XHRcdGNvbnN0IGJpdFJhdGlvID0gdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXTtcblx0XHRcdFx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUoZGltLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY29uc3RhbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRjb25zdCBsZW5ndGggPSB0ZXh0dXJlU2l6ZVswXSAqIHRleHR1cmVTaXplWzFdICogYml0UmF0aW87XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gdGhpcy5mb3JtYXRBcnJheVRyYW5zZmVyKHZhbHVlLCBsZW5ndGgsIEZsb2F0MzJBcnJheSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleHR1cmVTaXplWzBdLCB0ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHZhbHVlc0ZsYXQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGBjb25zdGFudHNfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgY29uc3RhbnRzXyR7bmFtZX1TaXplYCwgdGV4dHVyZVNpemUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYGNvbnN0YW50c18ke25hbWV9YCwgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKGRpbSwgYml0UmF0aW8pO1xuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNvbnN0YW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsZW5ndGggPSB0ZXh0dXJlU2l6ZVswXSAqIHRleHR1cmVTaXplWzFdICogKDQgLyBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gdGhpcy5mb3JtYXRBcnJheVRyYW5zZmVyKHZhbHVlLCBsZW5ndGgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzRmxhdC5idWZmZXIpO1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXh0dXJlU2l6ZVswXSwgdGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGBjb25zdGFudHNfJHtuYW1lfVNpemVgLCB0ZXh0dXJlU2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgY29uc3RhbnRzXyR7bmFtZX1gLCB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0ID0gdmFsdWU7XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gdXRpbHMuZ2V0RGltZW5zaW9ucyhpbnB1dCwgdHJ1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgYml0UmF0aW8gPSB0aGlzLmNvbnN0YW50Qml0UmF0aW9zW25hbWVdO1xuXHRcdFx0XHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZShkaW0sIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjb25zdGFudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlbmd0aCA9IHRleHR1cmVTaXplWzBdICogdGV4dHVyZVNpemVbMV0gKiBiaXRSYXRpbztcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlc0ZsYXQgPSB0aGlzLmZvcm1hdEFycmF5VHJhbnNmZXIoaW5wdXQudmFsdWUsIGxlbmd0aCwgRmxvYXQzMkFycmF5KTtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4dHVyZVNpemVbMF0sIHRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdmFsdWVzRmxhdCk7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGBjb25zdGFudHNfJHtuYW1lfVNpemVgLCB0ZXh0dXJlU2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgY29uc3RhbnRzXyR7bmFtZX1gLCB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUoZGltLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY29uc3RhbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGxlbmd0aCA9IHRleHR1cmVTaXplWzBdICogdGV4dHVyZVNpemVbMV0gKiAoNCAvIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlc0ZsYXQgPSB0aGlzLmZvcm1hdEFycmF5VHJhbnNmZXIoaW5wdXQudmFsdWUsIGxlbmd0aCk7XG5cdFx0XHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZXNGbGF0LmJ1ZmZlcik7XG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleHR1cmVTaXplWzBdLCB0ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgYnVmZmVyKTtcblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdihgY29uc3RhbnRzXyR7bmFtZX1EaW1gLCBkaW0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYGNvbnN0YW50c18ke25hbWV9U2l6ZWAsIHRleHR1cmVTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGBjb25zdGFudHNfJHtuYW1lfWAsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBpbnB1dEltYWdlID0gdmFsdWU7XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gW2lucHV0SW1hZ2Uud2lkdGgsIGlucHV0SW1hZ2UuaGVpZ2h0LCAxXTtcblx0XHRcdFx0XHRjb25zdCBzaXplID0gW2lucHV0SW1hZ2Uud2lkdGgsIGlucHV0SW1hZ2UuaGVpZ2h0XTtcblxuXHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY29uc3RhbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHRcdFx0XHRcdC8vIFVwbG9hZCB0aGUgaW1hZ2UgaW50byB0aGUgdGV4dHVyZS5cblx0XHRcdFx0XHRjb25zdCBtaXBMZXZlbCA9IDA7IC8vIHRoZSBsYXJnZXN0IG1pcFxuXHRcdFx0XHRcdGNvbnN0IGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IHdlIHdhbnQgaW4gdGhlIHRleHR1cmVcblx0XHRcdFx0XHRjb25zdCBzcmNGb3JtYXQgPSBnbC5SR0JBOyAvLyBmb3JtYXQgb2YgZGF0YSB3ZSBhcmUgc3VwcGx5aW5nXG5cdFx0XHRcdFx0Y29uc3Qgc3JjVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7IC8vIHR5cGUgb2YgZGF0YSB3ZSBhcmUgc3VwcGx5aW5nXG5cdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELFxuXHRcdFx0XHRcdFx0bWlwTGV2ZWwsXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCxcblx0XHRcdFx0XHRcdHNyY0Zvcm1hdCxcblx0XHRcdFx0XHRcdHNyY1R5cGUsXG5cdFx0XHRcdFx0XHRpbnB1dEltYWdlKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYGNvbnN0YW50c18ke25hbWV9U2l6ZWAsIHNpemUpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGBjb25zdGFudHNfJHtuYW1lfWAsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0VGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGNvbnN0YW50ICR7IG5hbWV9ICgkeyB0eXBlIH0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYGNvbnN0YW50c18ke25hbWV9U2l6ZWAsIHNpemUpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGBjb25zdGFudHNfJHtuYW1lfWAsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0VGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGNvbnN0YW50ICR7IG5hbWV9ICgkeyB0eXBlIH0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGBjb25zdGFudHNfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGBjb25zdGFudHNfJHtuYW1lfVNpemVgLCBzaXplKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgY29uc3RhbnRzXyR7bmFtZX1gLCB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NvbnN0YW50IHR5cGUgbm90IHN1cHBvcnRlZDogJyArIHZhbHVlKTtcblx0XHR9XG5cdFx0dGhpcy5jb25zdGFudHNMZW5ndGgrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBBZGRzIGtlcm5lbCBwYXJhbWV0ZXJzIHRvIHRoZSBBcmd1bWVudCBUZXh0dXJlLFxuXHQgKiBiaW5kaW5nIGl0IHRvIHRoZSBjb250ZXh0LCBldGMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl8RmxvYXQzMkFycmF5fFVpbnQxNkFycmF5fSB2YWx1ZSAtIFRoZSBhY3R1YWwgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIGtlcm5lbFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gdGhlIGV4cGVjdGVkIHRvdGFsIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGFycmF5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbVHlwZV1cblx0ICogQHJldHVybnMge0Zsb2F0MzJBcnJheXxVaW50MTZBcnJheXxVaW50OEFycmF5fSBmbGF0dGVuZWQgYXJyYXkgdG8gdHJhbnNmZXJcblx0ICovXG5cdGZvcm1hdEFycmF5VHJhbnNmZXIodmFsdWUsIGxlbmd0aCwgVHlwZSkge1xuXHRcdGlmICh0aGlzLmZsb2F0VGV4dHVyZXMpIHtcblx0XHRcdC8vIGxlbmd0aCAqPSA0O1xuXHRcdH1cblx0XHRpZiAodXRpbHMuaXNBcnJheSh2YWx1ZVswXSkgfHwgdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG5cdFx0XHQvLyBub3QgYWxyZWFkeSBmbGF0XG5cdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuXHRcdFx0dXRpbHMuZmxhdHRlblRvKHZhbHVlLCB2YWx1ZXNGbGF0KTtcblx0XHRcdHJldHVybiB2YWx1ZXNGbGF0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdGNhc2UgVWludDhBcnJheTpcblx0XHRcdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cdFx0XHRcdGNhc2UgVWludDE2QXJyYXk6XG5cdFx0XHRcdGNhc2UgSW50MTZBcnJheTpcblx0XHRcdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cdFx0XHRcdGNhc2UgSW50MzJBcnJheTpcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gbmV3KFR5cGUgfHwgdmFsdWUuY29uc3RydWN0b3IpKGxlbmd0aCk7XG5cdFx0XHRcdFx0dXRpbHMuZmxhdHRlblRvKHZhbHVlLCB2YWx1ZXNGbGF0KTtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWVzRmxhdDtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuXHRcdFx0XHRcdFx0dXRpbHMuZmxhdHRlblRvKHZhbHVlLCB2YWx1ZXNGbGF0KTtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZXNGbGF0O1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IHRoZSBoZWFkZXIgc3RyaW5nIGZvciB0aGUgcHJvZ3JhbS5cblx0ICogVGhpcyByZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiBubyBzdWIta2VybmVscyBhcmUgZGVmaW5lZC5cblx0ICpcblx0ICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG5cdCAqL1xuXHRfZ2V0SGVhZGVyU3RyaW5nKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwgP1xuXHRcdFx0JyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG4nIDpcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBHZXQgdGhlIG1heGltdW0gbG9vcCBzaXplIFN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG5cdCAqL1xuXHRfZ2V0TG9vcE1heFN0cmluZygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5sb29wTWF4SXRlcmF0aW9ucyA/XG5cdFx0XHRgICR7cGFyc2VJbnQodGhpcy5sb29wTWF4SXRlcmF0aW9ucyl9O1xcbmAgOlxuXHRcdFx0JyAxMDAwO1xcbidcblx0XHQpO1xuXHR9XG5cblx0X2dldFBsdWdpbnNTdHJpbmcoKSB7XG5cdFx0aWYgKCF0aGlzLnBsdWdpbnMpIHJldHVybiAnXFxuJztcblx0XHRyZXR1cm4gdGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5tYXRjaChwbHVnaW4uZnVuY3Rpb25NYXRjaCkgPyBwbHVnaW4uc291cmNlIDogJycpLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEdlbmVyYXRlIHRyYW5zcGlsZWQgZ2xzbCBTdHJpbmdzIGZvciBjb25zdGFudCBwYXJhbWV0ZXJzIHNlbnQgdG8gYSBrZXJuZWxcblx0ICogVGhleSBjYW4gYmUgZGVmaW5lZCBieSAqaGFyZGNvZGVDb25zdGFudHMqXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuXHQgKi9cblx0X2dldENvbnN0YW50c1N0cmluZygpIHtcblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRjb25zdCB7XG5cdFx0XHR0aHJlYWREaW0sXG5cdFx0XHR0ZXhTaXplXG5cdFx0fSA9IHRoaXM7XG5cdFx0aWYgKHRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRgaXZlYzMgdU91dHB1dERpbSA9IGl2ZWMzKCR7dGhyZWFkRGltWzBdfSwgJHt0aHJlYWREaW1bMV19LCAke3RocmVhZERpbVsyXX0pYCxcblx0XHRcdFx0YGl2ZWMyIHVUZXhTaXplID0gaXZlYzIoJHt0ZXhTaXplWzBdfSwgJHt0ZXhTaXplWzFdfSlgXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0J3VuaWZvcm0gaXZlYzMgdU91dHB1dERpbScsXG5cdFx0XHRcdCd1bmlmb3JtIGl2ZWMyIHVUZXhTaXplJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEdldCB0ZXh0dXJlIGNvb3JkaW5hdGUgc3RyaW5nIGZvciB0aGUgcHJvZ3JhbVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcblx0ICovXG5cdF9nZXRUZXh0dXJlQ29vcmRpbmF0ZSgpIHtcblx0XHRjb25zdCBzdWJLZXJuZWxzID0gdGhpcy5zdWJLZXJuZWxzO1xuXHRcdGlmIChzdWJLZXJuZWxzID09PSBudWxsIHx8IHN1Yktlcm5lbHMubGVuZ3RoIDwgMSkge1xuXHRcdFx0cmV0dXJuICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAnb3V0IHZlYzIgdlRleENvb3JkO1xcbic7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEdldCBEZWNvZGUzMiBlbmRpYW5uZXNzIHN0cmluZyBmb3IgbGl0dGxlLWVuZGlhbiBhbmQgYmlnLWVuZGlhblxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcblx0ICovXG5cdF9nZXREZWNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuZW5kaWFubmVzcyA9PT0gJ0xFJyA/XG5cdFx0XHQnJyA6XG5cdFx0XHQnICB0ZXhlbC5yZ2JhID0gdGV4ZWwuYWJncjtcXG4nXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBHZXQgRW5jb2RlMzIgZW5kaWFubmVzcyBzdHJpbmcgZm9yIGxpdHRsZS1lbmRpYW4gYW5kIGJpZy1lbmRpYW5cblx0ICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG5cdCAqL1xuXHRfZ2V0RW5jb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmVuZGlhbm5lc3MgPT09ICdMRScgP1xuXHRcdFx0JycgOlxuXHRcdFx0JyAgdGV4ZWwucmdiYSA9IHRleGVsLmFiZ3I7XFxuJ1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgaWYgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgcHJvdmlkZSBtZXRob2QgdG8gcmVwbGFjZSAvXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuXHQgKi9cblx0X2dldERpdmlkZVdpdGhJbnRlZ2VyQ2hlY2tTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgP1xuXHRcdFx0YGZsb2F0IGRpdl93aXRoX2ludF9jaGVjayhmbG9hdCB4LCBmbG9hdCB5KSB7XG4gIGlmIChmbG9vcih4KSA9PSB4ICYmIGZsb29yKHkpID09IHkgJiYgaW50ZWdlck1vZCh4LCB5KSA9PSAwLjApIHtcbiAgICByZXR1cm4gZmxvYXQoaW50KHgpL2ludCh5KSk7XG4gIH1cbiAgcmV0dXJuIHggLyB5O1xufWAgOlxuXHRcdFx0Jyc7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2VuZXJhdGUgdHJhbnNwaWxlZCBnbHNsIFN0cmluZ3MgZm9yIHVzZXItZGVmaW5lZCBwYXJhbWV0ZXJzIHNlbnQgdG8gYSBrZXJuZWxcblx0ICogQHBhcmFtIHtBcnJheX0gYXJncyAtIFRoZSBhY3R1YWwgcGFyYW1ldGVycyBzZW50IHRvIHRoZSBLZXJuZWxcblx0ICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG5cdCAqL1xuXHRfZ2V0TWFpbkFyZ3VtZW50c1N0cmluZyhhcmdzKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cdFx0Y29uc3Qge1xuXHRcdFx0YXJndW1lbnRUeXBlcyxcblx0XHRcdGFyZ3VtZW50TmFtZXMsXG5cdFx0XHRoYXJkY29kZUNvbnN0YW50cyxcblx0XHRcdG9wdGltaXplRmxvYXRNZW1vcnksXG5cdFx0XHRwcmVjaXNpb24sXG5cdFx0fSA9IHRoaXM7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGFyZ3NbaV07XG5cdFx0XHRjb25zdCBuYW1lID0gYXJndW1lbnROYW1lc1tpXTtcblx0XHRcdGNvbnN0IHR5cGUgPSBhcmd1bWVudFR5cGVzW2ldO1xuXHRcdFx0aWYgKGhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0XHRjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMSknOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoNCknOlxuXHRcdFx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHRcdFx0Y29uc3QgZGltID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gdXRpbHMuZGltVG9UZXhTaXplKHtcblx0XHRcdFx0XHRcdFx0ZmxvYXRUZXh0dXJlczogb3B0aW1pemVGbG9hdE1lbW9yeSxcblx0XHRcdFx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHByZWNpc2lvbiA9PT0gJ3NpbmdsZScsXG5cdFx0XHRcdFx0XHR9LCBkaW0pO1xuXG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHRcdFx0YHVuaWZvcm0gc2FtcGxlcjJEIHVzZXJfJHtuYW1lfWAsXG5cdFx0XHRcdFx0XHRcdGBpdmVjMiB1c2VyXyR7bmFtZX1TaXplID0gaXZlYzIoJHtzaXplWzBdfSwgJHtzaXplWzFdfSlgLFxuXHRcdFx0XHRcdFx0XHRgaXZlYzMgdXNlcl8ke25hbWV9RGltID0gaXZlYzMoJHtkaW1bMF19LCAke2RpbVsxXX0sICR7ZGltWzJdfSlgLFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goYGZsb2F0IHVzZXJfJHtuYW1lfSA9ICR7dmFsdWV9LjBgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goYGZsb2F0IHVzZXJfJHtuYW1lfSA9ICR7IE51bWJlci5pc0ludGVnZXIodmFsdWUpID8gdmFsdWUgKyAnLjAnIDogdmFsdWUgfWApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdHlwZSAke3R5cGV9IG5vdCBzdXBwb3J0ZWQgaW4gV2ViR0xgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdGNhc2UgJ051bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMyknOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdFx0Y2FzZSAnSW5wdXQnOlxuXHRcdFx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHRcdFx0YHVuaWZvcm0gc2FtcGxlcjJEIHVzZXJfJHtuYW1lfWAsXG5cdFx0XHRcdFx0XHRcdGB1bmlmb3JtIGl2ZWMyIHVzZXJfJHtuYW1lfVNpemVgLFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBpdmVjMyB1c2VyXyR7bmFtZX1EaW1gLFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goYHVuaWZvcm0gaW50IHVzZXJfJHtuYW1lfWApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaChgdW5pZm9ybSBmbG9hdCB1c2VyXyR7bmFtZX1gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goYHVuaWZvcm0gaW50IHVzZXJfJHtuYW1lfWApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdHlwZSAke3R5cGV9IG5vdCBzdXBwb3J0ZWQgaW4gV2ViR0xgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHR9XG5cblx0X2dldE1haW5Db25zdGFudHNTdHJpbmcoKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cdFx0Y29uc3Qge1xuXHRcdFx0Y29uc3RhbnRzXG5cdFx0fSA9IHRoaXM7XG5cdFx0aWYgKGNvbnN0YW50cykge1xuXHRcdFx0Zm9yIChsZXQgbmFtZSBpbiBjb25zdGFudHMpIHtcblx0XHRcdFx0aWYgKCFjb25zdGFudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBjb25zdGFudHNbbmFtZV07XG5cdFx0XHRcdGxldCB0eXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKHZhbHVlKTtcblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnY29uc3QgaW50IGNvbnN0YW50c18nICsgbmFtZSArICcgPSAnICsgcGFyc2VJbnQodmFsdWUpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCdjb25zdCBmbG9hdCBjb25zdGFudHNfJyArIG5hbWUgKyAnID0gJyArIHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHRjYXNlICdJbnB1dCc6XG5cdFx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMSknOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoNCknOlxuXHRcdFx0XHRcdGNhc2UgJ051bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0XHRcdGB1bmlmb3JtIHNhbXBsZXIyRCBjb25zdGFudHNfJHtuYW1lfWAsXG5cdFx0XHRcdFx0XHRcdGB1bmlmb3JtIGl2ZWMyIGNvbnN0YW50c18ke25hbWV9U2l6ZWAsXG5cdFx0XHRcdFx0XHRcdGB1bmlmb3JtIGl2ZWMzIGNvbnN0YW50c18ke25hbWV9RGltYCxcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCdjb25zdCBib29sIGNvbnN0YW50c18nICsgbmFtZSArICcgPSAnICsgKHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJykpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29uc3RhbnQgJHtuYW1lfSB0eXBlICR7dHlwZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEdldCBLZXJuZWwgcHJvZ3JhbSBzdHJpbmcgKGluICpnbHNsKikgZm9yIGEga2VybmVsLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcblx0ICovXG5cdGdldEtlcm5lbFN0cmluZygpIHtcblx0XHRsZXQga2VybmVsUmVzdWx0RGVjbGFyYXRpb247XG5cdFx0c3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcblx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdFx0a2VybmVsUmVzdWx0RGVjbGFyYXRpb24gPSAndmVjMiBrZXJuZWxSZXN1bHQnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0FycmF5KDMpJzpcblx0XHRcdFx0a2VybmVsUmVzdWx0RGVjbGFyYXRpb24gPSAndmVjMyBrZXJuZWxSZXN1bHQnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0FycmF5KDQpJzpcblx0XHRcdFx0a2VybmVsUmVzdWx0RGVjbGFyYXRpb24gPSAndmVjNCBrZXJuZWxSZXN1bHQnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcblx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0a2VybmVsUmVzdWx0RGVjbGFyYXRpb24gPSAnZmxvYXQga2VybmVsUmVzdWx0Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRpZiAodGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdFx0XHRrZXJuZWxSZXN1bHREZWNsYXJhdGlvbiA9ICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG91dHB1dCB0eXBlIFwiJHsgdGhpcy5yZXR1cm5UeXBlIH1cImApO1xuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cdFx0Y29uc3Qgc3ViS2VybmVscyA9IHRoaXMuc3ViS2VybmVscztcblx0XHRpZiAoc3ViS2VybmVscyAhPT0gbnVsbCkge1xuXHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdGtlcm5lbFJlc3VsdERlY2xhcmF0aW9uXG5cdFx0XHQpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdGBmbG9hdCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH0gPSAwLjBgXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRrZXJuZWxSZXN1bHREZWNsYXJhdGlvblxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpICsgdGhpcy50cmFuc2xhdGVkU291cmNlO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG5cdFx0XHQnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuXHRcdFx0JyAga2VybmVsKCknLFxuXHRcdFx0JyAgZ2xfRnJhZ0NvbG9yID0gYWN0dWFsQ29sb3InLFxuXHRcdF0pO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcblx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXInOlxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSkgK1xuXHRcdFx0XHRcdHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBwYWNrZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgXCIke3RoaXMucmV0dXJuVHlwZX1cIiBzcGVjaWZpZWRgKTtcblx0XHR9XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHQnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuXHRcdFx0JyAga2VybmVsKCknLFxuXHRcdFx0JyAgZ2xfRnJhZ0RhdGFbMF0gPSBlbmNvZGUzMihrZXJuZWxSZXN1bHQpJ1xuXHRcdF07XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0YCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gZW5jb2RlMzIoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0TWVtb3J5T3B0aW1pemVkRmxvYXRzKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtcblx0XHRcdCcgIGluZGV4ICo9IDQnLFxuXHRcdF07XG5cblx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRjb25zdCBjaGFubmVscyA9IFsncicsICdnJywgJ2InLCAnYSddO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2hhbm5lbCA9IGNoYW5uZWxzW2ldO1xuXHRcdFx0XHRcdHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpO1xuXHRcdFx0XHRcdHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpO1xuXHRcdFx0XHRcdGlmIChpICsgMSA8IGNoYW5uZWxzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgaW5kZXggKz0gMScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgb3B0aW1pemVkIG91dHB1dCBvbmx5IHVzYWJsZSB3aXRoIE51bWJlcnMsICR7dGhpcy5yZXR1cm5UeXBlfSBzcGVjaWZpZWRgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcblx0XHRyZXN1bHQucHVzaChcblx0XHRcdCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG5cdFx0XHQnICBrZXJuZWwoKScsXG5cdFx0XHRgICBnbF9GcmFnRGF0YVswXS4ke2NoYW5uZWx9ID0ga2VybmVsUmVzdWx0YCxcblx0XHQpO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdFN1Yktlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcblx0XHRpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XS4ke2NoYW5uZWx9ID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YCxcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEtlcm5lbE51bWJlclRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG5cdFx0XHQnICBrZXJuZWwoKScsXG5cdFx0XHQnICBnbF9GcmFnRGF0YVswXVswXSA9IGtlcm5lbFJlc3VsdCcsXG5cdFx0XTtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRTdWJLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0YCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YCxcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0JyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcblx0XHRcdCcgIGtlcm5lbCgpJyxcblx0XHRcdCcgIGdsX0ZyYWdEYXRhWzBdWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcblx0XHRcdCcgIGdsX0ZyYWdEYXRhWzBdWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcblx0XHRdO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5MlRleHR1cmUoKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cdFx0aWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuXHRcdFx0XHRgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHQnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuXHRcdFx0JyAga2VybmVsKCknLFxuXHRcdFx0JyAgZ2xfRnJhZ0RhdGFbMF1bMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuXHRcdFx0JyAgZ2xfRnJhZ0RhdGFbMF1bMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuXHRcdFx0JyAgZ2xfRnJhZ0RhdGFbMF1bMl0gPSBrZXJuZWxSZXN1bHRbMl0nLFxuXHRcdF07XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuXHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG5cdFx0XHRcdGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWAsXG5cdFx0XHRcdGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsyXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsyXWAsXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG5cdFx0XHQnICBrZXJuZWwoKScsXG5cdFx0XHQnICBnbF9GcmFnRGF0YVswXSA9IGtlcm5lbFJlc3VsdCcsXG5cdFx0XTtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0YCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YCxcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IG1haW4gcmVzdWx0IHN0cmluZyB3aXRoIGNoZWNrcyBmb3IgcHJlY2lzaW9uLCBncmFwaGljYWwsIHN1Yktlcm5lbHNSZXN1bHRzLCBldGMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuXHQgKi9cblx0X2dldE1haW5SZXN1bHRTdHJpbmcoKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0c3ViS2VybmVscyxcblx0XHRcdHByZWNpc2lvbixcblx0XHRcdGZsb2F0VGV4dHVyZXMsXG5cdFx0XHRncmFwaGljYWwsXG5cdFx0XHRwaXBlbGluZVxuXHRcdH0gPSB0aGlzO1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXG5cdFx0aWYgKHByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdHJlc3VsdC5wdXNoKCcgIGluZGV4ICo9IDQnKTtcblx0XHR9XG5cblx0XHRpZiAoZ3JhcGhpY2FsKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0JyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcblx0XHRcdFx0JyAga2VybmVsKCknLFxuXHRcdFx0XHQnICBnbF9GcmFnQ29sb3IgPSBhY3R1YWxDb2xvcicsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAocHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuXHRcdFx0Y29uc3QgY2hhbm5lbHMgPSBbJ3InLCAnZycsICdiJywgJ2EnXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVscy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCgnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknKTtcblx0XHRcdFx0cmVzdWx0LnB1c2goJyAga2VybmVsKCknKTtcblxuXHRcdFx0XHRpZiAoc3ViS2VybmVscykge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGAgIGdsX0ZyYWdEYXRhWzBdLiR7Y2hhbm5lbHNbaV19ID0ga2VybmVsUmVzdWx0YCk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHN1Yktlcm5lbHMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGAgIGdsX0ZyYWdEYXRhWyR7aiArIDF9XS4ke2NoYW5uZWxzW2ldfSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbHNbal0ubmFtZX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYCAgZ2xfRnJhZ0NvbG9yLiR7Y2hhbm5lbHNbaV19ID0ga2VybmVsUmVzdWx0YCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaSA8IGNoYW5uZWxzLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICBpbmRleCArPSAxJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHN1Yktlcm5lbHMgIT09IG51bGwpIHtcblx0XHRcdHJlc3VsdC5wdXNoKCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScpO1xuXHRcdFx0cmVzdWx0LnB1c2goJyAga2VybmVsKCknKTtcblx0XHRcdHJlc3VsdC5wdXNoKCcgIGdsX0ZyYWdEYXRhWzBdID0gZW5jb2RlMzIoa2VybmVsUmVzdWx0KScpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9IGVuY29kZTMyKHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbHNbaV0ubmFtZX0pYCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHQnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuXHRcdFx0XHQnICBrZXJuZWwoKScsXG5cdFx0XHRcdCcgIGdsX0ZyYWdDb2xvciA9IGVuY29kZTMyKGtlcm5lbFJlc3VsdCknLFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgLSBTaGFkZXIgc3RyaW5nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgLSBWYXJpYWJsZXMvQ29uc3RhbnRzIGFzc29jaWF0ZWQgd2l0aCBzaGFkZXJcblx0ICovXG5cdHJlcGxhY2VBcnRpZmFjdHMoc3JjLCBtYXApIHtcblx0XHRyZXR1cm4gc3JjLnJlcGxhY2UoL1sgXSpfXyhbQS1aXStbMC05XSooW19dP1tBLVpdKSopX187XFxuL2csIChtYXRjaCwgYXJ0aWZhY3QpID0+IHtcblx0XHRcdGlmIChtYXAuaGFzT3duUHJvcGVydHkoYXJ0aWZhY3QpKSB7XG5cdFx0XHRcdHJldHVybiBtYXBbYXJ0aWZhY3RdO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgYHVuaGFuZGxlZCBhcnRpZmFjdCAke2FydGlmYWN0fWA7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IHRoZSBmcmFnbWVudCBzaGFkZXIgU3RyaW5nLlxuXHQgKiBJZiB0aGUgU3RyaW5nIGhhc24ndCBiZWVuIGNvbXBpbGVkIHlldCxcblx0ICogdGhlbiB0aGlzIG1ldGhvZCBjb21waWxlcyBpdCBhcyB3ZWxsXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBUaGUgYWN0dWFsIHBhcmFtZXRlcnMgc2VudCB0byB0aGUgS2VybmVsXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEZyYWdtZW50IFNoYWRlciBzdHJpbmdcblx0ICovXG5cdGdldEZyYWdtZW50U2hhZGVyKGFyZ3MpIHtcblx0XHRpZiAodGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyID0gdGhpcy5yZXBsYWNlQXJ0aWZhY3RzKHRoaXMuY29uc3RydWN0b3IuZnJhZ21lbnRTaGFkZXIsIHRoaXMuX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IHRoZSB2ZXJ0aWNhbCBzaGFkZXIgU3RyaW5nXG5cdCAqIEBwYXJhbSB7QXJyYXl8SUFyZ3VtZW50c30gYXJncyAtIFRoZSBhY3R1YWwgcGFyYW1ldGVycyBzZW50IHRvIHRoZSBLZXJuZWxcblx0ICogQHJldHVybnMge3N0cmluZ30gVmVydGljYWwgU2hhZGVyIHN0cmluZ1xuXHQgKi9cblx0Z2V0VmVydGV4U2hhZGVyKGFyZ3MpIHtcblx0XHRpZiAodGhpcy5jb21waWxlZFZlcnRleFNoYWRlciAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyID0gdGhpcy5jb25zdHJ1Y3Rvci52ZXJ0ZXhTaGFkZXI7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgUmV0dXJucyB0aGUgKnByZS1jb21waWxlZCogS2VybmVsIGFzIGEgSlMgT2JqZWN0IFN0cmluZywgdGhhdCBjYW4gYmUgcmV1c2VkLlxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHdlYkdMS2VybmVsU3RyaW5nKHRoaXMpO1xuXHR9XG5cblx0ZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG5cdFx0aWYgKHRoaXMub3V0cHV0VGV4dHVyZSkge1xuXHRcdFx0dGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGhpcy5vdXRwdXRUZXh0dXJlKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuYnVmZmVyKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuZnJhbWVidWZmZXIpIHtcblx0XHRcdHRoaXMuY29udGV4dC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMudmVydFNoYWRlcikge1xuXHRcdFx0dGhpcy5jb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRTaGFkZXIpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5mcmFnU2hhZGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ1NoYWRlcik7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnByb2dyYW0pIHtcblx0XHRcdHRoaXMuY29udGV4dC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMudGV4dHVyZUNhY2hlKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgbmFtZSA9IGtleXNbaV07XG5cdFx0XHR0aGlzLmNvbnRleHQuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmVDYWNoZVtuYW1lXSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvbnRleHQuZGVsZXRlVGV4dHVyZSh0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHJlbW92ZUNhbnZhc1JlZmVyZW5jZXMpIHtcblx0XHRcdGNvbnN0IGlkeCA9IGNhbnZhc2VzLmluZGV4T2YodGhpcy5jYW52YXMpO1xuXHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdGNhbnZhc2VzW2lkeF0gPSBudWxsO1xuXHRcdFx0XHRtYXhUZXhTaXplc1tpZHhdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5kZXN0cm95RXh0ZW5zaW9ucygpO1xuXHRcdGRlbGV0ZSB0aGlzLmNvbnRleHQ7XG5cdFx0ZGVsZXRlIHRoaXMuY2FudmFzO1xuXHR9XG5cblx0ZGVzdHJveUV4dGVuc2lvbnMoKSB7XG5cdFx0dGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0ID0gbnVsbDtcblx0XHR0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyID0gbnVsbDtcblx0XHR0aGlzLmV4dGVuc2lvbnMuT0VTX2VsZW1lbnRfaW5kZXhfdWludCA9IG51bGw7XG5cdFx0dGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyA9IG51bGw7XG5cdH1cblxuXHRzdGF0aWMgZGVzdHJveUNvbnRleHQoY29udGV4dCkge1xuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcblx0XHRpZiAoZXh0ZW5zaW9uKSB7XG5cdFx0XHRleHRlbnNpb24ubG9zZUNvbnRleHQoKTtcblx0XHR9XG5cdH1cblxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QganNvbiA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdGpzb24uZnVuY3Rpb25Ob2RlcyA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMRnVuY3Rpb25Ob2RlKS50b0pTT04oKTtcblx0XHRyZXR1cm4ganNvbjtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0V2ViR0xLZXJuZWxcbn07IiwiY29uc3QgdmVydGV4U2hhZGVyID0gYHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5wcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuXG5hdHRyaWJ1dGUgdmVjMiBhUG9zO1xuYXR0cmlidXRlIHZlYzIgYVRleENvb3JkO1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xudW5pZm9ybSB2ZWMyIHJhdGlvO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFQb3MgKyB2ZWMyKDEpKSAqIHJhdGlvICsgdmVjMigtMSksIDAsIDEpO1xuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHZlcnRleFNoYWRlclxufTsiLCJjb25zdCBmcmFnbWVudFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbl9fSEVBREVSX187XG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5wcmVjaXNpb24gaGlnaHAgaW50O1xucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcblxuY29uc3QgaW50IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xuXG5fX1BMVUdJTlNfXztcbl9fQ09OU1RBTlRTX187XG5cbmluIHZlYzIgdlRleENvb3JkO1xuXG52ZWMyIGludGVnZXJNb2QodmVjMiB4LCBmbG9hdCB5KSB7XG4gIHZlYzIgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XG4gIHZlYzMgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWM0IGludGVnZXJNb2QodmVjNCB4LCB2ZWM0IHkpIHtcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbmZsb2F0IGludGVnZXJNb2QoZmxvYXQgeCwgZmxvYXQgeSkge1xuICBmbG9hdCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcbn1cblxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0gKHkgKiBpbnQoeC95KSk7XG59XG5cbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xuXG4vLyBIZXJlIGJlIGRyYWdvbnMhXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXG4vLyBZT1UgV0lMTCBCUkVBSyBTT01FVEhJTkcgT04gU09NRUJPRFlcXCdTIE1BQ0hJTkVcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXG5jb25zdCB2ZWMyIE1BR0lDX1ZFQyA9IHZlYzIoMS4wLCAtMjU2LjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxuZmxvYXQgZGVjb2RlMzIodmVjNCB0ZXhlbCkge1xuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcbiAgdGV4ZWwgKj0gMjU1LjA7XG4gIHZlYzIgZ3RlMTI4O1xuICBndGUxMjgueCA9IHRleGVsLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGd0ZTEyOC55ID0gdGV4ZWwuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiB0ZXhlbC5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xuICBmbG9hdCByZXMgPSBleHAyKHJvdW5kKGV4cG9uZW50KSk7XG4gIHRleGVsLmIgPSB0ZXhlbC5iIC0gMTI4LjAgKiBndGUxMjgueDtcbiAgcmVzID0gZG90KHRleGVsLCBTQ0FMRV9GQUNUT1IpICogZXhwMihyb3VuZChleHBvbmVudC0yMy4wKSkgKyByZXM7XG4gIHJlcyAqPSBndGUxMjgueSAqIC0yLjAgKyAxLjA7XG4gIHJldHVybiByZXM7XG59XG5cbmZsb2F0IGRlY29kZTE2KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbCoyXSAqIDI1NS4wICsgdGV4ZWxbY2hhbm5lbCoyICsgMV0gKiA2NTI4MC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuXHRpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbF0gKiAyNTUuMDtcbn1cblxudmVjNCBlbmNvZGUzMihmbG9hdCBmKSB7XG4gIGZsb2F0IEYgPSBhYnMoZik7XG4gIGZsb2F0IHNpZ24gPSBmIDwgMC4wID8gMS4wIDogMC4wO1xuICBmbG9hdCBleHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xuICBmbG9hdCBtYW50aXNzYSA9IChleHAyKC1leHBvbmVudCkgKiBGKTtcbiAgLy8gZXhwb25lbnQgKz0gZmxvb3IobG9nMihtYW50aXNzYSkpO1xuICB2ZWM0IHRleGVsID0gdmVjNChGICogZXhwMigyMy4wIC0gZXhwb25lbnQpKSAqIFNDQUxFX0ZBQ1RPUl9JTlY7XG4gIHRleGVsLnJnID0gaW50ZWdlck1vZCh0ZXhlbC5yZywgMjU2LjApO1xuICB0ZXhlbC5iID0gaW50ZWdlck1vZCh0ZXhlbC5iLCAxMjguMCk7XG4gIHRleGVsLmEgPSBleHBvbmVudCAqIDAuNSArIDYzLjU7XG4gIHRleGVsLmJhICs9IHZlYzIoaW50ZWdlck1vZChleHBvbmVudCsxMjcuMCwgMi4wKSwgc2lnbikgKiAxMjguMDtcbiAgdGV4ZWwgPSBmbG9vcih0ZXhlbCk7XG4gIHRleGVsICo9IDAuMDAzOTIxNTY5OyAvLyAxLzI1NVxuICBfX0VOQ09ERTMyX0VORElBTk5FU1NfXztcbiAgcmV0dXJuIHRleGVsO1xufVxuLy8gRHJhZ29ucyBlbmQgaGVyZVxuXG5pbnQgaW5kZXg7XG5pdmVjMyB0aHJlYWRJZDtcblxuaXZlYzMgaW5kZXhUbzNEKGludCBpZHgsIGl2ZWMzIHRleERpbSkge1xuICBpbnQgeiA9IGludChpZHggLyAodGV4RGltLnggKiB0ZXhEaW0ueSkpO1xuICBpZHggLT0geiAqIGludCh0ZXhEaW0ueCAqIHRleERpbS55KTtcbiAgaW50IHkgPSBpbnQoaWR4IC8gdGV4RGltLngpO1xuICBpbnQgeCA9IGludChpbnRlZ2VyTW9kKGlkeCwgdGV4RGltLngpKTtcbiAgcmV0dXJuIGl2ZWMzKHgsIHksIHopO1xufVxuXG5mbG9hdCBnZXQzMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaXZlYzMgeHl6ID0gaXZlYzMoeCwgeSwgeik7XG4gIGludCBpbmRleCA9IHh5ei54ICsgdGV4RGltLnggKiAoeHl6LnkgKyB0ZXhEaW0ueSAqIHh5ei56KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgcmV0dXJuIGRlY29kZTMyKHRleGVsKTtcbn1cblxuZmxvYXQgZ2V0MTYoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xuICBpbnQgaW5kZXggPSB4eXoueCArICh0ZXhEaW0ueCAqICh4eXoueSArICh0ZXhEaW0ueSAqIHh5ei56KSkpO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDI7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUueCAqIDIsIHRleFNpemUueSkpO1xuICByZXR1cm4gZGVjb2RlMTYodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0OChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaXZlYzMgeHl6ID0gaXZlYzMoeCwgeSwgeik7XG4gIGludCBpbmRleCA9IHh5ei54ICsgKHRleERpbS54ICogKHh5ei55ICsgKHRleERpbS55ICogeHl6LnopKSk7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogNDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZS54ICogNCwgdGV4U2l6ZS55KSk7XG4gIHJldHVybiBkZWNvZGU4KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldE1lbW9yeU9wdGltaXplZDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpdmVjMyB4eXogPSBpdmVjMyh4LCB5LCB6KTtcbiAgaW50IGluZGV4ID0geHl6LnggKyAodGV4RGltLnggKiAoeHl6LnkgKyAodGV4RGltLnkgKiB4eXoueikpKTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCA0KTtcbiAgaW5kZXggPSBpbmRleCAvIDQ7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICBpbmRleCA9IGluZGV4IC8gNDtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbF07XG59XG5cbnZlYzQgZ2V0SW1hZ2UyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaXZlYzMgeHl6ID0gaXZlYzMoeCwgeSwgeik7XG4gIGludCBpbmRleCA9IHh5ei54ICsgdGV4RGltLnggKiAoeHl6LnkgKyB0ZXhEaW0ueSAqIHh5ei56KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbn1cblxudmVjNCBnZXRJbWFnZTNEKHNhbXBsZXIyREFycmF5IHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xuICBpbnQgaW5kZXggPSB4eXoueCArIHRleERpbS54ICogKHh5ei55ICsgdGV4RGltLnkgKiB4eXoueik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZSh0ZXgsIHZlYzMoc3QgLyB2ZWMyKHRleFNpemUpLCB6KSk7XG59XG5cbmZsb2F0IGdldEZsb2F0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxudmVjMiBnZXRWZWMyRnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHZlYzIocmVzdWx0WzBdLCByZXN1bHRbMV0pO1xufVxuXG52ZWMzIGdldFZlYzNGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMyhyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbn1cblxudmVjNCBnZXRWZWM0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgcmV0dXJuIGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xufVxuXG52ZWM0IGFjdHVhbENvbG9yO1xudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcbn1cblxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XG4gIGNvbG9yKHIsZyxiLDEuMCk7XG59XG5cbl9fTUFJTl9DT05TVEFOVFNfXztcbl9fTUFJTl9BUkdVTUVOVFNfXztcbl9fS0VSTkVMX187XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGluZGV4ID0gaW50KHZUZXhDb29yZC5zICogZmxvYXQodVRleFNpemUueCkpICsgaW50KHZUZXhDb29yZC50ICogZmxvYXQodVRleFNpemUueSkpICogdVRleFNpemUueDtcbiAgX19NQUlOX1JFU1VMVF9fO1xufWA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRmcmFnbWVudFNoYWRlclxufTsiLCJjb25zdCB7XG5cdFdlYkdMRnVuY3Rpb25Ob2RlXG59ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR0wyRnVuY3Rpb25Ob2RlXG4gKiBAZGVzYyBbSU5URVJOQUxdIFRha2VzIGluIGEgZnVuY3Rpb24gbm9kZSwgYW5kIGRvZXMgYWxsIHRoZSBBU1Qgdm9vZG9vIHJlcXVpcmVkIHRvIHRvU3RyaW5nIGl0cyByZXNwZWN0aXZlIHdlYkdMIGNvZGUuXG4gKiBAZXh0ZW5kcyBXZWJHTEZ1bmN0aW9uTm9kZVxuICogQHJldHVybnMgdGhlIGNvbnZlcnRlZCB3ZWJHTCBmdW5jdGlvbiBzdHJpbmdcbiAqL1xuY2xhc3MgV2ViR0wyRnVuY3Rpb25Ob2RlIGV4dGVuZHMgV2ViR0xGdW5jdGlvbk5vZGUge1xuXG5cdC8qKlxuXHQgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqaWRlbnRpZmllciogZXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gaWR0Tm9kZSAtIEFuIGFzdCBOb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcblx0ICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuXHQgKi9cblx0YXN0SWRlbnRpZmllckV4cHJlc3Npb24oaWR0Tm9kZSwgcmV0QXJyKSB7XG5cdFx0aWYgKGlkdE5vZGUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuXHRcdFx0XHQnSWRlbnRpZmllckV4cHJlc3Npb24gLSBub3QgYW4gSWRlbnRpZmllcicsXG5cdFx0XHRcdGlkdE5vZGVcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShpZHROb2RlKTtcblxuXHRcdGlmIChpZHROb2RlLm5hbWUgPT09ICdJbmZpbml0eScpIHtcblx0XHRcdHJldEFyci5wdXNoKCdpbnRCaXRzVG9GbG9hdCgyMTM5MDk1MDM5KScpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG5cdFx0XHRpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoaWR0Tm9kZS5uYW1lKSA+IC0xKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKGBib29sKHVzZXJfJHtpZHROb2RlLm5hbWV9KWApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goYHVzZXJfJHtpZHROb2RlLm5hbWV9YCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHVzZXJBcmd1bWVudE5hbWUgPSB0aGlzLmdldEtlcm5lbEFyZ3VtZW50TmFtZShpZHROb2RlLm5hbWUpO1xuXHRcdFx0aWYgKHVzZXJBcmd1bWVudE5hbWUpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goYHVzZXJfJHt1c2VyQXJndW1lbnROYW1lfWApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goYHVzZXJfJHtpZHROb2RlLm5hbWV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldEFycjtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0V2ViR0wyRnVuY3Rpb25Ob2RlXG59OyIsImNvbnN0IHtcblx0V2ViR0xLZXJuZWxcbn0gPSByZXF1aXJlKCcuLi93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7XG5cdFdlYkdMMkZ1bmN0aW9uTm9kZVxufSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3Qge1xuXHRGdW5jdGlvbkJ1aWxkZXJcbn0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1idWlsZGVyJyk7XG5jb25zdCB7XG5cdHV0aWxzXG59ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHtcblx0VGV4dHVyZVxufSA9IHJlcXVpcmUoJy4uLy4uL3RleHR1cmUnKTtcbmNvbnN0IHtcblx0ZnJhZ21lbnRTaGFkZXJcbn0gPSByZXF1aXJlKCcuL2ZyYWdtZW50LXNoYWRlcicpO1xuY29uc3Qge1xuXHR2ZXJ0ZXhTaGFkZXJcbn0gPSByZXF1aXJlKCcuL3ZlcnRleC1zaGFkZXInKTtcblxubGV0IGlzU3VwcG9ydGVkID0gbnVsbDtcbmxldCB0ZXN0Q2FudmFzID0gbnVsbDtcbmxldCB0ZXN0Q29udGV4dCA9IG51bGw7XG5sZXQgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xubGV0IGZlYXR1cmVzID0gbnVsbDtcblxuY2xhc3MgV2ViR0wyS2VybmVsIGV4dGVuZHMgV2ViR0xLZXJuZWwge1xuXHRzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuXHRcdGlmIChpc1N1cHBvcnRlZCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGlzU3VwcG9ydGVkO1xuXHRcdH1cblx0XHR0aGlzLnNldHVwRmVhdHVyZUNoZWNrcygpO1xuXHRcdGlzU3VwcG9ydGVkID0gdGhpcy5pc0NvbnRleHRNYXRjaCh0ZXN0Q29udGV4dCk7XG5cdFx0cmV0dXJuIGlzU3VwcG9ydGVkO1xuXHR9XG5cblx0c3RhdGljIHNldHVwRmVhdHVyZUNoZWNrcygpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRlc3RDYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuXHRcdH1cblx0XHRpZiAoIXRlc3RDYW52YXMpIHJldHVybjtcblx0XHR0ZXN0Q29udGV4dCA9IHRlc3RDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XG5cdFx0aWYgKCF0ZXN0Q29udGV4dCB8fCAhdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKSByZXR1cm47XG5cdFx0dGVzdEV4dGVuc2lvbnMgPSB7XG5cdFx0XHRFWFRfY29sb3JfYnVmZmVyX2Zsb2F0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcblx0XHRcdE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcblx0XHR9O1xuXHRcdGZlYXR1cmVzID0gdGhpcy5nZXRGZWF0dXJlcygpO1xuXHR9XG5cblx0c3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcblx0XHQvLyBmcm9tIGdsb2JhbFxuXHRcdGlmICh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBjb250ZXh0IGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0c3RhdGljIGdldEZlYXR1cmVzKCkge1xuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKHtcblx0XHRcdGlzRmxvYXRSZWFkOiB0aGlzLmdldElzRmxvYXRSZWFkKCksXG5cdFx0XHRpc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlOiB0aGlzLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSxcblx0XHRcdGtlcm5lbE1hcDogdHJ1ZSxcblx0XHRcdGlzVGV4dHVyZUZsb2F0OiB0cnVlLFxuXHRcdH0pO1xuXHR9XG5cblx0c3RhdGljIGdldElzVGV4dHVyZUZsb2F0KCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0c3RhdGljIGdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSB7XG5cdFx0cmV0dXJuIHN1cGVyLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgdGVzdENhbnZhcygpIHtcblx0XHRyZXR1cm4gdGVzdENhbnZhcztcblx0fVxuXG5cdHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG5cdFx0cmV0dXJuIHRlc3RDb250ZXh0O1xuXHR9XG5cblx0c3RhdGljIGdldCBmZWF0dXJlcygpIHtcblx0XHRyZXR1cm4gZmVhdHVyZXM7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IGZyYWdtZW50U2hhZGVyKCkge1xuXHRcdHJldHVybiBmcmFnbWVudFNoYWRlcjtcblx0fVxuXHRzdGF0aWMgZ2V0IHZlcnRleFNoYWRlcigpIHtcblx0XHRyZXR1cm4gdmVydGV4U2hhZGVyO1xuXHR9XG5cblx0aW5pdENvbnRleHQoKSB7XG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSB7XG5cdFx0XHRhbHBoYTogZmFsc2UsXG5cdFx0XHRkZXB0aDogZmFsc2UsXG5cdFx0XHRhbnRpYWxpYXM6IGZhbHNlXG5cdFx0fTtcblx0XHRjb25zdCBjb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgc2V0dGluZ3MpO1xuXHRcdHJldHVybiBjb250ZXh0O1xuXHR9XG5cblx0aW5pdEV4dGVuc2lvbnMoKSB7XG5cdFx0dGhpcy5leHRlbnNpb25zID0ge1xuXHRcdFx0RVhUX2NvbG9yX2J1ZmZlcl9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpLFxuXHRcdFx0T0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcblx0XHR9O1xuXHR9XG5cblx0dmFsaWRhdGVTZXR0aW5ncygpIHtcblx0XHRpZiAoIXRoaXMudmFsaWRhdGUpIHtcblx0XHRcdHRoaXMudGV4U2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcblx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyxcblx0XHRcdH0sIHRoaXMub3V0cHV0LCB0cnVlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBmZWF0dXJlcyA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXM7XG5cdFx0aWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyAmJiB0aGlzLmZsb2F0T3V0cHV0Rm9yY2UgIT09IHRydWUgJiYgIWZlYXR1cmVzLmlzRmxvYXRSZWFkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Zsb2F0IHRleHR1cmUgb3V0cHV0cyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhpY2FsICYmIHRoaXMucHJlY2lzaW9uID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnByZWNpc2lvbiA9IGZlYXR1cmVzLmlzRmxvYXRSZWFkID8gJ3NpbmdsZScgOiAndW5zaWduZWQnO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gIWZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmIGZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUpIHtcblx0XHRcdHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmNoZWNrT3V0cHV0KCk7XG5cblx0XHRpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJndW1lbnRzWzBdKTtcblx0XHRcdHN3aXRjaCAoYXJnVHlwZSkge1xuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0dGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0Y2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG5cdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG5cdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdFx0dGhpcy5vdXRwdXQgPSBhcmd1bWVudHNbMF0ub3V0cHV0O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLmdyYXBoaWNhbCkge1xuXHRcdFx0aWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBtdXN0IGhhdmUgMiBkaW1lbnNpb25zIG9uIGdyYXBoaWNhbCBtb2RlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdDYW5ub3QgdXNlIGdyYXBoaWNhbCBtb2RlIGFuZCBzaW5nbGUgcHJlY2lzaW9uIGF0IHRoZSBzYW1lIHRpbWUnKTtcblx0XHRcdFx0dGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRleFNpemUgPSB1dGlscy5jbG9uZSh0aGlzLm91dHB1dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBlbHNlIGlmICghdGhpcy5ncmFwaGljYWwgJiYgdGhpcy5wcmVjaXNpb24gPT09IG51bGwgJiYgZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcblx0XHRcdHRoaXMucHJlY2lzaW9uID0gJ3NpbmdsZSc7XG5cdFx0fVxuXG5cdFx0dGhpcy50ZXhTaXplID0gdXRpbHMuZGltVG9UZXhTaXplKHtcblx0XHRcdGZsb2F0VGV4dHVyZXM6ICF0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG5cdFx0XHRmbG9hdE91dHB1dDogdGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnLFxuXHRcdH0sIHRoaXMub3V0cHV0LCB0cnVlKTtcblxuXHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScgfHwgdGhpcy5mbG9hdE91dHB1dEZvcmNlKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG5cdFx0fVxuXHR9XG5cblx0dHJhbnNsYXRlU291cmNlKCkge1xuXHRcdGNvbnN0IGZ1bmN0aW9uQnVpbGRlciA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMMkZ1bmN0aW9uTm9kZSwge1xuXHRcdFx0Zml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3lcblx0XHR9KTtcblx0XHR0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlU3RyaW5nKCdrZXJuZWwnKTtcblx0XHRpZiAoIXRoaXMuZ3JhcGhpY2FsICYmICF0aGlzLnJldHVyblR5cGUpIHtcblx0XHRcdHRoaXMucmV0dXJuVHlwZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRLZXJuZWxSZXN1bHRUeXBlKCk7XG5cdFx0fVxuXHR9XG5cblx0cnVuKCkge1xuXHRcdGlmICh0aGlzLnByb2dyYW0gPT09IG51bGwpIHtcblx0XHRcdHRoaXMuYnVpbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdFx0Y29uc3Qge1xuXHRcdFx0YXJndW1lbnROYW1lcyxcblx0XHRcdGFyZ3VtZW50VHlwZXMsXG5cdFx0XHR0ZXhTaXplXG5cdFx0fSA9IHRoaXM7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cdFx0Z2wuc2Npc3NvcigwLCAwLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdKTtcblxuXHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KCd1T3V0cHV0RGltJywgbmV3IEludDMyQXJyYXkodGhpcy50aHJlYWREaW0pKTtcblx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdigndVRleFNpemUnLCB0ZXhTaXplKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldFVuaWZvcm0yZigncmF0aW8nLCB0ZXhTaXplWzBdIC8gdGhpcy5tYXhUZXhTaXplWzBdLCB0ZXhTaXplWzFdIC8gdGhpcy5tYXhUZXhTaXplWzFdKTtcblxuXHRcdHRoaXMuYXJndW1lbnRzTGVuZ3RoID0gMDtcblx0XHRmb3IgKGxldCB0ZXhJbmRleCA9IDA7IHRleEluZGV4IDwgYXJndW1lbnROYW1lcy5sZW5ndGg7IHRleEluZGV4KyspIHtcblx0XHRcdHRoaXMuYWRkQXJndW1lbnQoYXJndW1lbnRzW3RleEluZGV4XSwgYXJndW1lbnRUeXBlc1t0ZXhJbmRleF0sIGFyZ3VtZW50TmFtZXNbdGV4SW5kZXhdKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5wbHVnaW5zKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbaV07XG5cdFx0XHRcdGlmIChwbHVnaW4ub25CZWZvcmVSdW4pIHtcblx0XHRcdFx0XHRwbHVnaW4ub25CZWZvcmVSdW4odGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdGlmICh0aGlzLnBpcGVsaW5lKSB7XG5cdFx0XHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcblx0XHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcblx0XHRcdFx0aWYgKCF0aGlzLm91dHB1dFRleHR1cmUgfHwgdGhpcy5pbW11dGFibGUpIHtcblx0XHRcdFx0XHR0aGlzLl9zZXR1cE91dHB1dFRleHR1cmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXh0dXJlKHtcblx0XHRcdFx0XHR0ZXh0dXJlOiB0aGlzLm91dHB1dFRleHR1cmUsXG5cdFx0XHRcdFx0c2l6ZTogdGV4U2l6ZSxcblx0XHRcdFx0XHRkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcblx0XHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0XHRcdGNvbnRleHQ6IHRoaXMuY29udGV4dCxcblx0XHRcdFx0XHRncHU6IHRoaXMuZ3B1LFxuXHRcdFx0XHRcdHR5cGU6IHRoaXMuZ2V0UmV0dXJuVGV4dHVyZVR5cGUoKSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcblx0XHRpZiAodGhpcy5pbW11dGFibGUpIHtcblx0XHRcdHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcblx0XHRcdGlmICh0aGlzLmltbXV0YWJsZSkge1xuXHRcdFx0XHR0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzID0gW107XG5cdFx0XHRcdHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXModGhpcy5zdWJLZXJuZWxzLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0XHRnbC5kcmF3QnVmZmVycyh0aGlzLmRyYXdCdWZmZXJzTWFwKTtcblx0XHR9XG5cblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblxuXHRcdGlmICh0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzICE9PSBudWxsKSB7XG5cdFx0XHRpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IG91dHB1dCA9IHtcblx0XHRcdFx0XHRyZXN1bHQ6IHRoaXMucmVuZGVyT3V0cHV0KClcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKHRoaXMucGlwZWxpbmUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0b3V0cHV0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSBuZXcgVGV4dHVyZSh7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmU6IHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXNbaV0sXG5cdFx0XHRcdFx0XHRcdHNpemU6IHRleFNpemUsXG5cdFx0XHRcdFx0XHRcdGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuXHRcdFx0XHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0XHRcdFx0XHRjb250ZXh0OiB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdGdwdTogdGhpcy5ncHUsXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHRoaXMuZ2V0UmV0dXJuVGV4dHVyZVR5cGUoKSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0b3V0cHV0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSBuZXcgVGV4dHVyZSh7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmU6IHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXNbaV0sXG5cdFx0XHRcdFx0XHRcdHNpemU6IHRleFNpemUsXG5cdFx0XHRcdFx0XHRcdGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuXHRcdFx0XHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0XHRcdFx0XHRjb250ZXh0OiB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdGdwdTogdGhpcy5ncHUsXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHRoaXMuZ2V0UmV0dXJuVGV4dHVyZVR5cGUoKSxcblx0XHRcdFx0XHRcdH0pLnRvQXJyYXkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJPdXRwdXQoKTtcblx0fVxuXG5cdGRyYXdCdWZmZXJzKCkge1xuXHRcdHRoaXMuY29udGV4dC5kcmF3QnVmZmVycyh0aGlzLmRyYXdCdWZmZXJzTWFwKTtcblx0fVxuXG5cdGdldE91dHB1dFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3V0cHV0VGV4dHVyZTtcblx0fVxuXG5cdF9zZXR1cE91dHB1dFRleHR1cmUoKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0dGV4U2l6ZVxuXHRcdH0gPSB0aGlzO1xuXHRcdGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLm91dHB1dFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRpZiAodGhpcy5waXBlbGluZSkge1xuXHRcdFx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuXHRcdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUjMyRiwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkVELCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdBcnJheSgyKSc6XG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHMzJGLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SRywgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IzMkYsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQiwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgcmV0dXJuIHR5cGUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0fVxuXHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cdH1cblxuXHRfc2V0dXBTdWJPdXRwdXRUZXh0dXJlcyhsZW5ndGgpIHtcblx0XHRjb25zdCB7XG5cdFx0XHR0ZXhTaXplXG5cdFx0fSA9IHRoaXM7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG5cdFx0Y29uc3QgZHJhd0J1ZmZlcnNNYXAgPSB0aGlzLmRyYXdCdWZmZXJzTWFwID0gW2dsLkNPTE9SX0FUVEFDSE1FTlQwXTtcblx0XHRjb25zdCB0ZXh0dXJlcyA9IHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy5jb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcblx0XHRcdHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG5cdFx0XHRkcmF3QnVmZmVyc01hcC5wdXNoKGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEpO1xuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCArIGkpO1xuXHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0Ly8gVE9ETzogdXBncmFkZSB0aGlzXG5cdFx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblx0XHRcdH1cblx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBAZGVzYyBBZGRzIGtlcm5lbCBwYXJhbWV0ZXJzIHRvIHRoZSBBcmd1bWVudCBUZXh0dXJlLFxuXHQgKiBiaW5kaW5nIGl0IHRvIHRoZSBjb250ZXh0LCBldGMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl8VGV4dHVyZXxOdW1iZXJ8SW5wdXR9IHZhbHVlIC0gVGhlIGFjdHVhbCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUga2VybmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgYXJndW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhcmd1bWVudFxuXHQgKi9cblx0YWRkQXJndW1lbnQodmFsdWUsIHR5cGUsIG5hbWUpIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcblx0XHRjb25zdCBhcmd1bWVudFRleHR1cmUgPSB0aGlzLmdldEFyZ3VtZW50VGV4dHVyZShuYW1lKTtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG5cdFx0XHR0eXBlID0gdmFsdWUudHlwZTtcblx0XHR9XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRjYXNlICdBcnJheSgyKSc6XG5cdFx0XHRjYXNlICdBcnJheSgzKSc6XG5cdFx0XHRjYXNlICdBcnJheSg0KSc6XG5cdFx0XHRjYXNlICdBcnJheTJEJzpcblx0XHRcdGNhc2UgJ0FycmF5M0QnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgYml0UmF0aW8gPSB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zW3RoaXMuYXJndW1lbnRzTGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUoZGltLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlbmd0aCA9IHRleHR1cmVTaXplWzBdICogdGV4dHVyZVNpemVbMV0gKiBiaXRSYXRpbztcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlc0ZsYXQgPSB0aGlzLmZvcm1hdEFycmF5VHJhbnNmZXIodmFsdWUsIGxlbmd0aCwgRmxvYXQzMkFycmF5KTtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGV4dHVyZVNpemVbMF0sIHRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdmFsdWVzRmxhdCk7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYHVzZXJfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgdXNlcl8ke25hbWV9U2l6ZWAsIHRleHR1cmVTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUoZGltLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gdGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSAqICg0IC8gYml0UmF0aW8pO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVzRmxhdCA9IHRoaXMuZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZSwgbGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlc0ZsYXQuYnVmZmVyKTtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4dHVyZVNpemVbMF0sIHRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBidWZmZXIpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGB1c2VyXyR7bmFtZX1EaW1gLCBkaW0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYHVzZXJfJHtuYW1lfVNpemVgLCB0ZXh0dXJlU2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgdXNlcl8ke25hbWV9YCwgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWYoYHVzZXJfJHtuYW1lfWAsIHZhbHVlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnSW5wdXQnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgaW5wdXQgPSB2YWx1ZTtcblx0XHRcdFx0XHRjb25zdCBkaW0gPSB1dGlscy5nZXREaW1lbnNpb25zKGlucHV0LCB0cnVlKTtcblx0XHRcdFx0XHRjb25zdCBiaXRSYXRpbyA9IHRoaXMuYXJndW1lbnRCaXRSYXRpb3NbdGhpcy5hcmd1bWVudHNMZW5ndGhdO1xuXHRcdFx0XHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZShkaW0sIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gdGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSAqIGJpdFJhdGlvO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVzRmxhdCA9IHRoaXMuZm9ybWF0QXJyYXlUcmFuc2ZlcihpbnB1dC52YWx1ZSwgbGVuZ3RoLCBGbG9hdDMyQXJyYXkpO1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0ZXh0dXJlU2l6ZVswXSwgdGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB2YWx1ZXNGbGF0KTtcblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdihgdXNlcl8ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGB1c2VyXyR7bmFtZX1TaXplYCwgdGV4dHVyZVNpemUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYHVzZXJfJHtuYW1lfWAsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZShkaW0sIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsZW5ndGggPSB0ZXh0dXJlU2l6ZVswXSAqIHRleHR1cmVTaXplWzFdICogKDQgLyBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gdGhpcy5mb3JtYXRBcnJheVRyYW5zZmVyKGlucHV0LnZhbHVlLCBsZW5ndGgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzRmxhdC5idWZmZXIpO1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXh0dXJlU2l6ZVswXSwgdGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYHVzZXJfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgdXNlcl8ke25hbWV9U2l6ZWAsIHRleHR1cmVTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgaW5wdXRJbWFnZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGNvbnN0IGRpbSA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodCwgMV07XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodF07XG5cblx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYXJndW1lbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHRcdFx0XHRcdC8vIFVwbG9hZCB0aGUgaW1hZ2UgaW50byB0aGUgdGV4dHVyZS5cblx0XHRcdFx0XHRjb25zdCBtaXBMZXZlbCA9IDA7IC8vIHRoZSBsYXJnZXN0IG1pcFxuXHRcdFx0XHRcdGNvbnN0IGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IHdlIHdhbnQgaW4gdGhlIHRleHR1cmVcblx0XHRcdFx0XHRjb25zdCBzcmNGb3JtYXQgPSBnbC5SR0JBOyAvLyBmb3JtYXQgb2YgZGF0YSB3ZSBhcmUgc3VwcGx5aW5nXG5cdFx0XHRcdFx0Y29uc3Qgc3JjVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7IC8vIHR5cGUgb2YgZGF0YSB3ZSBhcmUgc3VwcGx5aW5nXG5cdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELFxuXHRcdFx0XHRcdFx0bWlwTGV2ZWwsXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCxcblx0XHRcdFx0XHRcdHNyY0Zvcm1hdCxcblx0XHRcdFx0XHRcdHNyY1R5cGUsXG5cdFx0XHRcdFx0XHRpbnB1dEltYWdlKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYHVzZXJfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGB1c2VyXyR7bmFtZX1TaXplYCwgc2l6ZSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYHVzZXJfJHtuYW1lfWAsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgaW5wdXRJbWFnZXMgPSB2YWx1ZTtcblx0XHRcdFx0XHRjb25zdCBkaW0gPSBbaW5wdXRJbWFnZXNbMF0ud2lkdGgsIGlucHV0SW1hZ2VzWzBdLmhlaWdodCwgaW5wdXRJbWFnZXMubGVuZ3RoXTtcblx0XHRcdFx0XHRjb25zdCBzaXplID0gW2lucHV0SW1hZ2VzWzBdLndpZHRoLCBpbnB1dEltYWdlc1swXS5oZWlnaHRdO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkRfQVJSQVksIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJEX0FSUkFZLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblx0XHRcdFx0XHQvLyBVcGxvYWQgdGhlIGltYWdlcyBpbnRvIHRoZSB0ZXh0dXJlLlxuXHRcdFx0XHRcdGNvbnN0IG1pcExldmVsID0gMDsgLy8gdGhlIGxhcmdlc3QgbWlwXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBOyAvLyBmb3JtYXQgd2Ugd2FudCBpbiB0aGUgdGV4dHVyZVxuXHRcdFx0XHRcdGNvbnN0IHdpZHRoID0gaW5wdXRJbWFnZXNbMF0ud2lkdGg7XG5cdFx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gaW5wdXRJbWFnZXNbMF0uaGVpZ2h0O1xuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVEZXB0aCA9IGlucHV0SW1hZ2VzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zdCBib3JkZXIgPSAwO1xuXHRcdFx0XHRcdGNvbnN0IHNyY0Zvcm1hdCA9IGdsLlJHQkE7IC8vIGZvcm1hdCBvZiBkYXRhIHdlIGFyZSBzdXBwbHlpbmdcblx0XHRcdFx0XHRjb25zdCBzcmNUeXBlID0gZ2wuVU5TSUdORURfQllURTsgLy8gdHlwZSBvZiBkYXRhIHdlIGFyZSBzdXBwbHlpbmdcblx0XHRcdFx0XHRnbC50ZXhJbWFnZTNEKFxuXHRcdFx0XHRcdFx0Z2wuVEVYVFVSRV8yRF9BUlJBWSxcblx0XHRcdFx0XHRcdG1pcExldmVsLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQsXG5cdFx0XHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodCxcblx0XHRcdFx0XHRcdHRleHR1cmVEZXB0aCxcblx0XHRcdFx0XHRcdGJvcmRlcixcblx0XHRcdFx0XHRcdHNyY0Zvcm1hdCxcblx0XHRcdFx0XHRcdHNyY1R5cGUsXG5cdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB4T2Zmc2V0ID0gMDtcblx0XHRcdFx0XHRcdGNvbnN0IHlPZmZzZXQgPSAwO1xuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VEZXB0aCA9IDE7XG5cdFx0XHRcdFx0XHRnbC50ZXhTdWJJbWFnZTNEKFxuXHRcdFx0XHRcdFx0XHRnbC5URVhUVVJFXzJEX0FSUkFZLFxuXHRcdFx0XHRcdFx0XHRtaXBMZXZlbCxcblx0XHRcdFx0XHRcdFx0eE9mZnNldCxcblx0XHRcdFx0XHRcdFx0eU9mZnNldCxcblx0XHRcdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRcdFx0aW5wdXRJbWFnZXNbaV0ud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGlucHV0SW1hZ2VzW2ldLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0aW1hZ2VEZXB0aCxcblx0XHRcdFx0XHRcdFx0c3JjRm9ybWF0LFxuXHRcdFx0XHRcdFx0XHRzcmNUeXBlLFxuXHRcdFx0XHRcdFx0XHRpbnB1dEltYWdlc1tpXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGB1c2VyXyR7bmFtZX1EaW1gLCBkaW0pO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgdXNlcl8ke25hbWV9U2l6ZWAsIHNpemUpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG5cdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMiknOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBpbnB1dFRleHR1cmUgPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoaW5wdXRUZXh0dXJlLmNvbnRleHQgIT09IHRoaXMuY29udGV4dCkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudCAkeyBuYW1lfSAoJHsgdHlwZSB9KSBtdXN0IGJlIGZyb20gc2FtZSBjb250ZXh0YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IGRpbSA9IGlucHV0VGV4dHVyZS5kaW1lbnNpb25zO1xuXHRcdFx0XHRcdGNvbnN0IHNpemUgPSBpbnB1dFRleHR1cmUuc2l6ZTtcblxuXHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYHVzZXJfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGB1c2VyXyR7bmFtZX1TaXplYCwgc2l6ZSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYHVzZXJfJHtuYW1lfWAsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0VGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50ICR7IG5hbWV9ICgkeyB0eXBlIH0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdihgdXNlcl8ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYHVzZXJfJHtuYW1lfVNpemVgLCBzaXplKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgdXNlcl8ke25hbWV9YCwgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGB1c2VyXyR7bmFtZX1gLCB2YWx1ZSA/IDEgOiAwKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICcgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHRoaXMuYXJndW1lbnRzTGVuZ3RoKys7XG5cdH1cblxuXHRfZ2V0TWFpbkNvbnN0YW50c1N0cmluZygpIHtcblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRpZiAodGhpcy5jb25zdGFudHMpIHtcblx0XHRcdGZvciAobGV0IG5hbWUgaW4gdGhpcy5jb25zdGFudHMpIHtcblx0XHRcdFx0aWYgKCF0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IHRoaXMuY29uc3RhbnRzW25hbWVdO1xuXHRcdFx0XHRsZXQgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSk7XG5cdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ2NvbnN0IGludCBjb25zdGFudHNfJyArIG5hbWUgKyAnID0gJyArIHBhcnNlSW50KHZhbHVlKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnY29uc3QgZmxvYXQgY29uc3RhbnRzXycgKyBuYW1lICsgJyA9ICcgKyBwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0Y2FzZSAnSW5wdXQnOlxuXHRcdFx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMiknOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY29uc3RhbnRzXyR7IG5hbWUgfWAsXG5cdFx0XHRcdFx0XHRcdGB1bmlmb3JtIGhpZ2hwIGl2ZWMyIGNvbnN0YW50c18keyBuYW1lIH1TaXplYCxcblx0XHRcdFx0XHRcdFx0YHVuaWZvcm0gaGlnaHAgaXZlYzMgY29uc3RhbnRzXyR7IG5hbWUgfURpbWAsXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0XHRcdGB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyREFycmF5IGNvbnN0YW50c18keyBuYW1lIH1gLFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBpdmVjMiBjb25zdGFudHNfJHsgbmFtZSB9U2l6ZWAsXG5cdFx0XHRcdFx0XHRcdGB1bmlmb3JtIGhpZ2hwIGl2ZWMzIGNvbnN0YW50c18keyBuYW1lIH1EaW1gLFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ2NvbnN0IGJvb2wgY29uc3RhbnRzXycgKyBuYW1lICsgJyA9ICcgKyAodmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb25zdGFudCAkeyBuYW1lIH0gdHlwZSAkeyB0eXBlIH1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEFkZHMga2VybmVsIHBhcmFtZXRlcnMgdG8gdGhlIEFyZ3VtZW50IFRleHR1cmUsXG5cdCAqIGJpbmRpbmcgaXQgdG8gdGhlIGNvbnRleHQsIGV0Yy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheXxUZXh0dXJlfE51bWJlcn0gdmFsdWUgLSBUaGUgYWN0dWFsIGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBrZXJuZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUeXBlIG9mIHRoZSBhcmd1bWVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGFyZ3VtZW50XG5cdCAqL1xuXHRhZGRDb25zdGFudCh2YWx1ZSwgdHlwZSwgbmFtZSkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuXHRcdGNvbnN0IGNvbnN0YW50VGV4dHVyZSA9IHRoaXMuZ2V0QXJndW1lbnRUZXh0dXJlKG5hbWUpO1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcblx0XHRcdHR5cGUgPSB2YWx1ZS50eXBlO1xuXHRcdH1cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdGNhc2UgJ0FycmF5KDMpJzpcblx0XHRcdGNhc2UgJ0FycmF5KDQpJzpcblx0XHRcdGNhc2UgJ0FycmF5MkQnOlxuXHRcdFx0Y2FzZSAnQXJyYXkzRCc6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBkaW0gPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcblx0XHRcdFx0XHRjb25zdCBiaXRSYXRpbyA9IHRoaXMuY29uc3RhbnRCaXRSYXRpb3NbbmFtZV07XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKGRpbSwgYml0UmF0aW8pO1xuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNvbnN0YW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gdGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSAqIGJpdFJhdGlvO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVzRmxhdCA9IHRoaXMuZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZSwgbGVuZ3RoLCBGbG9hdDMyQXJyYXkpO1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0ZXh0dXJlU2l6ZVswXSwgdGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB2YWx1ZXNGbGF0KTtcblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdihgY29uc3RhbnRzXyR7bmFtZX1EaW1gLCBkaW0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYGNvbnN0YW50c18ke25hbWV9U2l6ZWAsIHRleHR1cmVTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGBjb25zdGFudHNfJHtuYW1lfWAsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZShkaW0sIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjb25zdGFudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gdGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSAqICg0IC8gYml0UmF0aW8pO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVzRmxhdCA9IHRoaXMuZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZSwgbGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlc0ZsYXQuYnVmZmVyKTtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4dHVyZVNpemVbMF0sIHRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBidWZmZXIpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGBjb25zdGFudHNfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgY29uc3RhbnRzXyR7bmFtZX1TaXplYCwgdGV4dHVyZVNpemUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYGNvbnN0YW50c18ke25hbWV9YCwgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0ID0gdmFsdWU7XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gdXRpbHMuZ2V0RGltZW5zaW9ucyhpbnB1dCwgdHJ1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgYml0UmF0aW8gPSB0aGlzLmNvbnN0YW50Qml0UmF0aW9zW25hbWVdO1xuXHRcdFx0XHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZShkaW0sIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjb25zdGFudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlbmd0aCA9IHRleHR1cmVTaXplWzBdICogdGV4dHVyZVNpemVbMV0gKiBiaXRSYXRpbztcblx0XHRcdFx0XHRcdC8vIFRPRE86IGJldHRlciBoYW5kbGUgMTYgYW5kIDggYml0P1xuXHRcdFx0XHRcdFx0Ly8gY29uc3QgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gdGhpcy5mb3JtYXRBcnJheVRyYW5zZmVyKGlucHV0LnZhbHVlLCBsZW5ndGgsIEZsb2F0MzJBcnJheSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRleHR1cmVTaXplWzBdLCB0ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHZhbHVlc0ZsYXQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGBjb25zdGFudHNfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdihgY29uc3RhbnRzXyR7bmFtZX1TaXplYCwgdGV4dHVyZVNpemUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoYGNvbnN0YW50c18ke25hbWV9YCwgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKGRpbSwgYml0UmF0aW8pO1xuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNvbnN0YW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsZW5ndGggPSB0ZXh0dXJlU2l6ZVswXSAqIHRleHR1cmVTaXplWzFdICogKDQgLyBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZXNGbGF0ID0gdGhpcy5mb3JtYXRBcnJheVRyYW5zZmVyKGlucHV0LnZhbHVlLCBsZW5ndGgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzRmxhdC5idWZmZXIpO1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXh0dXJlU2l6ZVswXSwgdGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGBjb25zdGFudHNfJHtuYW1lfVNpemVgLCB0ZXh0dXJlU2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgY29uc3RhbnRzXyR7bmFtZX1gLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgaW5wdXRJbWFnZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGNvbnN0IGRpbSA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodCwgMV07XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodF07XG5cblx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNvbnN0YW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblx0XHRcdFx0XHQvLyBVcGxvYWQgdGhlIGltYWdlIGludG8gdGhlIHRleHR1cmUuXG5cdFx0XHRcdFx0Y29uc3QgbWlwTGV2ZWwgPSAwOyAvLyB0aGUgbGFyZ2VzdCBtaXBcblx0XHRcdFx0XHRjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7IC8vIGZvcm1hdCB3ZSB3YW50IGluIHRoZSB0ZXh0dXJlXG5cdFx0XHRcdFx0Y29uc3Qgc3JjRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdGNvbnN0IHNyY1R5cGUgPSBnbC5VTlNJR05FRF9CWVRFOyAvLyB0eXBlIG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0XHRcdG1pcExldmVsLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQsXG5cdFx0XHRcdFx0XHRzcmNGb3JtYXQsXG5cdFx0XHRcdFx0XHRzcmNUeXBlLFxuXHRcdFx0XHRcdFx0aW5wdXRJbWFnZSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KGBjb25zdGFudHNfJHtuYW1lfURpbWAsIGRpbSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KGBjb25zdGFudHNfJHtuYW1lfVNpemVgLCBzaXplKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaShgY29uc3RhbnRzXyR7bmFtZX1gLCB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ0hUTUxJbWFnZUFycmF5Jzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0SW1hZ2VzID0gdmFsdWU7XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gW2lucHV0SW1hZ2VzWzBdLndpZHRoLCBpbnB1dEltYWdlc1swXS5oZWlnaHQsIGlucHV0SW1hZ2VzLmxlbmd0aF07XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IFtpbnB1dEltYWdlc1swXS53aWR0aCwgaW5wdXRJbWFnZXNbMF0uaGVpZ2h0XTtcblxuXHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgY29uc3RhbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJEX0FSUkFZLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHRcdFx0XHRcdC8vIFVwbG9hZCB0aGUgaW1hZ2VzIGludG8gdGhlIHRleHR1cmUuXG5cdFx0XHRcdFx0Y29uc3QgbWlwTGV2ZWwgPSAwOyAvLyB0aGUgbGFyZ2VzdCBtaXBcblx0XHRcdFx0XHRjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7IC8vIGZvcm1hdCB3ZSB3YW50IGluIHRoZSB0ZXh0dXJlXG5cdFx0XHRcdFx0Y29uc3Qgd2lkdGggPSBpbnB1dEltYWdlc1swXS53aWR0aDtcblx0XHRcdFx0XHRjb25zdCBoZWlnaHQgPSBpbnB1dEltYWdlc1swXS5oZWlnaHQ7XG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZURlcHRoID0gaW5wdXRJbWFnZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnN0IGJvcmRlciA9IDA7XG5cdFx0XHRcdFx0Y29uc3Qgc3JjRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdGNvbnN0IHNyY1R5cGUgPSBnbC5VTlNJR05FRF9CWVRFOyAvLyB0eXBlIG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdGdsLnRleEltYWdlM0QoXG5cdFx0XHRcdFx0XHRnbC5URVhUVVJFXzJEX0FSUkFZLFxuXHRcdFx0XHRcdFx0bWlwTGV2ZWwsXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCxcblx0XHRcdFx0XHRcdHdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0LFxuXHRcdFx0XHRcdFx0dGV4dHVyZURlcHRoLFxuXHRcdFx0XHRcdFx0Ym9yZGVyLFxuXHRcdFx0XHRcdFx0c3JjRm9ybWF0LFxuXHRcdFx0XHRcdFx0c3JjVHlwZSxcblx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRJbWFnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHhPZmZzZXQgPSAwO1xuXHRcdFx0XHRcdFx0Y29uc3QgeU9mZnNldCA9IDA7XG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZURlcHRoID0gMTtcblx0XHRcdFx0XHRcdGdsLnRleFN1YkltYWdlM0QoXG5cdFx0XHRcdFx0XHRcdGdsLlRFWFRVUkVfMkRfQVJSQVksXG5cdFx0XHRcdFx0XHRcdG1pcExldmVsLFxuXHRcdFx0XHRcdFx0XHR4T2Zmc2V0LFxuXHRcdFx0XHRcdFx0XHR5T2Zmc2V0LFxuXHRcdFx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdFx0XHRpbnB1dEltYWdlc1tpXS53aWR0aCxcblx0XHRcdFx0XHRcdFx0aW5wdXRJbWFnZXNbaV0uaGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRpbWFnZURlcHRoLFxuXHRcdFx0XHRcdFx0XHRzcmNGb3JtYXQsXG5cdFx0XHRcdFx0XHRcdHNyY1R5cGUsXG5cdFx0XHRcdFx0XHRcdGlucHV0SW1hZ2VzW2ldXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYGNvbnN0YW50c18ke25hbWV9U2l6ZWAsIHNpemUpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGBjb25zdGFudHNfJHtuYW1lfWAsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0VGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGNvbnN0YW50ICR7IG5hbWV9ICgkeyB0eXBlIH0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYGNvbnN0YW50c18ke25hbWV9U2l6ZWAsIHNpemUpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGBjb25zdGFudHNfJHtuYW1lfWAsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0VGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGNvbnN0YW50ICR7IG5hbWV9ICgkeyB0eXBlIH0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZGltID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG5cdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoYGNvbnN0YW50c18ke25hbWV9RGltYCwgZGltKTtcblx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoYGNvbnN0YW50c18ke25hbWV9U2l6ZWAsIHNpemUpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKGBjb25zdGFudHNfJHtuYW1lfWAsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NvbnN0YW50IHR5cGUgbm90IHN1cHBvcnRlZDogJyArIHZhbHVlKTtcblx0XHR9XG5cdFx0dGhpcy5jb25zdGFudHNMZW5ndGgrKztcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAZGVzYyBHZXQgdGhlIGhlYWRlciBzdHJpbmcgZm9yIHRoZSBwcm9ncmFtLlxuXHQgKiBUaGlzIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGlmIG5vIHN1Yi1rZXJuZWxzIGFyZSBkZWZpbmVkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcblx0ICovXG5cdF9nZXRIZWFkZXJTdHJpbmcoKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEdldCB0ZXh0dXJlIGNvb3JkaW5hdGUgc3RyaW5nIGZvciB0aGUgcHJvZ3JhbVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcblx0ICovXG5cdF9nZXRUZXh0dXJlQ29vcmRpbmF0ZSgpIHtcblx0XHRjb25zdCBzdWJLZXJuZWxzID0gdGhpcy5zdWJLZXJuZWxzO1xuXHRcdGlmIChzdWJLZXJuZWxzID09PSBudWxsIHx8IHN1Yktlcm5lbHMubGVuZ3RoIDwgMSkge1xuXHRcdFx0cmV0dXJuICdpbiBoaWdocCB2ZWMyIHZUZXhDb29yZDtcXG4nO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gJ291dCBoaWdocCB2ZWMyIHZUZXhDb29yZDtcXG4nO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBHZW5lcmF0ZSB0cmFuc3BpbGVkIGdsc2wgU3RyaW5ncyBmb3IgdXNlci1kZWZpbmVkIHBhcmFtZXRlcnMgc2VudCB0byBhIGtlcm5lbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gVGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcblx0ICovXG5cdF9nZXRNYWluQXJndW1lbnRzU3RyaW5nKGFyZ3MpIHtcblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRjb25zdCBhcmd1bWVudFR5cGVzID0gdGhpcy5hcmd1bWVudFR5cGVzO1xuXHRcdGNvbnN0IGFyZ3VtZW50TmFtZXMgPSB0aGlzLmFyZ3VtZW50TmFtZXM7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGFyZ3NbaV07XG5cdFx0XHRjb25zdCBuYW1lID0gYXJndW1lbnROYW1lc1tpXTtcblx0XHRcdGNvbnN0IHR5cGUgPSBhcmd1bWVudFR5cGVzW2ldO1xuXHRcdFx0aWYgKHRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdGNhc2UgJ051bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMyknOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdFx0Y2FzZSAnSW5wdXQnOlxuXHRcdFx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdFx0XHRjb25zdCBkaW0gPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSB1dGlscy5kaW1Ub1RleFNpemUoe1xuXHRcdFx0XHRcdFx0XHRmbG9hdFRleHR1cmVzOiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG5cdFx0XHRcdFx0XHRcdGZsb2F0T3V0cHV0OiB0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZSdcblx0XHRcdFx0XHRcdH0sIGRpbSk7XG5cblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgdXNlcl8keyBuYW1lIH1gLFxuXHRcdFx0XHRcdFx0XHRgaGlnaHAgaXZlYzIgdXNlcl8keyBuYW1lIH1TaXplID0gaXZlYzIoJHsgc2l6ZVswXSB9LCAkeyBzaXplWzFdIH0pYCxcblx0XHRcdFx0XHRcdFx0YGhpZ2hwIGl2ZWMzIHVzZXJfJHsgbmFtZSB9RGltID0gaXZlYzMoJHsgZGltWzBdIH0sICR7IGRpbVsxXX0sICR7IGRpbVsyXSB9KWAsXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaChgaGlnaHAgZmxvYXQgdXNlcl8keyBuYW1lIH0gPSAkeyB2YWx1ZSB9LjBgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goYGhpZ2hwIGZsb2F0IHVzZXJfJHsgbmFtZSB9ID0gJHsgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgPyB2YWx1ZSArICcuMCcgOiB2YWx1ZSB9YCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGB1bmlmb3JtIGludCB1c2VyXyR7bmFtZX1gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHR5cGUgJHt0eXBlfSBub3Qgc3VwcG9ydGVkIGluIFdlYkdMMmApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0Y2FzZSAnTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRcdFx0Y2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcblx0XHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMiknOlxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0XHRjYXNlICdJbnB1dCc6XG5cdFx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlJzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgdXNlcl8keyBuYW1lIH1gLFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBpdmVjMiB1c2VyXyR7IG5hbWUgfVNpemVgLFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBpdmVjMyB1c2VyXyR7IG5hbWUgfURpbWBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHRcdFx0YHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEQXJyYXkgdXNlcl8keyBuYW1lIH1gLFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBpdmVjMiB1c2VyXyR7IG5hbWUgfVNpemVgLFxuXHRcdFx0XHRcdFx0XHRgdW5pZm9ybSBoaWdocCBpdmVjMyB1c2VyXyR7IG5hbWUgfURpbWBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGB1bmlmb3JtIGZsb2F0IHVzZXJfJHsgbmFtZSB9YCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGB1bmlmb3JtIGludCB1c2VyXyR7bmFtZX1gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHR5cGUgJHt0eXBlfSBub3Qgc3VwcG9ydGVkIGluIFdlYkdMMmApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IEtlcm5lbCBwcm9ncmFtIHN0cmluZyAoaW4gKmdsc2wqKSBmb3IgYSBrZXJuZWwuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuXHQgKi9cblx0Z2V0S2VybmVsU3RyaW5nKCkge1xuXHRcdGxldCBrZXJuZWxSZXN1bHREZWNsYXJhdGlvbjtcblx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0Y2FzZSAnQXJyYXkoMiknOlxuXHRcdFx0XHRrZXJuZWxSZXN1bHREZWNsYXJhdGlvbiA9ICd2ZWMyIGtlcm5lbFJlc3VsdCc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0XHRrZXJuZWxSZXN1bHREZWNsYXJhdGlvbiA9ICd2ZWMzIGtlcm5lbFJlc3VsdCc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0XHRrZXJuZWxSZXN1bHREZWNsYXJhdGlvbiA9ICd2ZWM0IGtlcm5lbFJlc3VsdCc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXInOlxuXHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRrZXJuZWxSZXN1bHREZWNsYXJhdGlvbiA9ICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGlmICh0aGlzLmdyYXBoaWNhbCkge1xuXHRcdFx0XHRcdGtlcm5lbFJlc3VsdERlY2xhcmF0aW9uID0gJ2Zsb2F0IGtlcm5lbFJlc3VsdCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgb3V0cHV0IHR5cGUgXCIkeyB0aGlzLnJldHVyblR5cGUgfVwiYCk7XG5cdFx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRjb25zdCBzdWJLZXJuZWxzID0gdGhpcy5zdWJLZXJuZWxzO1xuXHRcdGlmIChzdWJLZXJuZWxzICE9PSBudWxsKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0a2VybmVsUmVzdWx0RGVjbGFyYXRpb24sXG5cdFx0XHRcdCdsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBkYXRhMCdcblx0XHRcdCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0YGZsb2F0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfSA9IDAuMGAsXG5cdFx0XHRcdFx0YGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0J291dCB2ZWM0IGRhdGEwJyxcblx0XHRcdFx0a2VybmVsUmVzdWx0RGVjbGFyYXRpb25cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KSArIHRoaXMudHJhbnNsYXRlZFNvdXJjZTtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRHcmFwaGljYWwoKSB7XG5cdFx0cmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuXHRcdFx0JyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcblx0XHRcdCcgIGtlcm5lbCgpJyxcblx0XHRcdCcgIGRhdGEwID0gYWN0dWFsQ29sb3InLFxuXHRcdF0pO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcblx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0Y2FzZSAnTGl0ZXJhbEludGVnZXInOlxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSkgK1xuXHRcdFx0XHRcdHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBwYWNrZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgXCIke3RoaXMucmV0dXJuVHlwZX1cIiBzcGVjaWZpZWRgKTtcblx0XHR9XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHQnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuXHRcdFx0JyAga2VybmVsKCknLFxuXHRcdFx0JyAgZGF0YTAgPSBlbmNvZGUzMihrZXJuZWxSZXN1bHQpJ1xuXHRcdF07XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0YCAgZGF0YSR7aSArIDF9ID0gZW5jb2RlMzIoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0TWVtb3J5T3B0aW1pemVkRmxvYXRzKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtcblx0XHRcdCcgIGluZGV4ICo9IDQnLFxuXHRcdF07XG5cblx0XHRzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRjb25zdCBjaGFubmVscyA9IFsncicsICdnJywgJ2InLCAnYSddO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2hhbm5lbCA9IGNoYW5uZWxzW2ldO1xuXHRcdFx0XHRcdHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpO1xuXHRcdFx0XHRcdHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpO1xuXHRcdFx0XHRcdGlmIChpICsgMSA8IGNoYW5uZWxzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgaW5kZXggKz0gMScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgb3B0aW1pemVkIG91dHB1dCBvbmx5IHVzYWJsZSB3aXRoIE51bWJlcnMsICR7dGhpcy5yZXR1cm5UeXBlfSBzcGVjaWZpZWRgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcblx0XHRyZXN1bHQucHVzaChcblx0XHRcdCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG5cdFx0XHQnICBrZXJuZWwoKScsXG5cdFx0XHRgICBkYXRhMC4ke2NoYW5uZWx9ID0ga2VybmVsUmVzdWx0YCxcblx0XHQpO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdFN1Yktlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcblx0XHRpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdGAgIGRhdGEke2kgKyAxfS4ke2NoYW5uZWx9ID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YCxcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEtlcm5lbE51bWJlclRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG5cdFx0XHQnICBrZXJuZWwoKScsXG5cdFx0XHQnICBkYXRhMFswXSA9IGtlcm5lbFJlc3VsdCcsXG5cdFx0XTtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRTdWJLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0YCAgZGF0YSR7aSArIDF9WzBdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YCxcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0JyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcblx0XHRcdCcgIGtlcm5lbCgpJyxcblx0XHRcdCcgIGRhdGEwWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcblx0XHRcdCcgIGRhdGEwWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcblx0XHRdO1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5MlRleHR1cmUoKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cdFx0aWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRgICBkYXRhJHtpICsgMX1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuXHRcdFx0XHRgICBkYXRhJHtpICsgMX1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHQnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuXHRcdFx0JyAga2VybmVsKCknLFxuXHRcdFx0JyAgZGF0YTBbMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuXHRcdFx0JyAgZGF0YTBbMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuXHRcdFx0JyAgZGF0YTBbMl0gPSBrZXJuZWxSZXN1bHRbMl0nLFxuXHRcdF07XG5cdH1cblxuXHRnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuXHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdGAgIGRhdGEke2kgKyAxfVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG5cdFx0XHRcdGAgIGRhdGEke2kgKyAxfVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWAsXG5cdFx0XHRcdGAgIGRhdGEke2kgKyAxfVsyXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsyXWAsXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0Z2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG5cdFx0XHQnICBrZXJuZWwoKScsXG5cdFx0XHQnICBkYXRhMCA9IGtlcm5lbFJlc3VsdCcsXG5cdFx0XTtcblx0fVxuXG5cdGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0YCAgZGF0YSR7aSArIDF9ID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YCxcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IHRoZSBmcmFnbWVudCBzaGFkZXIgU3RyaW5nLlxuXHQgKiBJZiB0aGUgU3RyaW5nIGhhc24ndCBiZWVuIGNvbXBpbGVkIHlldCxcblx0ICogdGhlbiB0aGlzIG1ldGhvZCBjb21waWxlcyBpdCBhcyB3ZWxsXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBUaGUgYWN0dWFsIHBhcmFtZXRlcnMgc2VudCB0byB0aGUgS2VybmVsXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEZyYWdtZW50IFNoYWRlciBzdHJpbmdcblx0ICovXG5cdGdldEZyYWdtZW50U2hhZGVyKGFyZ3MpIHtcblx0XHRpZiAodGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyID0gdGhpcy5yZXBsYWNlQXJ0aWZhY3RzKHRoaXMuY29uc3RydWN0b3IuZnJhZ21lbnRTaGFkZXIsIHRoaXMuX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgR2V0IHRoZSB2ZXJ0aWNhbCBzaGFkZXIgU3RyaW5nXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBUaGUgYWN0dWFsIHBhcmFtZXRlcnMgc2VudCB0byB0aGUgS2VybmVsXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFZlcnRpY2FsIFNoYWRlciBzdHJpbmdcblx0ICpcblx0ICovXG5cdGdldFZlcnRleFNoYWRlcihhcmdzKSB7XG5cdFx0aWYgKHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXIgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jb21waWxlZFZlcnRleFNoYWRlciA9IHRoaXMuY29uc3RydWN0b3IudmVydGV4U2hhZGVyO1xuXHR9XG5cblx0ZGVzdHJveUV4dGVuc2lvbnMoKSB7XG5cdFx0dGhpcy5leHRlbnNpb25zLkVYVF9jb2xvcl9idWZmZXJfZmxvYXQgPSBudWxsO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSBudWxsO1xuXHR9XG5cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcblx0XHRqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBXZWJHTDJGdW5jdGlvbk5vZGUpLnRvSlNPTigpO1xuXHRcdHJldHVybiBqc29uO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRXZWJHTDJLZXJuZWxcbn07IiwiY29uc3QgdmVydGV4U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xucHJlY2lzaW9uIGhpZ2hwIGludDtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG5cbmluIHZlYzIgYVBvcztcbmluIHZlYzIgYVRleENvb3JkO1xuXG5vdXQgdmVjMiB2VGV4Q29vcmQ7XG51bmlmb3JtIHZlYzIgcmF0aW87XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgoYVBvcyArIHZlYzIoMSkpICogcmF0aW8gKyB2ZWMyKC0xKSwgMCwgMSk7XG4gIHZUZXhDb29yZCA9IGFUZXhDb29yZDtcbn1gO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dmVydGV4U2hhZGVyXG59OyIsImNvbnN0IGdwdU1vY2sgPSByZXF1aXJlKCdncHUtbW9jay5qcycpO1xuY29uc3Qge1xuXHR1dGlsc1xufSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHtcblx0Q1BVS2VybmVsXG59ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2NwdS9rZXJuZWwnKTtcbmNvbnN0IHtcblx0SGVhZGxlc3NHTEtlcm5lbFxufSA9IHJlcXVpcmUoJy4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWwnKTtcbmNvbnN0IHtcblx0V2ViR0wyS2VybmVsXG59ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsJyk7XG5jb25zdCB7XG5cdFdlYkdMS2VybmVsXG59ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWwnKTtcbmNvbnN0IHtcblx0a2VybmVsUnVuU2hvcnRjdXRcbn0gPSByZXF1aXJlKCcuL2tlcm5lbC1ydW4tc2hvcnRjdXQnKTtcblxuXG4vKipcbiAqXG4gKiBAdHlwZSB7S2VybmVsW119XG4gKi9cbmNvbnN0IGtlcm5lbE9yZGVyID0gW0hlYWRsZXNzR0xLZXJuZWwsIFdlYkdMMktlcm5lbCwgV2ViR0xLZXJuZWxdO1xuXG4vKipcbiAqXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbmNvbnN0IGtlcm5lbFR5cGVzID0gWydncHUnLCAnY3B1J107XG5cbmNvbnN0IGludGVybmFsS2VybmVscyA9IHtcblx0J2hlYWRsZXNzZ2wnOiBIZWFkbGVzc0dMS2VybmVsLFxuXHQnd2ViZ2wyJzogV2ViR0wyS2VybmVsLFxuXHQnd2ViZ2wnOiBXZWJHTEtlcm5lbCxcbn07XG5cbmxldCB2YWxpZGF0ZSA9IHRydWU7XG5cbi8qKlxuICogVGhlIEdQVS5qcyBsaWJyYXJ5IGNsYXNzIHdoaWNoIG1hbmFnZXMgdGhlIEdQVSBjb250ZXh0IGZvciB0aGUgY3JlYXRpbmcga2VybmVsc1xuICovXG5jbGFzcyBHUFUge1xuXHRzdGF0aWMgZGlzYWJsZVZhbGlkYXRpb24oKSB7XG5cdFx0dmFsaWRhdGUgPSBmYWxzZTtcblx0fVxuXG5cdHN0YXRpYyBlbmFibGVWYWxpZGF0aW9uKCkge1xuXHRcdHZhbGlkYXRlID0gdHJ1ZTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgaXNHUFVTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuIGtlcm5lbE9yZGVyLnNvbWUoS2VybmVsID0+IEtlcm5lbC5pc1N1cHBvcnRlZCk7XG5cdH1cblxuXHQvKipcblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGlzS2VybmVsTWFwU3VwcG9ydGVkKCkge1xuXHRcdHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQgJiYgS2VybmVsLmZlYXR1cmVzLmtlcm5lbE1hcCk7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgVFJVRSBpcyBwbGF0Zm9ybSBzdXBwb3J0cyBPZmZzY3JlZW5DYW52YXNcblx0ICovXG5cdHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykgfHwgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFRSVUUgaWYgcGxhdGZvcm0gc3VwcG9ydHMgV2ViR0xcblx0ICovXG5cdHN0YXRpYyBnZXQgaXNXZWJHTFN1cHBvcnRlZCgpIHtcblx0XHRyZXR1cm4gV2ViR0xLZXJuZWwuaXNTdXBwb3J0ZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgVFJVRSBpZiBwbGF0Zm9ybSBzdXBwb3J0cyBXZWJHTDJcblx0ICovXG5cdHN0YXRpYyBnZXQgaXNXZWJHTDJTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuIFdlYkdMMktlcm5lbC5pc1N1cHBvcnRlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBUUlVFIGlmIHBsYXRmb3JtIHN1cHBvcnRzIEhlYWRsZXNzR0xcblx0ICovXG5cdHN0YXRpYyBnZXQgaXNIZWFkbGVzc0dMU3VwcG9ydGVkKCkge1xuXHRcdHJldHVybiBIZWFkbGVzc0dMS2VybmVsLmlzU3VwcG9ydGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBkZXNjIFRSVUUgaWYgcGxhdGZvcm0gc3VwcG9ydHMgQ2FudmFzXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGlzQ2FudmFzU3VwcG9ydGVkKCkge1xuXHRcdHJldHVybiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIFRSVUUgaWYgcGxhdGZvcm0gc3VwcG9ydHMgSFRNTEltYWdlQXJyYXl9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGlzR1BVSFRNTEltYWdlQXJyYXlTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuIFdlYkdMMktlcm5lbC5pc1N1cHBvcnRlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBUUlVFIGlmIHBsYXRmb3JtIHN1cHBvcnRzIHNpbmdsZSBwcmVjaXNpb259XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGdldCBpc1NpbmdsZVByZWNpc2lvblN1cHBvcnRlZCgpIHtcblx0XHRyZXR1cm4ga2VybmVsT3JkZXIuc29tZShLZXJuZWwgPT4gS2VybmVsLmlzU3VwcG9ydGVkICYmIEtlcm5lbC5mZWF0dXJlcy5pc0Zsb2F0UmVhZCAmJiBLZXJuZWwuZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR1BVLlxuXHQgKiBAcGFyYW0ge0lHUFVTZXR0aW5nc30gW3NldHRpbmdzXSAtIFNldHRpbmdzIHRvIHNldCBtb2RlLCBhbmQgb3RoZXIgcHJvcGVydGllc1xuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcblx0XHRzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuXHRcdHRoaXMuY2FudmFzID0gc2V0dGluZ3MuY2FudmFzIHx8IG51bGw7XG5cdFx0dGhpcy5jb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dCB8fCBudWxsO1xuXHRcdHRoaXMubW9kZSA9IHNldHRpbmdzLm1vZGU7XG5cdFx0aWYgKHRoaXMubW9kZSA9PT0gJ2RldicpIHJldHVybjtcblx0XHR0aGlzLktlcm5lbCA9IG51bGw7XG5cdFx0dGhpcy5rZXJuZWxzID0gW107XG5cdFx0dGhpcy5mdW5jdGlvbnMgPSBbXTtcblx0XHR0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IFtdO1xuXHRcdHRoaXMuY2hvb3NlS2VybmVsKCk7XG5cdFx0Ly8gYWRkIGZ1bmN0aW9ucyBmcm9tIHNldHRpbmdzXG5cdFx0aWYgKHNldHRpbmdzLmZ1bmN0aW9ucykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5hZGRGdW5jdGlvbihzZXR0aW5ncy5mdW5jdGlvbnNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFkZCBuYXRpdmUgZnVuY3Rpb25zIGZyb20gc2V0dGluZ3Ncblx0XHRpZiAoc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHAgaW4gc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zKSB7XG5cdFx0XHRcdHRoaXMuYWRkTmF0aXZlRnVuY3Rpb24ocCwgc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zW3BdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hvb3NlIGtlcm5lbCB0eXBlIGFuZCBzYXZlIG9uIC5LZXJuZWwgcHJvcGVydHkgb2YgR1BVXG5cdCAqL1xuXHRjaG9vc2VLZXJuZWwoKSB7XG5cdFx0aWYgKHRoaXMuS2VybmVsKSByZXR1cm47XG5cblx0XHRsZXQgS2VybmVsID0gbnVsbDtcblxuXHRcdGlmICh0aGlzLmNvbnRleHQpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsT3JkZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgRXh0ZXJuYWxLZXJuZWwgPSBrZXJuZWxPcmRlcltpXTtcblx0XHRcdFx0aWYgKEV4dGVybmFsS2VybmVsLmlzQ29udGV4dE1hdGNoKHRoaXMuY29udGV4dCkpIHtcblx0XHRcdFx0XHRpZiAoIUV4dGVybmFsS2VybmVsLmlzU3VwcG9ydGVkKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB0eXBlICR7RXh0ZXJuYWxLZXJuZWwubmFtZX0gbm90IHN1cHBvcnRlZGApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRLZXJuZWwgPSBFeHRlcm5hbEtlcm5lbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKEtlcm5lbCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gQ29udGV4dCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5tb2RlKSB7XG5cdFx0XHRpZiAodGhpcy5tb2RlIGluIGludGVybmFsS2VybmVscykge1xuXHRcdFx0XHRpZiAoaW50ZXJuYWxLZXJuZWxzW3RoaXMubW9kZV0uaXNTdXBwb3J0ZWQpIHtcblx0XHRcdFx0XHRLZXJuZWwgPSBpbnRlcm5hbEtlcm5lbHNbdGhpcy5tb2RlXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdncHUnKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsT3JkZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoa2VybmVsT3JkZXJbaV0uaXNTdXBwb3J0ZWQpIHtcblx0XHRcdFx0XHRcdEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2NwdScpIHtcblx0XHRcdFx0S2VybmVsID0gQ1BVS2VybmVsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFLZXJuZWwpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBBIHJlcXVlc3RlZCBtb2RlIG9mIFwiJHt0aGlzLm1vZGV9XCIgYW5kIGlzIG5vdCBzdXBwb3J0ZWRgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoa2VybmVsT3JkZXJbaV0uaXNTdXBwb3J0ZWQpIHtcblx0XHRcdFx0XHRLZXJuZWwgPSBrZXJuZWxPcmRlcltpXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFLZXJuZWwpIHtcblx0XHRcdFx0S2VybmVsID0gQ1BVS2VybmVsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5tb2RlKSB7XG5cdFx0XHR0aGlzLm1vZGUgPSBLZXJuZWwubW9kZTtcblx0XHR9XG5cdFx0dGhpcy5LZXJuZWwgPSBLZXJuZWw7XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2MgVGhpcyBjcmVhdGVzIGEgY2FsbGFibGUgZnVuY3Rpb24gb2JqZWN0IHRvIGNhbGwgdGhlIGtlcm5lbCBmdW5jdGlvbiB3aXRoIHRoZSBhcmd1bWVudCBwYXJhbWV0ZXIgc2V0XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfG9iamVjdH0gc291cmNlIC0gVGhlIGNhbGxpbmcgdG8gcGVyZm9ybSB0aGUgY29udmVyc2lvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHRpbmdzXSAtIFRoZSBwYXJhbWV0ZXIgY29uZmlndXJhdGlvbiBvYmplY3Rcblx0ICogQHJldHVybnMge0tlcm5lbH0gY2FsbGFibGUgZnVuY3Rpb24gdG8gcnVuXG5cdCAqL1xuXHRjcmVhdGVLZXJuZWwoc291cmNlLCBzZXR0aW5ncykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNvdXJjZSBwYXJhbWV0ZXInKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnICYmICF1dGlscy5pc0Z1bmN0aW9uKHNvdXJjZSkgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignc291cmNlIHBhcmFtZXRlciBub3QgYSBmdW5jdGlvbicpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm1vZGUgPT09ICdkZXYnKSB7XG5cdFx0XHRyZXR1cm4gZ3B1TW9jayhzb3VyY2UsIHVwZ3JhZGVEZXByZWNhdGVkQ3JlYXRlS2VybmVsU2V0dGluZ3Moc2V0dGluZ3MpKTtcblx0XHR9XG5cblx0XHRzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nID8gc291cmNlLnRvU3RyaW5nKCkgOiBzb3VyY2U7XG5cdFx0Y29uc3QgbWVyZ2VkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdGNvbnRleHQ6IHRoaXMuY29udGV4dCxcblx0XHRcdGNhbnZhczogdGhpcy5jYW52YXMsXG5cdFx0XHRmdW5jdGlvbnM6IHRoaXMuZnVuY3Rpb25zLFxuXHRcdFx0bmF0aXZlRnVuY3Rpb25zOiB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyxcblx0XHRcdGdwdTogdGhpcyxcblx0XHRcdHZhbGlkYXRlLFxuXHRcdFx0b25SZXF1ZXN0RmFsbGJhY2s6IChhcmdzKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZhbGxiYWNrS2VybmVsID0gbmV3IENQVUtlcm5lbChzb3VyY2UsIG1lcmdlZFNldHRpbmdzKTtcblx0XHRcdFx0cmV0dXJuIGZhbGxiYWNrS2VybmVsLmFwcGx5KGZhbGxiYWNrS2VybmVsLCBhcmdzKTtcblx0XHRcdH1cblx0XHR9LCB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSB8fCB7fSk7XG5cblx0XHRjb25zdCBrZXJuZWwgPSBrZXJuZWxSdW5TaG9ydGN1dChuZXcgdGhpcy5LZXJuZWwoc291cmNlLCBtZXJnZWRTZXR0aW5ncykpO1xuXG5cdFx0Ly9pZiBjYW52YXMgZGlkbid0IGNvbWUgZnJvbSB0aGlzLCBwcm9wYWdhdGUgZnJvbSBrZXJuZWxcblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7XG5cdFx0XHR0aGlzLmNhbnZhcyA9IGtlcm5lbC5jYW52YXM7XG5cdFx0fVxuXG5cdFx0Ly9pZiBjb250ZXh0IGRpZG4ndCBjb21lIGZyb20gdGhpcywgcHJvcGFnYXRlIGZyb20ga2VybmVsXG5cdFx0aWYgKCF0aGlzLmNvbnRleHQpIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IGtlcm5lbC5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHRoaXMua2VybmVscy5wdXNoKGtlcm5lbCk7XG5cblx0XHRyZXR1cm4ga2VybmVsO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIENyZWF0ZSBhIHN1cGVyIGtlcm5lbCB3aGljaCBleGVjdXRlcyBzdWIga2VybmVsc1xuXHQgKiBhbmQgc2F2ZXMgdGhlaXIgb3V0cHV0IHRvIGJlIHVzZWQgd2l0aCB0aGUgbmV4dCBzdWIga2VybmVsLlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgd2Ugd2FudCB0byBzYXZlIHRoZSBvdXRwdXQgb24gb25lIGtlcm5lbCxcblx0ICogYW5kIHRoZW4gdXNlIGl0IGFzIGFuIGlucHV0IHRvIGFub3RoZXIga2VybmVsLiAqTWFjaGluZSBMZWFybmluZypcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHN1Yktlcm5lbHMgLSBTdWIga2VybmVscyBmb3IgdGhpcyBrZXJuZWxcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcm9vdEtlcm5lbCAtIFJvb3Qga2VybmVsXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gY2FsbGFibGUga2VybmVsIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnN0IG1lZ2FLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsTWFwKHtcblx0ICogICBhZGRSZXN1bHQ6IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG5cdCAqICAgICByZXR1cm4gYVt0aGlzLnRocmVhZC54XSArIGJbdGhpcy50aHJlYWQueF07XG5cdCAqICAgfSxcblx0ICogICBtdWx0aXBseVJlc3VsdDogZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuXHQgKiAgICAgcmV0dXJuIGFbdGhpcy50aHJlYWQueF0gKiBiW3RoaXMudGhyZWFkLnhdO1xuXHQgKiAgIH0sXG5cdCAqICB9LCBmdW5jdGlvbihhLCBiLCBjKSB7XG5cdCAqICAgICAgIHJldHVybiBtdWx0aXBseShhZGQoYSwgYiksIGMpO1xuXHQgKiB9KTtcblx0ICpcblx0ICogbWVnYUtlcm5lbChhLCBiLCBjKTtcblx0ICpcblx0ICogTm90ZTogWW91IGNhbiBhbHNvIGRlZmluZSBzdWJLZXJuZWxzIGFzIGFuIGFycmF5IG9mIGZ1bmN0aW9ucy5cblx0ICogPiBbYWRkLCBtdWx0aXBseV1cblx0ICpcblx0ICovXG5cdGNyZWF0ZUtlcm5lbE1hcCgpIHtcblx0XHRsZXQgZm47XG5cdFx0bGV0IHNldHRpbmdzO1xuXHRcdGlmICh0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAyXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Zm4gPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDJdO1xuXHRcdFx0c2V0dGluZ3MgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLktlcm5lbC5pc1N1cHBvcnRlZCB8fCAhdGhpcy5LZXJuZWwuZmVhdHVyZXMua2VybmVsTWFwKSB7XG5cdFx0XHRpZiAodGhpcy5tb2RlICYmIGtlcm5lbFR5cGVzLmluZGV4T2YodGhpcy5tb2RlKSA8IDApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBrZXJuZWxNYXAgbm90IHN1cHBvcnRlZCBvbiAke3RoaXMuS2VybmVsLm5hbWV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3Qga2VybmVsID0gdGhpcy5jcmVhdGVLZXJuZWwoZm4sIHVwZ3JhZGVEZXByZWNhdGVkQ3JlYXRlS2VybmVsU2V0dGluZ3Moc2V0dGluZ3MpKTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG5cdFx0XHRjb25zdCBmdW5jdGlvbnMgPSBhcmd1bWVudHNbMF07XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzb3VyY2UgPSBmdW5jdGlvbnNbaV0udG9TdHJpbmcoKTtcblx0XHRcdFx0Y29uc3QgbmFtZSA9IHV0aWxzLmdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoc291cmNlKTtcblx0XHRcdFx0a2VybmVsLmFkZFN1Yktlcm5lbCh7XG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRzb3VyY2UsXG5cdFx0XHRcdFx0cHJvcGVydHk6IGksXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBmdW5jdGlvbnMgPSBhcmd1bWVudHNbMF07XG5cdFx0XHRmb3IgKGxldCBwIGluIGZ1bmN0aW9ucykge1xuXHRcdFx0XHRpZiAoIWZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG5cdFx0XHRcdGNvbnN0IHNvdXJjZSA9IGZ1bmN0aW9uc1twXS50b1N0cmluZygpO1xuXHRcdFx0XHRjb25zdCBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpO1xuXHRcdFx0XHRrZXJuZWwuYWRkU3ViS2VybmVsKHtcblx0XHRcdFx0XHRuYW1lOiBuYW1lIHx8IHAsXG5cdFx0XHRcdFx0c291cmNlLFxuXHRcdFx0XHRcdHByb3BlcnR5OiBwLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ga2VybmVsO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIENvbWJpbmUgZGlmZmVyZW50IGtlcm5lbHMgaW50byBvbmUgc3VwZXIgS2VybmVsLFxuXHQgKiB1c2VmdWwgdG8gcGVyZm9ybSBtdWx0aXBsZSBvcGVyYXRpb25zIGluc2lkZSBvbmVcblx0ICoga2VybmVsIHdpdGhvdXQgdGhlIHBlbmFsdHkgb2YgZGF0YSB0cmFuc2ZlciBiZXR3ZWVuXG5cdCAqIGNwdSBhbmQgZ3B1LlxuXHQgKlxuXHQgKiBUaGUgbnVtYmVyIG9mIGtlcm5lbCBmdW5jdGlvbnMgc2VudCB0byB0aGlzIG1ldGhvZCBjYW4gYmUgdmFyaWFibGUuXG5cdCAqIFlvdSBjYW4gc2VuZCBpbiBvbmUsIHR3bywgZXRjLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJLZXJuZWxzIC0gS2VybmVsIGZ1bmN0aW9uKHMpIHRvIGNvbWJpbmUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJvb3RLZXJuZWwgLSBSb290IGtlcm5lbCB0byBjb21iaW5lIGtlcm5lbHMgaW50b1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBcdGNvbWJpbmVLZXJuZWxzKGFkZCwgbXVsdGlwbHksIGZ1bmN0aW9uKGEsYixjKXtcblx0ICpcdCBcdHJldHVybiBhZGQobXVsdGlwbHkoYSxiKSwgYylcblx0ICpcdH0pXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQ2FsbGFibGUga2VybmVsIGZ1bmN0aW9uXG5cdCAqXG5cdCAqL1xuXHRjb21iaW5lS2VybmVscygpIHtcblx0XHRjb25zdCBmaXJzdEtlcm5lbCA9IGFyZ3VtZW50c1swXTtcblx0XHRjb25zdCBjb21iaW5lZEtlcm5lbCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cdFx0aWYgKGZpcnN0S2VybmVsLmtlcm5lbC5jb25zdHJ1Y3Rvci5tb2RlID09PSAnY3B1JykgcmV0dXJuIGNvbWJpbmVkS2VybmVsO1xuXHRcdGNvbnN0IGNhbnZhcyA9IGFyZ3VtZW50c1swXS5jYW52YXM7XG5cdFx0Y29uc3QgY29udGV4dCA9IGFyZ3VtZW50c1swXS5jb250ZXh0O1xuXHRcdGNvbnN0IG1heCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcblx0XHRcdGFyZ3VtZW50c1tpXVxuXHRcdFx0XHQuc2V0Q2FudmFzKGNhbnZhcylcblx0XHRcdFx0LnNldENvbnRleHQoY29udGV4dClcblx0XHRcdFx0LnNldFBpcGVsaW5lKHRydWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IHRleHR1cmUgPSBjb21iaW5lZEtlcm5lbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYgKHRleHR1cmUudG9BcnJheSkge1xuXHRcdFx0XHRyZXR1cm4gdGV4dHVyZS50b0FycmF5KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIEFkZHMgYWRkaXRpb25hbCBmdW5jdGlvbnMsIHRoYXQgdGhlIGtlcm5lbCBtYXkgY2FsbC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IHNvdXJjZSAtIEphdmFzY3JpcHQgZnVuY3Rpb24gdG8gY29udmVydFxuXHQgKiBAcGFyYW0ge0lGdW5jdGlvblNldHRpbmdzfSBbc2V0dGluZ3NdXG5cdCAqIEByZXR1cm5zIHtHUFV9IHJldHVybnMgaXRzZWxmXG5cdCAqL1xuXHRhZGRGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzKSB7XG5cdFx0dGhpcy5mdW5jdGlvbnMucHVzaCh1dGlscy5mdW5jdGlvblRvSUZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBBZGRzIGFkZGl0aW9uYWwgbmF0aXZlIGZ1bmN0aW9ucywgdGhhdCB0aGUga2VybmVsIG1heSBjYWxsLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hdGl2ZSBmdW5jdGlvbiBuYW1lLCB1c2VkIGZvciByZXZlcnNlIGxvb2t1cFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gdGhlIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiwgYXMgaXQgd291bGQgYmUgZGVmaW5lZCBpbiBpdCdzIGVudGlyZXR5XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbc2V0dGluZ3NdXG5cdCAqIEByZXR1cm5zIHtHUFV9IHJldHVybnMgaXRzZWxmXG5cdCAqL1xuXHRhZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHNldHRpbmdzKSB7XG5cdFx0aWYgKHRoaXMua2VybmVscy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIFwiYWRkTmF0aXZlRnVuY3Rpb25cIiBhZnRlciBcImNyZWF0ZUtlcm5lbHNcIiBoYXMgYmVlbiBjYWxsZWQuJyk7XG5cdFx0fVxuXHRcdHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG5cdFx0Y29uc3Qge1xuXHRcdFx0YXJndW1lbnRUeXBlcyxcblx0XHRcdGFyZ3VtZW50TmFtZXNcblx0XHR9ID0gdGhpcy5LZXJuZWwubmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoc291cmNlKSB8fCB7fTtcblx0XHR0aGlzLm5hdGl2ZUZ1bmN0aW9ucy5wdXNoKHtcblx0XHRcdG5hbWUsXG5cdFx0XHRzb3VyY2UsXG5cdFx0XHRzZXR0aW5ncyxcblx0XHRcdGFyZ3VtZW50VHlwZXMsXG5cdFx0XHRhcmd1bWVudE5hbWVzLFxuXHRcdFx0cmV0dXJuVHlwZTogc2V0dGluZ3MucmV0dXJuVHlwZSB8fCB0aGlzLktlcm5lbC5uYXRpdmVGdW5jdGlvblJldHVyblR5cGUoc291cmNlKSxcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBEZXN0cm95cyBhbGwgbWVtb3J5IGFzc29jaWF0ZWQgd2l0aCBncHUuanMgJiB0aGUgd2ViR2wgaWYgd2UgY3JlYXRlZCBpdFxuXHQgKi9cblx0ZGVzdHJveSgpIHtcblx0XHQvLyBwZXJmb3JtIG9uIG5leHQgcnVuIGxvb3AgLSBmb3Igc29tZSByZWFzb24gd2UgZG9udCBnZXQgbG9zZSBjb250ZXh0IGV2ZW50c1xuXHRcdC8vIGlmIHdlYkdsIGlzIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCBpbiB0aGUgc2FtZSBydW4gbG9vcC5cblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMua2VybmVsc1tpXS5kZXN0cm95KHRydWUpOyAvLyByZW1vdmUgY2FudmFzIGlmIGV4aXN0c1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5rZXJuZWxzWzBdLmtlcm5lbC5jb25zdHJ1Y3Rvci5kZXN0cm95Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuXHRcdH0sIDApO1xuXHR9XG59XG5cblxuZnVuY3Rpb24gdXBncmFkZURlcHJlY2F0ZWRDcmVhdGVLZXJuZWxTZXR0aW5ncyhzZXR0aW5ncykge1xuXHRpZiAoIXNldHRpbmdzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHVwZ3JhZGVkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyk7XG5cblx0aWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdmbG9hdE91dHB1dCcpKSB7XG5cdFx0dXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnZmxvYXRPdXRwdXQnLCAncHJlY2lzaW9uJyk7XG5cdFx0dXBncmFkZWRTZXR0aW5ncy5wcmVjaXNpb24gPSBzZXR0aW5ncy5mbG9hdE91dHB1dCA/ICdzaW5nbGUnIDogJ3Vuc2lnbmVkJztcblx0fVxuXHRpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ291dHB1dFRvVGV4dHVyZScpKSB7XG5cdFx0dXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnb3V0cHV0VG9UZXh0dXJlJywgJ3BpcGVsaW5lJyk7XG5cdFx0dXBncmFkZWRTZXR0aW5ncy5waXBlbGluZSA9IEJvb2xlYW4oc2V0dGluZ3Mub3V0cHV0VG9UZXh0dXJlKTtcblx0fVxuXHRpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ291dHB1dEltbXV0YWJsZScpKSB7XG5cdFx0dXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnb3V0cHV0SW1tdXRhYmxlJywgJ2ltbXV0YWJsZScpO1xuXHRcdHVwZ3JhZGVkU2V0dGluZ3MuaW1tdXRhYmxlID0gQm9vbGVhbihzZXR0aW5ncy5vdXRwdXRJbW11dGFibGUpO1xuXHR9XG5cdGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnZmxvYXRUZXh0dXJlcycpKSB7XG5cdFx0dXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnZmxvYXRUZXh0dXJlcycsICdvcHRpbWl6ZUZsb2F0TWVtb3J5Jyk7XG5cdFx0dXBncmFkZWRTZXR0aW5ncy5vcHRpbWl6ZUZsb2F0TWVtb3J5ID0gQm9vbGVhbihzZXR0aW5ncy5mbG9hdFRleHR1cmVzKTtcblx0fVxuXHRyZXR1cm4gdXBncmFkZWRTZXR0aW5ncztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdEdQVSxcblx0a2VybmVsT3JkZXIsXG5cdGtlcm5lbFR5cGVzXG59OyIsImNvbnN0IHtcblx0R1BVXG59ID0gcmVxdWlyZSgnLi9ncHUnKTtcbmNvbnN0IHtcblx0YWxpYXNcbn0gPSByZXF1aXJlKCcuL2FsaWFzJyk7XG5jb25zdCB7XG5cdHV0aWxzXG59ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3Qge1xuXHRJbnB1dCxcblx0aW5wdXRcbn0gPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5jb25zdCB7XG5cdFRleHR1cmVcbn0gPSByZXF1aXJlKCcuL3RleHR1cmUnKTtcbmNvbnN0IHtcblx0RnVuY3Rpb25CdWlsZGVyXG59ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHtcblx0RnVuY3Rpb25Ob2RlXG59ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHtcblx0Q1BVRnVuY3Rpb25Ob2RlXG59ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2NwdS9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7XG5cdENQVUtlcm5lbFxufSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG5cbmNvbnN0IHtcblx0SGVhZGxlc3NHTEtlcm5lbFxufSA9IHJlcXVpcmUoJy4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWwnKTtcblxuY29uc3Qge1xuXHRXZWJHTEZ1bmN0aW9uTm9kZVxufSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wvZnVuY3Rpb24tbm9kZScpO1xuY29uc3Qge1xuXHRXZWJHTEtlcm5lbFxufSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG5cbmNvbnN0IHtcblx0V2ViR0wyRnVuY3Rpb25Ob2RlXG59ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbDIvZnVuY3Rpb24tbm9kZScpO1xuY29uc3Qge1xuXHRXZWJHTDJLZXJuZWxcbn0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcblxuY29uc3Qge1xuXHRHTEtlcm5lbFxufSA9IHJlcXVpcmUoJy4vYmFja2VuZC9nbC1rZXJuZWwnKTtcblxuY29uc3Qge1xuXHRLZXJuZWxcbn0gPSByZXF1aXJlKCcuL2JhY2tlbmQva2VybmVsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhbGlhcyxcblx0Q1BVRnVuY3Rpb25Ob2RlLFxuXHRDUFVLZXJuZWwsXG5cdEdQVSxcblx0RnVuY3Rpb25CdWlsZGVyLFxuXHRGdW5jdGlvbk5vZGUsXG5cdEhlYWRsZXNzR0xLZXJuZWwsXG5cdElucHV0LFxuXHRpbnB1dCxcblx0VGV4dHVyZSxcblx0dXRpbHMsXG5cdFdlYkdMMkZ1bmN0aW9uTm9kZSxcblx0V2ViR0wyS2VybmVsLFxuXHRXZWJHTEZ1bmN0aW9uTm9kZSxcblx0V2ViR0xLZXJuZWwsXG5cdEdMS2VybmVsLFxuXHRLZXJuZWwsXG59OyIsImNsYXNzIElucHV0IHtcblx0Y29uc3RydWN0b3IodmFsdWUsIHNpemUpIHtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoMyk7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuc2l6ZVtpXSA9IHNpemVbaV0gfHwgMTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHNpemUueikge1xuXHRcdFx0XHR0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54LCBzaXplLnksIHNpemUuel0pO1xuXHRcdFx0fSBlbHNlIGlmIChzaXplLnkpIHtcblx0XHRcdFx0dGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoW3NpemUueCwgc2l6ZS55LCAxXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54LCAxLCAxXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgW2gsIHcsIGRdID0gdGhpcy5zaXplO1xuXHRcdGlmICh0aGlzLnZhbHVlLmxlbmd0aCAhPT0gKGggKiB3ICogZCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9ICogJHtofSAqICR7ZH0gPSAkeyhoICogdyAqIGQpfWApO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpbnB1dCh2YWx1ZSwgc2l6ZSkge1xuXHRyZXR1cm4gbmV3IElucHV0KHZhbHVlLCBzaXplKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdElucHV0LFxuXHRpbnB1dFxufTsiLCJjb25zdCB7XG5cdHV0aWxzXG59ID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBrZXJuZWxSdW5TaG9ydGN1dChrZXJuZWwpIHtcblx0Y29uc3Qgc2hvcnRjdXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0dXRpbHNcblx0XHQuYWxsUHJvcGVydGllc09mKGtlcm5lbClcblx0XHQuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0XHRpZiAoa2V5WzBdID09PSAnXycgJiYga2V5WzFdID09PSAnXycpIHJldHVybjtcblx0XHRcdGlmICh0eXBlb2Yga2VybmVsW2tleV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKGtleS5zdWJzdHJpbmcoMCwgMykgPT09ICdhZGQnIHx8IGtleS5zdWJzdHJpbmcoMCwgMykgPT09ICdzZXQnKSB7XG5cdFx0XHRcdFx0c2hvcnRjdXRba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0a2VybmVsW2tleV0uYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNob3J0Y3V0O1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAncmVxdWVzdEZhbGxiYWNrJykge1xuXHRcdFx0XHRcdGNvbnN0IHJlcXVlc3RGYWxsYmFjayA9IGtlcm5lbFtrZXldLmJpbmQoa2VybmVsKTtcblx0XHRcdFx0XHRzaG9ydGN1dFtrZXldID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0a2VybmVsID0gcmVxdWVzdEZhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzaG9ydGN1dFtrZXldID0ga2VybmVsW2tleV0uYmluZChrZXJuZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzaG9ydGN1dC5fX2RlZmluZUdldHRlcl9fKGtleSwgKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBrZXJuZWxba2V5XTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNob3J0Y3V0Ll9fZGVmaW5lU2V0dGVyX18oa2V5LCAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRrZXJuZWxba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRzaG9ydGN1dC5rZXJuZWwgPSBrZXJuZWw7XG5cblx0cmV0dXJuIHNob3J0Y3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0a2VybmVsUnVuU2hvcnRjdXRcbn07IiwiY29uc3Qgc291cmNlID0gYFxuXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHRyaWFuZ2xlX25vaXNlX3NlZWQ7XG5oaWdocCBmbG9hdCB0cmlhbmdsZV9ub2lzZV9zaGlmdCA9IDAuMDAwMDAxO1xuXG4vL2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80dDJTRGhcbi8vbm90ZTogdW5pZm9ybWx5IGRpc3RyaWJ1dGVkLCBub3JtYWxpemVkIHJhbmQsIFswOzFbXG5mbG9hdCBucmFuZCggdmVjMiBuIClcbntcblx0cmV0dXJuIGZyYWN0KHNpbihkb3Qobi54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkqIDQzNzU4LjU0NTMpO1xufVxuLy9ub3RlOiByZW1hcHMgdiB0byBbMDsxXSBpbiBpbnRlcnZhbCBbYTtiXVxuZmxvYXQgcmVtYXAoIGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHYgKVxue1xuXHRyZXR1cm4gY2xhbXAoICh2LWEpIC8gKGItYSksIDAuMCwgMS4wICk7XG59XG5cbmZsb2F0IG40cmFuZCggdmVjMiBuIClcbntcblx0ZmxvYXQgdCA9IGZyYWN0KCB0cmlhbmdsZV9ub2lzZV9zZWVkICsgdHJpYW5nbGVfbm9pc2Vfc2hpZnQgKTtcblx0ZmxvYXQgbnJuZDAgPSBucmFuZCggbiArIDAuMDcqdCApO1xuXHRmbG9hdCBucm5kMSA9IG5yYW5kKCBuICsgMC4xMSp0ICk7XHRcblx0ZmxvYXQgbnJuZDIgPSBucmFuZCggbiArIDAuMTMqdCApO1xuXHRmbG9hdCBucm5kMyA9IG5yYW5kKCBuICsgMC4xNyp0ICk7XG5cdGZsb2F0IHJlc3VsdCA9IChucm5kMCtucm5kMStucm5kMitucm5kMykgLyA0LjA7XG5cdHRyaWFuZ2xlX25vaXNlX3NoaWZ0ID0gcmVzdWx0ICsgMC4wMDAwMDE7XG5cdHJldHVybiByZXN1bHQ7XG59YDtcblxuY29uc3QgbmFtZSA9ICd0cmlhbmdsZS1ub2lzZS1ub2lzZSc7XG5cbmNvbnN0IGZ1bmN0aW9uTWF0Y2ggPSAnTWF0aC5yYW5kb20oKSc7XG5cbmNvbnN0IGZ1bmN0aW9uUmVwbGFjZSA9ICduNHJhbmQodlRleENvb3JkKSc7XG5cbmNvbnN0IGZ1bmN0aW9uUmV0dXJuVHlwZSA9ICdOdW1iZXInO1xuXG5jb25zdCBvbkJlZm9yZVJ1biA9IChrZXJuZWwpID0+IHtcblx0a2VybmVsLnNldFVuaWZvcm0xZigndHJpYW5nbGVfbm9pc2Vfc2VlZCcsIE1hdGgucmFuZG9tKCkpO1xufTtcblxuLyoqXG4gKlxuICogQHR5cGUgSVBsdWdpblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZSxcblx0b25CZWZvcmVSdW4sXG5cdGZ1bmN0aW9uTWF0Y2gsXG5cdGZ1bmN0aW9uUmVwbGFjZSxcblx0ZnVuY3Rpb25SZXR1cm5UeXBlLFxuXHRzb3VyY2Vcbn07IiwiLyoqXG4gKiBAZGVzYyBXZWJHbCBUZXh0dXJlIGltcGxlbWVudGF0aW9uIGluIEpTXG4gKiBAcGFyYW0ge0lUZXh0dXJlU2V0dGluZ3N9IHNldHRpbmdzXG4gKi9cbmNsYXNzIFRleHR1cmUge1xuXHRjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuXHRcdGNvbnN0IHtcblx0XHRcdHRleHR1cmUsXG5cdFx0XHRzaXplLFxuXHRcdFx0ZGltZW5zaW9ucyxcblx0XHRcdG91dHB1dCxcblx0XHRcdGNvbnRleHQsXG5cdFx0XHRncHUsXG5cdFx0XHR0eXBlID0gJ051bWJlclRleHR1cmUnLFxuXHRcdH0gPSBzZXR0aW5ncztcblx0XHRpZiAoIW91dHB1dCkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcIm91dHB1dFwiIHJlcXVpcmVkLicpO1xuXHRcdGlmICghY29udGV4dCkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcImNvbnRleHRcIiByZXF1aXJlZC4nKTtcblx0XHR0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cdFx0dGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcblx0XHR0aGlzLm91dHB1dCA9IG91dHB1dDtcblx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXHRcdHRoaXMuZ3B1ID0gZ3B1O1xuXHRcdHRoaXMua2VybmVsID0gbnVsbDtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXNjIENvbnZlcnRzIHRoZSBUZXh0dXJlIGludG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuXHQgKiBAcGFyYW0ge0dQVX0gW2dwdV1cblx0ICogQHJldHVybnMge051bWJlcltdfE51bWJlcltdW118TnVtYmVyW11bXVtdfVxuXHQgKi9cblx0dG9BcnJheShncHUpIHtcblx0XHRsZXQge1xuXHRcdFx0a2VybmVsXG5cdFx0fSA9IHRoaXM7XG5cdFx0aWYgKGtlcm5lbCkgcmV0dXJuIGtlcm5lbCh0aGlzKTtcblx0XHRncHUgPSBncHUgfHwgdGhpcy5ncHU7XG5cdFx0aWYgKCFncHUpIHRocm93IG5ldyBFcnJvcignc2V0dGluZ3MgcHJvcGVydHkgXCJncHVcIiBvciBhcmd1bWVudCByZXF1aXJlZC4nKTtcblx0XHRrZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4W3RoaXMudGhyZWFkLnpdW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuXHRcdH0sIHtcblx0XHRcdG91dHB1dDogdGhpcy5vdXRwdXQsXG5cdFx0XHRwcmVjaXNpb246IHRoaXMuZ2V0UHJlY2lzaW9uKCksXG5cdFx0XHRvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLnR5cGUgPT09ICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJyxcblx0XHR9KTtcblxuXHRcdHRoaXMua2VybmVsID0ga2VybmVsO1xuXHRcdHJldHVybiBrZXJuZWwodGhpcyk7XG5cdH1cblxuXHRnZXRQcmVjaXNpb24oKSB7XG5cdFx0c3dpdGNoICh0aGlzLnR5cGUpIHtcblx0XHRcdGNhc2UgJ051bWJlclRleHR1cmUnOlxuXHRcdFx0XHRyZXR1cm4gJ3Vuc2lnbmVkJztcblx0XHRcdGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcblx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG5cdFx0XHRjYXNlICdBcnJheVRleHR1cmUoMyknOlxuXHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0cmV0dXJuICdzaW5nbGUnO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHRleHR1cmUgdHlwZScpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzYyBEZWxldGVzIHRoZSBUZXh0dXJlXG5cdCAqL1xuXHRkZWxldGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFRleHR1cmVcbn07IiwiY29uc3Qge1xuXHRJbnB1dFxufSA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IHtcblx0VGV4dHVyZVxufSA9IHJlcXVpcmUoJy4vdGV4dHVyZScpO1xuXG5jb25zdCBGVU5DVElPTl9OQU1FID0gL2Z1bmN0aW9uIChbXihdKikvO1xuY29uc3QgU1RSSVBfQ09NTUVOVFMgPSAvKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvbWc7XG5jb25zdCBBUkdVTUVOVF9OQU1FUyA9IC8oW15cXHMsXSspL2c7XG5cbi8qKlxuICpcbiAqIEBkZXNjIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgLyBzbmlwcGV0cyBvZiBjb2RlIHRoYXQgR1BVLkpTIHVzZXMgaW50ZXJuYWxseS5cbiAqIFRoaXMgY292ZXJzIHZhcmlvdXMgc25pcHBldHMgb2YgY29kZSB0aGF0IGlzIG5vdCBlbnRpcmVseSBncHUuanMgc3BlY2lmaWMgKGllLiBtYXkgZmluZCB1c2VzIGVsc2V3aGVyZSlcbiAqL1xuY29uc3QgdXRpbHMgPSB7XG5cdC8qKlxuXHQgKlxuXHQgKiBAZGVzYyBHZXRzIHRoZSBzeXN0ZW0gZW5kaWFubmVzcywgYW5kIGNhY2hlIGl0XG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9ICdMRScgb3IgJ0JFJyBkZXBlbmRpbmcgb24gc3lzdGVtIGFyY2hpdGVjdHVyZVxuXHQgKiBDcmVkaXQ6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1Rvb1RhbGxOYXRlLzQ3NTA5NTNcblx0ICovXG5cdHN5c3RlbUVuZGlhbm5lc3MoKSB7XG5cdFx0cmV0dXJuIF9zeXN0ZW1FbmRpYW5uZXNzO1xuXHR9LFxuXHRnZXRTeXN0ZW1FbmRpYW5uZXNzKCkge1xuXHRcdGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG5cdFx0Y29uc3QgYSA9IG5ldyBVaW50MzJBcnJheShiKTtcblx0XHRjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoYik7XG5cdFx0YVswXSA9IDB4ZGVhZGJlZWY7XG5cdFx0aWYgKGNbMF0gPT09IDB4ZWYpIHJldHVybiAnTEUnO1xuXHRcdGlmIChjWzBdID09PSAweGRlKSByZXR1cm4gJ0JFJztcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZW5kaWFubmVzcycpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAZGVzY1JldHVybiBUUlVFLCBvbiBhIEpTIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNPYmogLSBPYmplY3QgdG8gdmFsaWRhdGUgaWYgaXRzIGEgZnVuY3Rpb25cblx0ICogQHJldHVybnNcdHtCb29sZWFufSBUUlVFIGlmIHRoZSBvYmplY3QgaXMgYSBKUyBmdW5jdGlvblxuXHQgKi9cblx0aXNGdW5jdGlvbihmdW5jT2JqKSB7XG5cdFx0cmV0dXJuIHR5cGVvZihmdW5jT2JqKSA9PT0gJ2Z1bmN0aW9uJztcblx0fSxcblxuXHQvKipcblx0ICogQGRlc2MgUmV0dXJuIFRSVUUsIG9uIGEgdmFsaWQgSlMgZnVuY3Rpb24gc3RyaW5nXG5cdCAqIE5vdGU6IFRoaXMgZG9lcyBqdXN0IGEgVkVSWSBzaW1wbHkgc2FuaXR5IGNoZWNrLiBBbmQgbWF5IGdpdmUgZmFsc2UgcG9zaXRpdmVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZm4gLSBTdHJpbmcgb2YgSlMgZnVuY3Rpb24gdG8gdmFsaWRhdGVcblx0ICogQHJldHVybnMge0Jvb2xlYW59IFRSVUUgaWYgdGhlIHN0cmluZyBwYXNzZXMgYmFzaWMgdmFsaWRhdGlvblxuXHQgKi9cblx0aXNGdW5jdGlvblN0cmluZyhmbikge1xuXHRcdGlmICh0eXBlb2YgZm4gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gKGZuXG5cdFx0XHRcdC5zbGljZSgwLCAnZnVuY3Rpb24nLmxlbmd0aClcblx0XHRcdFx0LnRvTG93ZXJDYXNlKCkgPT09ICdmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBkZXNjIFJldHVybiB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGEgSlMgZnVuY3Rpb24gc3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jU3RyIC0gU3RyaW5nIG9mIEpTIGZ1bmN0aW9uIHRvIHZhbGlkYXRlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IEZ1bmN0aW9uIG5hbWUgc3RyaW5nIChpZiBmb3VuZClcblx0ICovXG5cdGdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoZnVuY1N0cikge1xuXHRcdHJldHVybiBGVU5DVElPTl9OQU1FLmV4ZWMoZnVuY1N0cilbMV0udHJpbSgpO1xuXHR9LFxuXG5cdGdldEZ1bmN0aW9uQm9keUZyb21TdHJpbmcoZnVuY1N0cikge1xuXHRcdHJldHVybiBmdW5jU3RyLnN1YnN0cmluZyhmdW5jU3RyLmluZGV4T2YoJ3snKSArIDEsIGZ1bmNTdHIubGFzdEluZGV4T2YoJ30nKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBkZXNjIFJldHVybiBsaXN0IG9mIGFyZ3VtZW50IG5hbWVzIGV4dHJhY3RlZCBmcm9tIGEgamF2YXNjcmlwdCBmdW5jdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZm4gLSBTdHJpbmcgb2YgSlMgZnVuY3Rpb24gdG8gdmFsaWRhdGVcblx0ICogQHJldHVybnMge1N0cmluZ1tdfSAgQXJyYXkgcmVwcmVzZW50aW5nIGFsbCB0aGUgcGFyYW1ldGVyIG5hbWVzXG5cdCAqL1xuXHRnZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhmbikge1xuXHRcdGNvbnN0IGZuU3RyID0gZm4ucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuXHRcdGxldCByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcblx0XHRpZiAocmVzdWx0ID09PSBudWxsKSB7XG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogQGRlc2MgUmV0dXJucyBhIGNsb25lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3QgdG8gY2xvbmVcblx0ICogQHJldHVybnMge09iamVjdHxBcnJheX0gQ2xvbmVkIG9iamVjdFxuXHQgKi9cblx0Y2xvbmUob2JqKSB7XG5cdFx0aWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmouaGFzT3duUHJvcGVydHkoJ2lzQWN0aXZlQ2xvbmUnKSkgcmV0dXJuIG9iajtcblxuXHRcdGNvbnN0IHRlbXAgPSBvYmouY29uc3RydWN0b3IoKTsgLy8gY2hhbmdlZFxuXG5cdFx0Zm9yIChsZXQga2V5IGluIG9iaikge1xuXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcblx0XHRcdFx0b2JqLmlzQWN0aXZlQ2xvbmUgPSBudWxsO1xuXHRcdFx0XHR0ZW1wW2tleV0gPSB1dGlscy5jbG9uZShvYmpba2V5XSk7XG5cdFx0XHRcdGRlbGV0ZSBvYmouaXNBY3RpdmVDbG9uZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGVtcDtcblx0fSxcblxuXHQvKipcblx0ICogQGRlc2MgQ2hlY2tzIGlmIGlzIGFuIGFycmF5IG9yIEFycmF5LWxpa2Ugb2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheSAtIFRoZSBhcmd1bWVudCBvYmplY3QgdG8gY2hlY2sgaWYgaXMgYXJyYXlcblx0ICogQHJldHVybnMge0Jvb2xlYW59ICB0cnVlIGlmIGlzIGFycmF5IG9yIEFycmF5LWxpa2Ugb2JqZWN0XG5cdCAqL1xuXHRpc0FycmF5KGFycmF5KSB7XG5cdFx0cmV0dXJuICFpc05hTihhcnJheS5sZW5ndGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAZGVzYyBFdmFsdWF0ZSB0aGUgYXJndW1lbnQgdHlwZSwgdG8gYXBwbHkgcmVzcGVjdGl2ZSBsb2dpYyBmb3IgaXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gVGhlIGFyZ3VtZW50IG9iamVjdCB0byBldmFsdWF0ZSB0eXBlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9ICBBcmd1bWVudCB0eXBlIEFycmF5L051bWJlci9GbG9hdC9UZXh0dXJlL1Vua25vd25cblx0ICovXG5cdGdldFZhcmlhYmxlVHlwZSh2YWx1ZSkge1xuXHRcdGlmICh1dGlscy5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0aWYgKHZhbHVlWzBdLm5vZGVOYW1lID09PSAnSU1HJykge1xuXHRcdFx0XHRyZXR1cm4gJ0hUTUxJbWFnZUFycmF5Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiAnQXJyYXknO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHRcdFx0aWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiAnSW50ZWdlcic7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ0Zsb2F0Jztcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRyZXR1cm4gJ0Jvb2xlYW4nO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUudHlwZTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW5wdXQpIHtcblx0XHRcdHJldHVybiAnSW5wdXQnO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUubm9kZU5hbWUgPT09ICdJTUcnKSB7XG5cdFx0XHRyZXR1cm4gJ0hUTUxJbWFnZSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAnVW5rbm93bic7XG5cdFx0fVxuXHR9LFxuXG5cblx0ZGltVG9UZXhTaXplKG9wdCwgZGltZW5zaW9ucywgb3V0cHV0KSB7XG5cdFx0bGV0IFt3LCBoLCBkXSA9IGRpbWVuc2lvbnM7XG5cdFx0bGV0IHRleGVsQ291bnQgPSAodyB8fCAxKSAqIChoIHx8IDEpICogKGQgfHwgMSk7XG5cblx0XHRpZiAob3B0LmZsb2F0VGV4dHVyZXMgJiYgKCFvdXRwdXQgfHwgb3B0LnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpKSB7XG5cdFx0XHR3ID0gdGV4ZWxDb3VudCA9IE1hdGguY2VpbCh0ZXhlbENvdW50IC8gNCk7XG5cdFx0fVxuXHRcdC8vIGlmIGdpdmVuIGRpbWVuc2lvbnMgPT0gYSAyZCBpbWFnZVxuXHRcdGlmIChoID4gMSAmJiB3ICogaCA9PT0gdGV4ZWxDb3VudCkge1xuXHRcdFx0cmV0dXJuIG5ldyBJbnQzMkFycmF5KFt3LCBoXSk7XG5cdFx0fVxuXHRcdHJldHVybiB1dGlscy5jbG9zZXN0U3F1YXJlRGltZW5zaW9ucyh0ZXhlbENvdW50KTtcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZURpbWVuc2lvbnN9XG5cdCAqL1xuXHRjbG9zZXN0U3F1YXJlRGltZW5zaW9ucyhsZW5ndGgpIHtcblx0XHRjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KGxlbmd0aCk7XG5cdFx0bGV0IGhpZ2ggPSBNYXRoLmNlaWwoc3FydCk7XG5cdFx0bGV0IGxvdyA9IE1hdGguZmxvb3Ioc3FydCk7XG5cdFx0d2hpbGUgKGhpZ2ggKiBsb3cgPCBsZW5ndGgpIHtcblx0XHRcdGhpZ2gtLTtcblx0XHRcdGxvdyA9IE1hdGguY2VpbChsZW5ndGggLyBoaWdoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBJbnQzMkFycmF5KFtsb3csIE1hdGguY2VpbChsZW5ndGggLyBsb3cpXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEEgdGV4dHVyZSB0YWtlcyB1cCBmb3VyXG5cdCAqIEBwYXJhbSB7T3V0cHV0RGltZW5zaW9uc30gZGltZW5zaW9uc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gYml0UmF0aW9cblx0ICogQHJldHVybnMge1RleHR1cmVEaW1lbnNpb25zfVxuXHQgKi9cblx0Z2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZShkaW1lbnNpb25zLCBiaXRSYXRpbykge1xuXHRcdGNvbnN0IFt3LCBoLCBkXSA9IGRpbWVuc2lvbnM7XG5cdFx0Y29uc3QgdG90YWxBcmVhID0gdXRpbHMucm91bmRUbygodyB8fCAxKSAqIChoIHx8IDEpICogKGQgfHwgMSksIDQpO1xuXHRcdGNvbnN0IHRleGVsQ291bnQgPSB0b3RhbEFyZWEgLyBiaXRSYXRpbztcblx0XHRyZXR1cm4gdXRpbHMuY2xvc2VzdFNxdWFyZURpbWVuc2lvbnModGV4ZWxDb3VudCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBkaW1lbnNpb25zXG5cdCAqIEBwYXJhbSBiaXRSYXRpb1xuXHQgKiBAcmV0dXJucyB7KnxUZXh0dXJlRGltZW5zaW9uc31cblx0ICovXG5cdGdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKGRpbWVuc2lvbnMsIGJpdFJhdGlvKSB7XG5cdFx0Y29uc3QgW3csIGgsIGRdID0gZGltZW5zaW9ucztcblx0XHRjb25zdCB0b3RhbEFyZWEgPSB1dGlscy5yb3VuZFRvKCh3IHx8IDEpICogKGggfHwgMSkgKiAoZCB8fCAxKSwgNCk7XG5cdFx0Y29uc3QgdGV4ZWxDb3VudCA9IHRvdGFsQXJlYSAvICg0IC8gYml0UmF0aW8pO1xuXHRcdHJldHVybiB1dGlscy5jbG9zZXN0U3F1YXJlRGltZW5zaW9ucyh0ZXhlbENvdW50KTtcblx0fSxcblxuXHRyb3VuZFRvKG4sIGQpIHtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcigobiArIGQgLSAxKSAvIGQpICogZDtcblx0fSxcblx0LyoqXG5cdCAqIEBkZXNjIFJldHVybiB0aGUgZGltZW5zaW9uIG9mIGFuIGFycmF5LlxuXHQgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xUZXh0dXJlfElucHV0fSB4IC0gVGhlIGFycmF5XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhZF0gLSBUbyBpbmNsdWRlIHBhZGRpbmcgaW4gdGhlIGRpbWVuc2lvbiBjYWxjdWxhdGlvblxuXHQgKiBAcmV0dXJucyB7T3V0cHV0RGltZW5zaW9uc31cblx0ICovXG5cdGdldERpbWVuc2lvbnMoeCwgcGFkKSB7XG5cdFx0bGV0IHJldDtcblx0XHRpZiAodXRpbHMuaXNBcnJheSh4KSkge1xuXHRcdFx0Y29uc3QgZGltID0gW107XG5cdFx0XHRsZXQgdGVtcCA9IHg7XG5cdFx0XHR3aGlsZSAodXRpbHMuaXNBcnJheSh0ZW1wKSkge1xuXHRcdFx0XHRkaW0ucHVzaCh0ZW1wLmxlbmd0aCk7XG5cdFx0XHRcdHRlbXAgPSB0ZW1wWzBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0ID0gZGltLnJldmVyc2UoKTtcblx0XHR9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG5cdFx0XHRyZXQgPSB4Lm91dHB1dDtcblx0XHR9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBJbnB1dCkge1xuXHRcdFx0cmV0ID0geC5zaXplO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGltZW5zaW9ucyBvZiAke3h9YCk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhZCkge1xuXHRcdFx0cmV0ID0gQXJyYXkuZnJvbShyZXQpO1xuXHRcdFx0d2hpbGUgKHJldC5sZW5ndGggPCAzKSB7XG5cdFx0XHRcdHJldC5wdXNoKDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgSW50MzJBcnJheShyZXQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQdXRzIGEgbmVzdGVkIDJkIGFycmF5IGludG8gYSBvbmUtZGltZW5zaW9uYWwgdGFyZ2V0IGFycmF5XG5cdCAqIEBwYXJhbSB7QXJyYXl8Kn0gYXJyYXlcblx0ICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fSB0YXJnZXRcblx0ICovXG5cdGZsYXR0ZW4yZEFycmF5VG8oYXJyYXksIHRhcmdldCkge1xuXHRcdGxldCBvZmZzZXQgPSAwO1xuXHRcdGZvciAobGV0IHkgPSAwOyB5IDwgYXJyYXkubGVuZ3RoOyB5KyspIHtcblx0XHRcdHRhcmdldC5zZXQoYXJyYXlbeV0sIG9mZnNldCk7XG5cdFx0XHRvZmZzZXQgKz0gYXJyYXlbeV0ubGVuZ3RoO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUHV0cyBhIG5lc3RlZCAzZCBhcnJheSBpbnRvIGEgb25lLWRpbWVuc2lvbmFsIHRhcmdldCBhcnJheVxuXHQgKiBAcGFyYW0ge0FycmF5fCp9IGFycmF5XG5cdCAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheX0gdGFyZ2V0XG5cdCAqL1xuXHRmbGF0dGVuM2RBcnJheVRvKGFycmF5LCB0YXJnZXQpIHtcblx0XHRsZXQgb2Zmc2V0ID0gMDtcblx0XHRmb3IgKGxldCB6ID0gMDsgeiA8IGFycmF5Lmxlbmd0aDsgeisrKSB7XG5cdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8IGFycmF5W3pdLmxlbmd0aDsgeSsrKSB7XG5cdFx0XHRcdHRhcmdldC5zZXQoYXJyYXlbel1beV0sIG9mZnNldCk7XG5cdFx0XHRcdG9mZnNldCArPSBhcnJheVt6XVt5XS5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBQdXRzIGEgbmVzdGVkIDFkLCAyZCwgb3IgM2QgYXJyYXkgaW50byBhIG9uZS1kaW1lbnNpb25hbCB0YXJnZXQgYXJyYXlcblx0ICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8VWludDE2QXJyYXl8VWludDhBcnJheX0gYXJyYXlcblx0ICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHRhcmdldFxuXHQgKi9cblx0ZmxhdHRlblRvKGFycmF5LCB0YXJnZXQpIHtcblx0XHRpZiAodXRpbHMuaXNBcnJheShhcnJheVswXSkpIHtcblx0XHRcdGlmICh1dGlscy5pc0FycmF5KGFycmF5WzBdWzBdKSkge1xuXHRcdFx0XHR1dGlscy5mbGF0dGVuM2RBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dXRpbHMuZmxhdHRlbjJkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LnNldChhcnJheSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAZGVzYyBTcGxpdHMgYW4gYXJyYXkgaW50byBzbWFsbGVyIGFycmF5cy5cblx0ICogTnVtYmVyIG9mIGVsZW1lbnRzIGluIG9uZSBzbWFsbCBjaHVuayBpcyBnaXZlbiBieSBgcGFydGBcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc3BsaXQgaW50byBjaHVua3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhcnQgLSBlbGVtZW50cyBpbiBvbmUgY2h1bmtcblx0ICpcblx0ICogQHJldHVybnMge051bWJlcltdfSBBbiBhcnJheSBvZiBzbWFsbGVyIGNodW5rc1xuXHQgKi9cblx0c3BsaXRBcnJheShhcnJheSwgcGFydCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IHBhcnQpIHtcblx0XHRcdHJlc3VsdC5wdXNoKG5ldyBhcnJheS5jb25zdHJ1Y3RvcihhcnJheS5idWZmZXIsIGkgKiA0ICsgYXJyYXkuYnl0ZU9mZnNldCwgcGFydCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdGdldEFzdFN0cmluZyhzb3VyY2UsIGFzdCkge1xuXHRcdGNvbnN0IGxpbmVzID0gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogc291cmNlLnNwbGl0KC9cXHI/XFxuL2cpO1xuXHRcdGNvbnN0IHN0YXJ0ID0gYXN0LmxvYy5zdGFydDtcblx0XHRjb25zdCBlbmQgPSBhc3QubG9jLmVuZDtcblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRyZXN1bHQucHVzaChsaW5lc1tzdGFydC5saW5lIC0gMV0uc2xpY2Uoc3RhcnQuY29sdW1uKSk7XG5cdFx0Zm9yIChsZXQgaSA9IHN0YXJ0LmxpbmU7IGkgPCBlbmQubGluZSAtIDE7IGkrKykge1xuXHRcdFx0cmVzdWx0LnB1c2gobGluZXNbaV0pO1xuXHRcdH1cblx0XHRyZXN1bHQucHVzaChsaW5lc1tlbmQubGluZSAtIDFdLnNsaWNlKDAsIGVuZC5jb2x1bW4pKTtcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJ1xcbicpO1xuXHR9LFxuXG5cdGFsbFByb3BlcnRpZXNPZihvYmopIHtcblx0XHRjb25zdCBwcm9wcyA9IFtdO1xuXG5cdFx0ZG8ge1xuXHRcdFx0cHJvcHMucHVzaC5hcHBseShwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSk7XG5cdFx0fSB3aGlsZSAob2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXG5cdFx0cmV0dXJuIHByb3BzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBsaW5lcyAtIEFuIEFycmF5IG9mIHN0cmluZ3Ncblx0ICogQHJldHVybnMge1N0cmluZ30gU2luZ2xlIGNvbWJpbmVkIFN0cmluZywgc2VwZXJhdGVkIGJ5ICpcXG4qXG5cdCAqL1xuXHRsaW5lc1RvU3RyaW5nKGxpbmVzKSB7XG5cdFx0aWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybiBsaW5lcy5qb2luKCc7XFxuJykgKyAnO1xcbic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAnXFxuJztcblx0XHR9XG5cdH0sXG5cdHdhcm5EZXByZWNhdGVkKHR5cGUsIG9sZE5hbWUsIG5ld05hbWUpIHtcblx0XHRpZiAobmV3TmFtZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBcIiR7IG5ld05hbWUgfVwiLiBGaXhpbmcsIGJ1dCBwbGVhc2UgdXBncmFkZSBhcyBpdCB3aWxsIHNvb24gYmUgcmVtb3ZlZC5gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVtb3ZlZC4gRml4aW5nLCBidXQgcGxlYXNlIHVwZ3JhZGUgYXMgaXQgd2lsbCBzb29uIGJlIHJlbW92ZWQuYCk7XG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNvdXJjZVxuXHQgKiBAcGFyYW0ge0lGdW5jdGlvblNldHRpbmdzfSBbc2V0dGluZ3NdXG5cdCAqIEByZXR1cm5zIHtJRnVuY3Rpb259XG5cdCAqL1xuXHRmdW5jdGlvblRvSUZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MpIHtcblx0XHRzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuXHRcdGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc291cmNlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBub3QgYSBzdHJpbmcgb3IgZnVuY3Rpb24nKTtcblx0XHRjb25zdCBzb3VyY2VTdHJpbmcgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNvdXJjZSA6IHNvdXJjZS50b1N0cmluZygpO1xuXG5cdFx0bGV0IGFyZ3VtZW50VHlwZXMgPSBbXTtcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHNldHRpbmdzLmFyZ3VtZW50VHlwZXMpKSB7XG5cdFx0XHRhcmd1bWVudFR5cGVzID0gc2V0dGluZ3MuYXJndW1lbnRUeXBlcztcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0YXJndW1lbnRUeXBlcyA9IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHNvdXJjZVN0cmluZylcblx0XHRcdFx0Lm1hcChuYW1lID0+IHNldHRpbmdzLmFyZ3VtZW50VHlwZXNbbmFtZV0pIHx8IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmd1bWVudFR5cGVzID0gc2V0dGluZ3MuYXJndW1lbnRUeXBlcyB8fCBbXTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c291cmNlOiBzb3VyY2VTdHJpbmcsXG5cdFx0XHRhcmd1bWVudFR5cGVzLFxuXHRcdFx0cmV0dXJuVHlwZTogc2V0dGluZ3MucmV0dXJuVHlwZSB8fCBudWxsLFxuXHRcdH07XG5cdH1cbn07XG5cbmNvbnN0IF9zeXN0ZW1FbmRpYW5uZXNzID0gdXRpbHMuZ2V0U3lzdGVtRW5kaWFubmVzcygpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dXRpbHNcbn07IiwiaW1wb3J0IHsgR1BVIH0gZnJvbSAnZ3B1LmpzJ1xuaW1wb3J0IGN1cnJ5IGZyb20gJ2Z1bi5qcy9zcmMvY3VycnknXG5pbXBvcnQgbWFwIGZyb20gJ2Z1bi5qcy9zcmMvbWFwJ1xuaW1wb3J0IGZvbGQgZnJvbSAnZnVuLmpzL3NyYy9mb2xkJ1xuaW1wb3J0IGVxdWFscyBmcm9tICdmdW4uanMvc3JjL2VxdWFscydcbmltcG9ydCBjb25jYXQgZnJvbSAndXRpbC9jb25jYXQnXG5pbXBvcnQgZW1wdHkgZnJvbSAndXRpbC9lbXB0eSdcbmltcG9ydCBkb3QgZnJvbSAndXRpbC9kb3QnXG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAndXRpbC9pZGVudGl0eSdcbmltcG9ydCB0cmFuc3Bvc2UgZnJvbSAndXRpbC90cmFuc3Bvc2UnXG5pbXBvcnQgZ2VuZXJhdGUgZnJvbSAndXRpbC9nZW5lcmF0ZSdcbmltcG9ydCBncHVtYXAgZnJvbSAndXRpbC9ncHVtYXAnXG5cbi8qKlxuICogQGNsYXNzIE1hdHJpeFxuICogQGNsYXNzZGVzYyBNYXRyaXggYXBwbGljYXRpdmUgcHJvdmlkaW5nIHN0YW5kYXJkIG1hdHJpeCBvcGVyYXRpb25zXG4gKiBAc3VtbWFyeSBUaGUgTWF0cml4IGNsYXNzIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIG5ldyBrZXl3b3JkLiBJbnN0ZWFkIHVzZSB0aGUgTWF0cml4Lm9mIHN5bnRheCB0byBjcmVhdGUgYSBuZXcgTWF0cml4LiBVbmZvcnR1bmF0bHkganNkb2NzIGRvZXMgbm90IGFsbG93IGZvciB0aGUgY29uc3RydWN0b3IgdG8gYmUgaGlkZGVuLlxuICogQGhpZGVjb250cnVjdG9yXG4gKiBAc2VlIG9mXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IG0gPSAgTWF0cml4Lm9mKFtbMSwyXSxbMiwzXSxbNCw1XV0pXG4gKlxuICovXG5sZXQgTWF0cml4ID0gZnVuY3Rpb24gKHZhbCkge1xuICB0aGlzLl9fdmFsdWUgPSB2YWxcbiAgdGhpcy5ncHUgPSBuZXcgR1BVKClcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb24gb2ZcbiAqIEBkZXNjIENyZWF0ZXMgYSBNYXRyaXggb2JqZWN0IGFuZCBmbGF0dGVucyB0aGUgTWF0cml4XG4gKiBAcGFyYW0gdmFsIHthcnJheXxmdW5jdGlvbn0gQW4gYXJyYXkgb2YgYXJyYXlzXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBtID0gIE1hdHJpeC5vZihbWzEsMl0sWzIsM10sWzQsNV1dKVxuICpcbiAqL1xuTWF0cml4Lm9mID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgTWF0cml4KSByZXR1cm4gdmFsXG4gIGlmICh0aGlzIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgdGhpcy5fX3ZhbHVlID0gdmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICByZXR1cm4gbmV3IE1hdHJpeCh2YWwpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IG0gPSAgTWF0cml4Lm9mKFtbMSwyXSxbMiwzXSxbNCw1XV0pXG4gKiBtLnR5cGUgPT09ICdNYXRyaXgnXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUudHlwZSA9ICdNYXRyaXgnXG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByZWNpc2lvblxuICogQHR5cGUge251bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgbSA9ICBNYXRyaXgub2YoW1sxLDJdLFsyLDNdLFs0LDVdXSlcbiAqIG0ucHJlY2lzaW9uID09PSA0XG4gKi9cbk1hdHJpeC5wcm90b3R5cGUucHJlY2lzaW9uID0gNFxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBzZXRQcmVjaXNpb25cbiAqIEBwYXJhbSBwcmVjaXNpb24ge251bWJlcn0gU2V0IHRoZSBudW1iZXIgb2YgZGVjaW1hbHMgZm9yIHJvdW5kaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IG0gPSAgTWF0cml4Lm9mKFtbMSwyXSxbMiwzXSxbNCw1XV0pXG4gKiBtLnNldFByZWNpc2lvbigxMClcbiAqIG0ucHJlY2lzaW9uID09PSAxMFxuICovXG5NYXRyaXgucHJvdG90eXBlLnNldFByZWNpc2lvbiA9IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb25cbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgaXNTeW1tZXRyaWNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKFtbMSwgMV0sIFsxLCAxXV0pXG4gKiB0cnVlID09PSBBLmlzU3ltbWV0cmljKClcbiAqXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuaXNTeW1tZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGEgPSB0aGlzLl9fdmFsdWVcbiAgY29uc3QgYiA9IE1hdHJpeC50cmFuc3Bvc2UodGhpcykuX192YWx1ZVxuICByZXR1cm4gZXF1YWxzKGEsIGIpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIGlzU3F1YXJlXG4gKiBAZGVzYyBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGNvbnRhaW5zIGEgc3F1YXJlIE1hdHJpeFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IEEgPSBNYXRyaXgub2YoW1sxLCAxXSwgWzEsIDFdXSlcbiAqIHRydWUgPT09IEEuaXNTcXVhcmUoKVxuICpcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5pc1NxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVxdWFscyh0aGlzLmdldENvbHMoKSwgdGhpcy5nZXRSb3dzKCkpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIGlzT3J0aG9nb25hbFxuICogQHBhcmFtIE0ge01hdHJpeHxhcnJheX1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBbWy0wLjMwOTIsIC0wLjk1MTBdLCBbLTAuOTUxMCwgMC4zMDkyXV1cbiAqIGNvbnN0IEEgPSBNYXRyaXguZnJvbUFycmF5KHJlc3VsdClcbiAqIHRydWUgID09PSBBLmlzT3J0aG9nb25hbCgpXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuaXNPcnRob2dvbmFsID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBBeEF0ID0gdGhpcy5kb3QodGhpcy50cmFuc3Bvc2UoKSlcbiAgY29uc3QgSSA9IHRoaXMuaWRlbnRpdHkoKVxuICByZXR1cm4gZXF1YWxzKEF4QXQsIEkpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIGdldENvbHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IEEgPSBNYXRyaXgub2YoW1sxLCAxXSwgWzEsIDFdXSlcbiAqIEEuZ2V0Q29scygpICA9PT0gMlxuICpcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5nZXRDb2xzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fX3ZhbHVlWzBdLmxlbmd0aFxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBlcXVhbHNcbiAqIEBwYXJhbSBNIHtNYXRyaXh8YXJyYXl9XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGEgPSBbWzEsIDFdLCBbMSwgMV1dXG4gKiB2YXIgQSA9IE1hdHJpeC5vZihhKVxuICogdmFyIEIgPSBNYXRyaXgub2YoYSlcbiAqIHRydWUgID09PSBBLmVxdWFscyhCKVxuICovXG5NYXRyaXgucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChNKSB7XG4gIHJldHVybiBlcXVhbHModGhpcy5fX3ZhbHVlLCBNLl9fdmFsdWUgfHwgTSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgZ2V0Um93c1xuICogQHJldHVybnMge051bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgQSA9IE1hdHJpeC5vZihbWzEsIDFdLCBbMSwgMV1dKVxuICogQS5nZXRSb3dzKCkgIC8vIDJcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5nZXRSb3dzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fX3ZhbHVlLmxlbmd0aFxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBnZXRTaGFwZVxuICogQHJldHVybnMge0FycmF5fVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKFtbMSwgMV0sIFsxLCAxXV0pXG4gKiBBLmdldFNoYXBlKCkgIC8vIFsyLCAyXVxuICovXG5NYXRyaXgucHJvdG90eXBlLmdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuZ2V0Um93cygpLCB0aGlzLmdldENvbHMoKV1cbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgbWFwXG4gKiBAZGVzY3JpcHRpb24gTWFwcyBvdmVyIHRoZSByb3dzIG9mIHRoZSBtYXRyaXggdXNpbmcgYSBtYXAgZnVuY3Rpb25cbiAqIEBwYXJhbSBmIHtmdW5jdGlvbn0gQW4gaXRlcmF0b3IgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IG0gPSBNYXRyaXgub2YoW1sxLCAxXSwgWzEsIDFdXSlcbiAqIG0ubWFwKHggPT4geC5tYXAoeSA9PiB5KyAxKSlcbiAqIC8vIFtbMiwgMl0sIFsyLCAyXV1cbiAqXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihtYXAoZikodGhpcy5fX3ZhbHVlKSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb24gbWFwXG4gKiBAZGVzY3JpcHRpb24gU3RhdGljIGZ1bmN0aW9uIHRoYXQgbWFwcyBvdmVyIHRoZSByb3dzIG9mIHRoZSBtYXRyaXggdXNpbmcgYSBtYXAgZnVuY3Rpb25cbiAqIEBwYXJhbSBmIHtmdW5jdGlvbn0gQW4gaXRlcmF0b3IgZnVuY3Rpb25cbiAqIEBwYXJhbSBNIHtNYXRyaXh8YXJyYXl9IE1hdHJpeCBvciBhcnJheSB0byBtYXBcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IG0gPSBNYXRyaXgubWFwKHg9ID4geC5tYXAoeSA9PiB5KyAxKSwgW1sxLCAxXSwgWzEsIDFdXSlcbiAqIC8vIFtbMiwgMl0sIFsyLCAyXV1cbiAqXG4gKi9cbk1hdHJpeC5tYXAgPSBjdXJyeShmdW5jdGlvbiAoZiwgTSkge1xuICByZXR1cm4gTWF0cml4Lm9mKE0pLm1hcChmKVxufSlcblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgbWFwXG4gKiBAZGVzY3JpcHRpb24gTWFwcyBvdmVyIHRoZSByb3dzIG9mIHRoZSBtYXRyaXggdXNpbmcgYSBtYXAgZnVuY3Rpb25cbiAqIEBwYXJhbSBmIHtmdW5jdGlvbn0gQW4gaXRlcmF0b3IgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IG0gPSBNYXRyaXgub2YoW1sxLCAxXSwgWzEsIDFdXSlcbiAqIG0ubWFwKHggPT4geC5tYXAoeSA9PiB5KyAxKSlcbiAqIC8vIFtbMiwgMl0sIFsyLCAyXV1cbiAqXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuZ3B1bWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgY29uc3QgcmVzID0gZ3B1bWFwKHRoaXMuZ3B1LCBmLCB0aGlzLl9fdmFsdWUpXG4gIHJldHVybiBNYXRyaXgub2YocmVzKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvbiBtYXBcbiAqIEBkZXNjcmlwdGlvbiBTdGF0aWMgZnVuY3Rpb24gdGhhdCBtYXBzIG92ZXIgdGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCB1c2luZyBhIG1hcCBmdW5jdGlvblxuICogQHBhcmFtIGYge2Z1bmN0aW9ufSBBbiBpdGVyYXRvciBmdW5jdGlvblxuICogQHBhcmFtIE0ge01hdHJpeHxhcnJheX0gTWF0cml4IG9yIGFycmF5IHRvIG1hcFxuICogQHJldHVybnMge01hdHJpeH1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgbSA9IE1hdHJpeC5tYXAoeD0gPiB4Lm1hcCh5ID0+IHkrIDEpLCBbWzEsIDFdLCBbMSwgMV1dKVxuICogLy8gW1syLCAyXSwgWzIsIDJdXVxuICpcbiAqL1xuTWF0cml4LmdwdW1hcCA9IGN1cnJ5KGZ1bmN0aW9uIChmLCBNKSB7XG4gIHJldHVybiBNYXRyaXgub2YoTSkuZ3B1bWFwKGYpXG59KVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBmb2xkXG4gKiBAZGVzY3JpcHRpb24gUmVkdWNlIHRoZSBtYXRyaXggcm93cyB1c2luZyBhIHJlZHVjZSBmdW5jdGlvblxuICogQHBhcmFtIGYge2Z1bmN0aW9ufSBBIHJlZHVjZS9mb2xkIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBGbGF0dGVuIE1hdHJpeFxuICogTWF0cml4Lm9mKFtbMSwgMV0sIFsxLCAxXV0pLmZvbGQoKHByZXYsIG5leHQpID0+IHByZXYuY29uY2F0KG5leHQpKVxuICogLy8gWzEsIDEsIDEsIDFdXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBNYXRyaXgub2YoZm9sZChmLCBbXSkodGhpcy5fX3ZhbHVlKSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb24gZm9sZFxuICogQGRlc2NyaXB0aW9uIFN0YXRpYyBmdW5jdGlvbiB0byByZWR1Y2UgdGhlIG1hdHJpeCByb3dzIHVzaW5nIGEgcmVkdWNlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZiB7ZnVuY3Rpb259IEEgcmVkdWNlL2ZvbGQgZnVuY3Rpb25cbiAqIEBwYXJhbSBNIHtNYXRyaXh9IFRoZSBNYXRyaXggdG8gcmVkdWNlXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICogQGV4YW1wbGVcblxuICogLy8gU3VtIG9mIGFsbCBtYXRyaXggdmFsdWVzXG4gKiBjb25zdCByZWR1Y2VyID0gKHByZXYsIG5leHQpID0+IE51bWJlcihwcmV2KSArIG5leHQucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgsIDApXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKFtbMSwgMV0sIFsxLCAxXV1cbiAqIE1hdHJpeC5mb2xkKHJlZHVjZXIsIEEpXG4gKiAvLyA0XG4gKi9cbk1hdHJpeC5mb2xkID0gY3VycnkoZnVuY3Rpb24gKGYsIE0pIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihNKS5mb2xkKGYpXG59KVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBhcFxuICogQGRlc2NyaXB0aW9uIEFwcGxpZXMgYSBNYXRyaXggdG8gYSBmdW5jdGlvblxuICogQHBhcmFtIE0ge01hdHJpeH1cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGYgPSB4ID0+IHgucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dClcbiAqIGNvbnN0IEEgPSBNYXRyaXgub2YoW1sxLCAyLCAzXSwgWzQsIDUsIDZdLCBbNywgOCwgOV1dKVxuICogTWF0cml4Lm9mKGYpLmFwKE0pXG4gKiAvLyBbWzZdLCBbMTVdLCBbMjRdXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiAoTSkge1xuICByZXR1cm4gTWF0cml4Lm9mKE0pLm1hcCh0aGlzLl9fdmFsdWUpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGFwXG4gKiBAZGVzY3JpcHRpb24gQXBwbGllcyBhIE1hdHJpeCB0byBhIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZiB7ZnVuY3Rpb259XG4gKiBAcGFyYW0gTSB7TWF0cml4fGFycmF5fVxuICogQHJldHVybnMge01hdHJpeH1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgZiA9IHggPT4geC5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0KVxuICogTWF0cml4LmFwKGYsIFtbMSwgMiwgM10sIFs0LCA1LCA2XSwgWzcsIDgsIDldXSlcbiAqIC8vIFtbNl0sIFsxNV0sIFsyNF1cbiAqL1xuTWF0cml4LmFwID0gY3VycnkoZnVuY3Rpb24gKGYsIE0pIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihmKS5hcChNKVxufSlcblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgY29uY2F0XG4gKiBAZGVzY3JpcHRpb24gQ29uY2F0ZW5hdGVzIDIgTWF0cmljZXMgdXNpbmcgYSBmdW5jdGlvbiBhcyBvcGVyYXRvclxuICogQHBhcmFtIE0ge01hdHJpeH1cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGEgPSBbWzAsIDEsIDFdLCBbMiwgMywgNF1dXG4gKiBjb25zdCBiID0gW1syLCAyLCAyXSwgWzMsIDMsIDNdXVxuICogY29uc3QgQSA9IE1hdHJpeC5vZihhKVxuICogY29uc3QgQiA9IE1hdHJpeC5vZihiKVxuICogY29uc3QgTSA9IEEuY29uY2F0KEIpXG4gKiAvLyBbWzAsIDEsIDEsIDIsIDIsIDJdLCBbMiwgMywgNCwgMywgMywgM11dXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChNLCBmID0gY29uY2F0KSB7XG4gIHJldHVybiBNYXRyaXgub2YodGhpcykubWFwKGYoTSkpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGNvbmNhdFxuICogQGRlc2NyaXB0aW9uIENvbmNhdGVuYXRlcyAyIE1hdHJpY2VzIHVzaW5nIGEgZnVuY3Rpb24gYXMgb3BlcmF0b3JcbiAqIEBwYXJhbSBBIHtNYXRyaXh9XG4gKiBAcGFyYW0gQiB7TWF0cml4fVxuICogQHJldHVybnMge01hdHJpeH1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgYSA9IFtbMCwgMSwgMV0sIFsyLCAzLCA0XV1cbiAqIGNvbnN0IGIgPSBbWzIsIDIsIDJdLCBbMywgMywgM11dXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKGEpXG4gKiBjb25zdCBCID0gTWF0cml4Lm9mKGIpXG4gKiBjb25zdCBNID0gTWF0cml4LmNvbmNhdChBLCBCKVxuICogLy8gW1swLCAxLCAxLCAyLCAyLCAyXSwgWzIsIDMsIDQsIDMsIDMsIDNdXVxuICpcbiAqL1xuTWF0cml4LmNvbmNhdCA9IGN1cnJ5KGZ1bmN0aW9uIChBLCBCLCBmID0gY29uY2F0KSB7XG4gIHJldHVybiBNYXRyaXgub2YoQSkubWFwKGYoQikpXG59KVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBlbXB0eVxuICogQGRlc2NyaXB0aW9uIFJldHVybiBhbiBlbXB0eSBNYXRyaXggZnJvbSBhbiBleGlzdGluZyBNYXRyaXhcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRyaXgub2YodGhpcykubWFwKGVtcHR5KVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvbiBlbXB0eVxuICogQGRlc2NyaXB0aW9uIFJldHVybiBhbiBlbXB0eSBNYXRyaXggZnJvbSBhbiBleGlzdGluZyBNYXRyaXhcbiAqIEBwYXJhbSByb3dzIHtudW1iZXJ9XG4gKiBAcGFyYW0gY29scyB7bnVtYmVyfVxuICogQHJldHVybnMge01hdHJpeH1cbiAqL1xuTWF0cml4LmVtcHR5ID0gY3VycnkoZnVuY3Rpb24gKHJvd3MgPSAwLCBjb2xzID0gMCkge1xuICBjb25zdCBtID0gZ2VuZXJhdGUocm93cywgY29scykgLy8gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkocm93cykpLm1hcCh4ID0+IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGNvbHMpKSlcbiAgcmV0dXJuIE1hdHJpeC5vZihtKS5tYXAoZW1wdHkpXG59KVxuXG4vLyAjIyMjICMjIyMgIyMjIyAvL1xuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBpZGVudGl0eVxuICogQGRlc2MgUmV0dXJucyBhbiBpZGVudGl0eSBtYXRyaXhcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKGEpXG4gKiBjb25zdCBBaWRlbnRpdHkgPSBBLmlkZW50aXR5KClcbiAqIC8vIFtbMSwgMCwgMF0sIFswLCAxLCAwXV1cbiAqXG4qL1xuTWF0cml4LnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihpZGVudGl0eSkuYXAodGhpcylcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb24gaWRlbnRpdHlcbiAqIEBkZXNjIFJldHVybnMgYW4gaWRlbnRpdHkgbWF0cml4XG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBBID0gTWF0cml4LmlkZW50aXR5KDMsIDIpXG4gKiAvLyBbWzEsIDAsIDBdLCBbMCwgMSwgMF1dXG4gKlxuICovXG5NYXRyaXguaWRlbnRpdHkgPSBmdW5jdGlvbiAocm93cywgY29scykge1xuICBjb25zdCBtID0gZ2VuZXJhdGUocm93cywgY29scykgLy8gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkocm93cykpLm1hcCh4ID0+IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGNvbHMpKSlcbiAgcmV0dXJuIE1hdHJpeC5vZihpZGVudGl0eSkuYXAobSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgY29tYmluZVxuICogQHNlZSBNYXRyaXguY29uY2F0XG4gKiBAcGFyYW0gTVxuICogQHJldHVybnMge01hdHJpeH1cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gKE0pIHtcbiAgcmV0dXJuIE1hdHJpeC5vZih0aGlzKS5jb25jYXQoTWF0cml4Lm9mKE0pLCBjb25jYXQpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGNvbWJpbmVcbiAqIEBzZWUgTWF0cml4LmNvbmNhdFxuICogQHBhcmFtIE1cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKi9cbk1hdHJpeC5jb21iaW5lID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihBKS5jb25jYXQoTWF0cml4Lm9mKEIpLCBjb25jYXQpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIGRvdFxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gMiBtYXRyaWNlc1xuICogQHBhcmFtIE1cbiAqIEBwYXJhbSBmXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBDcmVhdGUgbWF0cml4XG4gKiBjb25zdCBtID0gTWF0cml4Lm9mKFtbMSwgMl0sIFszLCA0XV0pXG4gKlxuICogLy8gR2VuZXJhdGUgaWRlbnRpdHkgbWF0cml4XG4gKiBjb25zdCBJICA9IG0uaWRlbnRpdHkoKSAvLyBbWzEsIDBdLCBbMCwgMV1dXG4gKlxuICogaWYobS5kb3QoSSkuZXF1YWxzKG0pKSB7XG4gKiAgICBjb25zb2xlLmxvZygnRG90IHByb2R1Y3Qgd2l0aCBpZGVudGl0eSBtYXRyaXggcmV0dXJucyB0aGUgc2FtZSBtYXRyaXgnKVxuICogfVxuICpcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAoTSkge1xuICByZXR1cm4gTWF0cml4Lm9mKHRoaXMpLmNvbmNhdChNYXRyaXgub2YoTSksIGRvdCh0aGlzLnByZWNpc2lvbikpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGRvdFxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gMiBtYXRyaWNlc1xuICogQHBhcmFtIE1cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICogY29uc3QgYSA9IFtbMSwgMiwgM10sIFs0LCA1LCA2XV1cbiAqIGNvbnN0IGIgPSBbWzcsIDhdLCBbOSwgMTBdLCBbMTEsIDEyXV1cbiAqXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKGEpXG4gKiBjb25zdCBCID0gTWF0cml4Lm9mKGIpXG4gKlxuICogTWF0cml4LmRvdChBLCBCKSAvLyBbWzU4LCA2NF0sIFsxMzksIDE1NF1dXG4gKlxuICovXG5NYXRyaXguZG90ID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihBKS5kb3QoTWF0cml4Lm9mKEIpKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBmaWxsXG4gKiBAZGVzYyBGaWxsIHVwIGFuIGVtcHR5IG1hdHJpeCB3aXRoIHRoZSBwcm92aWRlZCBtYXAgZnVuY3Rpb25cbiAqIEBwYXJhbSBmXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKFtbMSwyLDNdLCBbMywyLDFdLCBbNCw1LDZdXSkuZmlsbCh4ID0+IDQyKVxuICogLy8gW1s0Miw0Miw0Ml0sIFs0Miw0Miw0Ml0sIFs0Miw0Miw0Ml1dXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gTWF0cml4Lm9mKHRoaXMpLm1hcChtYXAoeCA9PiBmKHgpKSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgemVyb3NcbiAqIEBkZXNjIEZpbGwgdXAgYW4gZW1wdHkgbWF0cml4IHdpdGggemVyb3NcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKFtbMSwyLDNdLCBbMywyLDFdLCBbNCw1LDZdXSkuemVyb3MoKVxuICogLy8gW1swLDAsMF0sIFswLDAsMF0sIFswLDAsMF1dXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLnplcm9zID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0cml4Lm9mKHRoaXMpLmZpbGwoeCA9PiAwKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBmdW5jdGlvbiB6ZXJvc1xuICogQGRlc2MgRmlsbCB1cCBhbiBlbXB0eSBtYXRyaXggd2l0aCB6ZXJvc1xuICogQHBhcmFtIHJvd3Mge251bWJlcn0gRGVmaW5lcyB0aGUgcm93cyBvZiB0aGUgbWF0cml4XG4gKiBAcGFyYW0gY29scyB7bnVtYmVyfSBEZWZpbmVzIHRoZSBjb2x1bW5zIG9mIHRoZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IEEgPSBNYXRyaXguemVyb3MoMywgMylcbiAqIC8vIFtbMCwwLDBdLCBbMCwwLDBdLCBbMCwwLDBdXVxuICpcbiAqL1xuTWF0cml4Lnplcm9zID0gZnVuY3Rpb24gKHJvd3MsIGNvbHMpIHtcbiAgY29uc3QgbSA9IGdlbmVyYXRlKHJvd3MsIGNvbHMpXG4gIHJldHVybiBNYXRyaXgub2YobSkuZmlsbCh4ID0+IDApXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIG9uZXNcbiAqIEBkZXNjIEZpbGwgdXAgYW4gZW1wdHkgbWF0cml4IHdpdGggb25lc1xuICogQHJldHVybnMge01hdHJpeH1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgQSA9IE1hdHJpeC5vZihbWzEsMiwzXSwgWzMsMiwxXSwgWzQsNSw2XV0pLm9uZXMoKVxuICogLy8gW1sxLDEsMV0sIFsxLDEsMV0sIFsxLDEsMV1dXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRyaXgub2YodGhpcykuZmlsbCh4ID0+IDEpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGZ1bmN0aW9uIG9uZXNcbiAqIEBkZXNjIEZpbGwgdXAgYW4gZW1wdHkgbWF0cml4IHdpdGggb25lc1xuICogQHBhcmFtIHJvd3Mge251bWJlcn0gRGVmaW5lcyB0aGUgcm93cyBvZiB0aGUgbWF0cml4XG4gKiBAcGFyYW0gY29scyB7bnVtYmVyfSBEZWZpbmVzIHRoZSBjb2x1bW5zIG9mIHRoZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IEEgPSBNYXRyaXgub25lcygxLCAxKVxuICogLy8gW1sxLDEsMV0sIFsxLDEsMV0sIFsxLDEsMV1dXG4gKlxuICovXG5NYXRyaXgub25lcyA9IGZ1bmN0aW9uIChyb3dzLCBjb2xzKSB7XG4gIGNvbnN0IG0gPSBnZW5lcmF0ZShyb3dzLCBjb2xzKVxuICByZXR1cm4gTWF0cml4Lm9mKG0pLmZpbGwoeCA9PiAxKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciByYW5kb21cbiAqIEBkZXNjIEZpbGwgdXAgYW4gZW1wdHkgbWF0cml4IHdpdGggcmFuZG9tIHZhbHVlc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gW2YgPSBlID0+IE1hdGgucmFuZG9tKCkgKiAyIC0gMV1cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKi9cbk1hdHJpeC5wcm90b3R5cGUucmFuZG9tID0gZnVuY3Rpb24gKGYgPSBlID0+IE1hdGgucmFuZG9tKCkgKiAyIC0gMSkge1xuICByZXR1cm4gTWF0cml4Lm9mKHRoaXMpLmZpbGwoZilcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAZnVuY3Rpb24gcmFuZG9tXG4gKiBAZGVzYyBGaWxsIHVwIGFuIGVtcHR5IG1hdHJpeCB3aXRoIHJhbmRvbSBudW1iZXJzXG4gKiBAcGFyYW0gZiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHdoaWNoIHJldHVybnMgcmFuZG9tIHZhbHVlcy4gRGVmYXVsdCByYW5kb20gdmFsdWVzIGFyZSBiZXR3ZWVuIC0xIGFuZCAxXG4gKiBAcGFyYW0gcm93cyB7bnVtYmVyfSBEZWZpbmVzIHRoZSByb3dzIG9mIHRoZSBtYXRyaXhcbiAqIEBwYXJhbSBjb2xzIHtudW1iZXJ9IERlZmluZXMgdGhlIGNvbHVtbnMgb2YgdGhlIG1hdHJpeFxuICogQHJldHVybnMge01hdHJpeH1cbiAqL1xuTWF0cml4LnJhbmRvbSA9IGZ1bmN0aW9uIChmID0gZSA9PiAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSwgcm93cywgY29scykge1xuICBjb25zdCBtID0gZ2VuZXJhdGUocm93cywgY29scylcbiAgcmV0dXJuIE1hdHJpeC5vZihtKS5maWxsKGYpXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIHRvQXJyYXlcbiAqIEBkZXNjIFJldHVybnMgdGhlIGFycmF5IGZyb20gdGhlIG1hdHJpeFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5NYXRyaXgucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9fdmFsdWUubWFwKHJvdyA9PiByb3cubWFwKGNvbCA9PiBjb2wpKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBjbG9uZVxuICogQGRlc2MgUmV0dXJucyBhIGNsb25lIG9mIHRoZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRyaXguZnJvbUFycmF5KHRoaXMuX192YWx1ZSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgZnJvbUFycmF5XG4gKiBAZGVzYyBSZXR1cm5zIGEgTWF0cml4IGZyb20gYW4gYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuTWF0cml4LmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihtYXAocm93ID0+IG1hcChjb2wgPT4gY29sKShyb3cpKShhcnIpKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciB0cmFuc3Bvc2VcbiAqIEBkZXNjIFJldHVybnMgYSB0cmFuc3Bvc2VkIE1hdHJpeFxuICogQHJldHVybnMge01hdHJpeH1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgQSA9IE1hdHJpeC5vZihbLTEsIDJdLCBbMywgNF0sIFstOCwgMl0pXG4gKiBjb25zdCBiID0gQS50cmFuc3Bvc2UoKS50b0FycmF5KClcbiAqIC8vIHJldHVybnMgW1stMSwgMywtOF0sIFsyLCA0LCAyXV1cbiAqL1xuTWF0cml4LnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRyaXgub2YoZm9sZCh0cmFuc3Bvc2UsIFtdLCB0aGlzLl9fdmFsdWUpKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBmdW5jdGlvbiB0cmFuc3Bvc2VcbiAqIEBkZXNjIFJldHVybnMgYSB0cmFuc3Bvc2VkIE1hdHJpeFxuICogQHBhcmFtIE0ge01hdHJpeHxhcnJheX0gQSBNYXRyaXggb3IgYSBtYXRyaXggYXJyYXlcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGEgPSBbLTEsIDJdLCBbMywgNF0sIFstOCwgMl1cbiAqIGNvbnN0IGIgPSBNYXRyaXgudHJhbnNwb3NlKGEpLnRvQXJyYXkoKVxuICogLy8gcmV0dXJucyBbWy0xLCAzLC04XSwgWzIsIDQsIDJdXVxuICovXG5NYXRyaXgudHJhbnNwb3NlID0gZnVuY3Rpb24gKE0pIHtcbiAgcmV0dXJuIE1hdHJpeC5vZihNKS50cmFuc3Bvc2UoKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBtZW1iZXIgYWRkXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSBNIHtNYXRyaXh8bnVtYmVyfSBBZGQgYSBNYXRyaXggb3IgYSBudW1iZXJcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IEEgPSBNYXRyaXgub2YoW1s1LCA0XV0pXG4gKiBBLmFkZCgxKSAvLyBbWzYsIDVdXVxuICogY29uc3QgQiA9IE1hdHJpeC5vZihbWzUsIDVdXSlcbiAqIEIuYWRkKEIpIC8vIFtbMTAsIDEwXV1cbiAqXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKE0pIHtcbiAgaWYgKE0gaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICBpZiAodGhpcy5nZXRDb2xzKCkgIT09IE0uZ2V0Q29scygpIHx8IHRoaXMuZ2V0Um93cygpICE9PSBNLmdldFJvd3MoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaWNlcyBkbyBub3QgbWF0Y2gsIGNhbm5vdCBhZGQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXAoKHJvdywgaWR4KSA9PiBtYXAoKHZhbCwgamR4KSA9PiB2YWwgKyBNLl9fdmFsdWVbaWR4XVtqZHhdKShyb3cpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm1hcChtYXAoeCA9PiB4ICsgTSkpXG4gIH1cbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAbWVtYmVyIHN1YnRyYWN0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSBNIHtNYXRyaXh8bnVtYmVyfSBTdWJ0cmFjdCBhIE1hdHJpeCBvciBhIG51bWJlclxuICogQHJldHVybnMge01hdHJpeH1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgQSA9IE1hdHJpeC5vZihbWzUsIDRdXSlcbiAqIEEuc3VidHJhY3QoMSkgLy8gW1s0LCAyXV1cbiAqIGNvbnN0IEIgPSBNYXRyaXgub2YoW1s1LCA1XV0pXG4gKiBCLnN1YnRyYWN0KEIpIC8vIFtbMCwgMF1dXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKE0pIHtcbiAgaWYgKE0gaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICBpZiAodGhpcy5nZXRDb2xzKCkgIT09IE0uZ2V0Q29scygpIHx8IHRoaXMuZ2V0Um93cygpICE9PSBNLmdldFJvd3MoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaWNlcyBkbyBub3QgbWF0Y2gsIGNhbm5vdCBzdWJ0cmFjdCcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcCgocm93LCBpZHgpID0+IG1hcCgodmFsLCBqZHgpID0+IHZhbCAtIE0uX192YWx1ZVtpZHhdW2pkeF0pKHJvdykpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKG1hcCh4ID0+IHggLSBNKSlcbiAgfVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBtZW1iZXIgbXVsdGlwbHlcbiAqIEBpbnN0YW5jZVxuICogQGRlc2MgTXV0bGlwbHkgYSBzY2FsYXIgb3IgYSBtdHJhaXggd2l0aCBhIG1hdHJpeC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBtdWx0aXBsaWNhdGlvbiBpcyBub3QgcG9zc2libGUuXG4gKiBAcGFyYW0gTSB7TWF0cml4fG51bWJlcn1cbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IEEgPSBNYXRyaXgub2YoW1s1LCA0XV0pXG4gKiBBLm11bHRpcGx5KDIpIC8vIFtbMTAsIDhdXVxuICogY29uc3QgQiA9IE1hdHJpeC5vZihbWzUsIDVdXSlcbiAqIEIubXVsdGlwbHkoQikgLy8gW1syNSwgMjVdXVxuICpcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChNKSB7XG4gIGlmIChNIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgaWYgKHRoaXMuZ2V0Q29scygpICE9PSBNLmdldENvbHMoKSB8fCB0aGlzLmdldFJvd3MoKSAhPT0gTS5nZXRSb3dzKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2Ugc3RhdGljIG1ldGhvZCBcXCdkb3RcXCcgdG8gZG8gbWF0cml4IG11bHRpcGxpY2F0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cmljZXMgZG8gbm90IG1hdGNoLCBjYW5ub3QgY3JlYXRlIGhhZGFtYXJkIHByb2R1Y3QnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXAoKHJvdywgaWR4KSA9PiBtYXAoKGNvbCwgamR4KSA9PiBjb2wgKiBNLl9fdmFsdWVbaWR4XVtqZHhdKShyb3cpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm1hcChtYXAoeCA9PiB4ICogTSkpXG4gIH1cbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAbWVtYmVyIGFkZGl0aXZlaW52ZXJzZVxuICogQGluc3RhbmNlXG4gKiBAZGVzYyBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1hdHJpeCBvYnRhaW5lZCBieSBjaGFuZ2luZyB0aGUgc2lnbiBvZiBldmVyeSBtYXRyaXggZWxlbWVudC4gVGhlIGFkZGl0aXZlIGludmVyc2Ugb2YgbWF0cml4IEEgaXMgd3JpdHRlbiDigJNBLlxuICogQHJldHVybnMge01hdHJpeH1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgQSA9IE1hdHJpeC5vZihbWzUsLTVdLCBbLTQsIDRdXSlcbiAqIGNvbnN0IG1pbnVzQSA9IEEuYWRkaXRpdmVpbnZlcnNlKClcbiAqIC8vIFtbLTUsIDVdLCBbNCwgLTRdXVxuICovXG5NYXRyaXgucHJvdG90eXBlLmFkZGl0aXZlaW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdHJpeC5vZih0aGlzKS5tdWx0aXBseSgtMSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAbWVtYmVyIGhhZGFtYXJkXG4gKiBAaW5zdGFuY2VcbiAqIEBzZWUgbXVsdGlwbHlcbiAqIEBwYXJhbSBNXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKFtbNSwgNF1dKVxuICogQS5oYWRhbWFyZCgyKSAvLyBbWzEwLCA4XV1cbiAqIGNvbnN0IEIgPSBNYXRyaXgub2YoW1s1LCA1XV0pXG4gKiBCLmhhZGFtYXJkKEIpIC8vIFtbMjUsIDI1XV1cblxuICovXG5NYXRyaXgucHJvdG90eXBlLmhhZGFtYXJkID0gZnVuY3Rpb24gKE0pIHtcbiAgcmV0dXJuIE1hdHJpeC5vZih0aGlzKS5tdWx0aXBseShNKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBsdVxuICogQGRlc2MgQ2FsY3VsYXRlcyBMVSBkZWNvbXBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IE1hdHJpeFxuICogQHJldHVybnMge01hdHJpeFtdfVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBbWzMsIC03LCAtMiwgMl0sIFstMywgNSwgMSwgMF0sIFs2LCAtNCwgMCwgLTVdLCBbLTksIDUsIC01LCAxMl1dXG4gKiBjb25zdCBBID0gTWF0cml4LmZyb21BcnJheShyZXN1bHQpXG4gKiBjb25zdCBsdSA9IEEubHUoKVxuICogLy8gTC5fX3ZhbHVlID0gWyBbIDEsIDAsIDAsIDAgXSwgWyAtMSwgMSwgMCwgMCBdLCBbIDIsIC01LCAxLCAwIF0sIFsgLTMsIDgsIDMsIDEgXSBdXG4gKiAvLyBVLl9fdmFsdWUgPSAgWyBbIDMsIC03LCAtMiwgMiBdLCBbIDAsIC0yLCAtMSwgMiBdLCBbIDAsIDAsIC0xLCAxIF0sIFsgMCwgMCwgMCwgLTEgXSBdXG4gKiBNYXRyaXguZG90KGx1WzBdLCBsdVsxXSkgLy8gcmV0dXJucyBjbG9uZSBvZiBBXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLmx1ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBuID0gdGhpcy5nZXRSb3dzKClcbiAgY29uc3QgdG9sID0gMWUtNlxuICBjb25zdCBBID0gdGhpcy5jbG9uZSgpXG4gIGNvbnN0IEwgPSB0aGlzLnplcm9zKClcbiAgY29uc3QgVSA9IHRoaXMuemVyb3MoKVxuXG4gIGZvciAobGV0IGsgPSAwOyBrIDwgbjsgKytrKSB7XG4gICAgaWYgKE1hdGguYWJzKEEuX192YWx1ZVtrXVtrXSkgPCB0b2wpIHRocm93IEVycm9yKCdDYW5ub3QgcHJvY2VlZCB3aXRob3V0IGEgcm93IGV4Y2hhbmdlJylcbiAgICBMLl9fdmFsdWVba11ba10gPSAxXG4gICAgZm9yIChsZXQgaSA9IGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBMLl9fdmFsdWVbaV1ba10gPSBBLl9fdmFsdWVbaV1ba10gLyBBLl9fdmFsdWVba11ba11cbiAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IG47ICsraikge1xuICAgICAgICBBLl9fdmFsdWVbaV1bal0gPSBBLl9fdmFsdWVbaV1bal0gLSBMLl9fdmFsdWVbaV1ba10gKiBBLl9fdmFsdWVba11bal1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgbCA9IGs7IGwgPCBuOyArK2wpIHtcbiAgICAgIFUuX192YWx1ZVtrXVtsXSA9IEEuX192YWx1ZVtrXVtsXVxuICAgIH1cbiAgfVxuICByZXR1cm4gW0wsIFVdXG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIHJyZWZcbiAqIEByZXR1cm5zIHtNYXRyaXh8YXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBBID0gTWF0cml4Lm9mKFtbLTEsIDFdLCBbLTEsIDBdLCBbMCwgLTFdLCBbLTEsIC0yXV0pXG4gKiBBLnJyZWYoKSAvLyAgWyBbIDEsIDAgXSwgWyAtMCwgMSBdLCBbIDAsIDAgXSwgWyAwLCAwIF0gXVxuICovXG5NYXRyaXgucHJvdG90eXBlLnJyZWYgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBsZWFkID0gMFxuICBjb25zdCByZXN1bHRNYXRyaXggPSB0aGlzLmNsb25lKClcblxuICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMuZ2V0Um93cygpOyArK3IpIHtcbiAgICBpZiAodGhpcy5nZXRDb2xzKCkgPD0gbGVhZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdE1hdHJpeFxuICAgIH1cbiAgICBsZXQgaSA9IHJcbiAgICB3aGlsZSAocmVzdWx0TWF0cml4Ll9fdmFsdWVbaV1bbGVhZF0gPT09IDApIHtcbiAgICAgICsraVxuICAgICAgaWYgKHRoaXMuZ2V0Um93cygpID09PSBpKSB7XG4gICAgICAgIGkgPSByXG4gICAgICAgICsrbGVhZFxuICAgICAgICBpZiAodGhpcy5nZXRDb2xzKCkgPT09IGxlYWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0TWF0cml4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdG1wID0gcmVzdWx0TWF0cml4Ll9fdmFsdWVbaV1cbiAgICByZXN1bHRNYXRyaXguX192YWx1ZVtpXSA9IHJlc3VsdE1hdHJpeC5fX3ZhbHVlW3JdXG4gICAgcmVzdWx0TWF0cml4Ll9fdmFsdWVbcl0gPSB0bXBcblxuICAgIGxldCB2YWwgPSByZXN1bHRNYXRyaXguX192YWx1ZVtyXVtsZWFkXVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5nZXRDb2xzKCk7ICsraikge1xuICAgICAgcmVzdWx0TWF0cml4Ll9fdmFsdWVbcl1bal0gLz0gdmFsXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdldFJvd3MoKTsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gcikgY29udGludWVcbiAgICAgIHZhbCA9IHJlc3VsdE1hdHJpeC5fX3ZhbHVlW2ldW2xlYWRdXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuZ2V0Q29scygpOyArK2opIHtcbiAgICAgICAgcmVzdWx0TWF0cml4Ll9fdmFsdWVbaV1bal0gLT0gdmFsICogcmVzdWx0TWF0cml4Ll9fdmFsdWVbcl1bal1cbiAgICAgIH1cbiAgICB9XG4gICAgbGVhZCsrXG4gIH1cbiAgcmV0dXJuIHJlc3VsdE1hdHJpeFxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlciBzb2x2ZVxuICogQHBhcmFtIGJcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU29sdmUgeEEgPSBiXG4gKiAvLyA1eCArIHkgID0gN1xuICogLy8gM3ggLSA0eSA9IDE4XG4gKiAvLyBTb2x1dGlvbiBmb3IgeCBhbmQgeTpcbiAqIC8vIHggPSAyXG4gKiAvLyB5ID0gLTNcbiAqXG4gKiBjb25zdCBBID0gTWF0cml4Lm9mKFtbNSwgMV0sIFszLCAtNF1dKVxuICogY29uc3Qgc29sdmVBID0gQS5zb2x2ZShbNywgMThdKSAvLyBbMiwgLTNdXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKGIpIHtcbiAgY29uc3QgQSA9IHRoaXMuY2xvbmUoKVxuICBjb25zdCBMVSA9IEEubHUoKVxuICBjb25zdCBMID0gTFVbMF1cbiAgY29uc3QgVSA9IExVWzFdXG4gIGNvbnN0IG4gPSB0aGlzLmdldFJvd3MoKVxuICBsZXQgcyA9IDBcbiAgY29uc3QgYyA9IFtdXG4gIGNvbnN0IHggPSBbXVxuXG4gIGZvciAobGV0IGsgPSAwOyBrIDwgbjsgKytrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBrOyArK2opIHtcbiAgICAgIHMgPSBzICsgTC5fX3ZhbHVlW2tdW2pdICogY1tqXVxuICAgIH1cbiAgICBjW2tdID0gYltrXSAtIHNcbiAgICBzID0gMFxuICB9XG4gIGZvciAobGV0IGEgPSBuIC0gMTsgYSA+IC0xOyAtLWEpIHtcbiAgICBsZXQgdCA9IDBcbiAgICBmb3IgKGxldCBiID0gYSArIDE7IGIgPCBuOyArK2IpIHtcbiAgICAgIHQgPSB0ICsgVS5fX3ZhbHVlW2FdW2JdICogeFtiXVxuICAgIH1cbiAgICB4W2FdID0gKGNbYV0gLSB0KSAvIFUuX192YWx1ZVthXVthXVxuICB9XG4gIHJldHVybiB4XG59XG5cbi8qKlxuICogQG1lbWJlck9mIE1hdHJpeFxuICogQG1lbWJlciBpbnZlcnNlXG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IEEgPSBNYXRyaXgub2YoW1sxLCAxXSwgWzIsIDRdXSkuaW52ZXJzZSgpXG4gKiAvLyBbIFsgMiwgLTAuNSBdLCBbIC0xLCAwLjUgXSBdXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IEEgPSB0aGlzLmNsb25lKClcbiAgY29uc3QgSSA9IEEuaWRlbnRpdHkoKVxuICBjb25zdCBJbnYgPSBBLmNvbmNhdChJKS5ycmVmKClcblxuICBjb25zdCByZXN1bHQgPSBJbnYuX192YWx1ZS5yZWR1Y2UoKHJlc3VsdCwgeCwgaWR4KSA9PiB7XG4gICAgY29uc3QgaGFsZiA9IHgubGVuZ3RoIC8gMlxuICAgIHJlc3VsdC5wdXNoKHguc2xpY2UoaGFsZiwgeC5sZW5ndGgpKVxuICAgIHJldHVybiByZXN1bHRcbiAgfSwgW10pXG4gIHJldHVybiBNYXRyaXgub2YocmVzdWx0KVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBtZW1iZXIgcmFua1xuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5NYXRyaXgucHJvdG90eXBlLnJhbmsgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHJyZWYgPSB0aGlzLnJyZWYoKVxuICBsZXQgcmVzdWx0ID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJyZWYuZ2V0Q29scygpOyArK2kpIHtcbiAgICByZXN1bHQgKz0gcnJlZi5fX3ZhbHVlW2ldW2ldXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBtZW1iZXIgZGltZW5zaW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBzZWUgcmFua1xuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJhbmsoKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBtZW1iZXIgZGlhZ1xuICogQGluc3RhbmNlXG4gKiBAZGVzYyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvbiB0aGUgZGlhZ29uYWxcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgZGlhZzEgPSBNYXRyaXgub25lcygzLCAzKS5kaWFnKClcbiAqIC8vIFsxLCAxLCAxXVxuICpcbiAqIGNvbnN0IGRpYWcwID0gTWF0cml4Lnplcm9zKDUsIDUpLmRpYWcoKVxuICogLy8gWzAsIDAsIDAsIDAsIDBdXG4gKlxuICovXG5NYXRyaXgucHJvdG90eXBlLmRpYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmb2xkKChhY2MsIHgsIGlkeCkgPT4ge1xuICAgIHJldHVybiBhY2MuY29uY2F0KHhbaWR4XSlcbiAgfSkoW10pKHRoaXMuX192YWx1ZSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAZnVuY3Rpb24gZGlhZ1xuICogQGRlc2MgUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgb24gdGhlIGRpYWdvbmFsXG4gKiBAcGFyYW0gTSB7TWF0cml4fEFycmF5fSBNYXRyaXggZnJvbSB3aGljaCB0byByZXR1cm4gdGhlIGRpYWdvbmFsXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGRpYWcxID0gTWF0cml4LmRpYWcoW1syLCAxXSwgWzEsIDVdXSlcbiAqIC8vIFsyLCA1XVxuICpcbiAqL1xuTWF0cml4LmRpYWcgPSBmdW5jdGlvbiAoTSkge1xuICByZXR1cm4gTWF0cml4Lm9mKE0pLmRpYWcoKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBtZW1iZXIgZGlhZ3Byb2R1Y3RcbiAqIEBpbnN0YW5jZVxuICogQGRlc2MgUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGUgdmFsdWVzIG9uIHRoZSBkaWFnb25hbFxuICogQHJldHVybnMge051bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgZGlhZzEgPSBNYXRyaXgub25lcygzLCAzKS5kaWFncHJvZHVjdCgpXG4gKiAvLyAxXG4gKlxuICogY29uc3QgZGlhZzAgPSBNYXRyaXguemVyb3MoNSwgNSkuZGlhZ3Byb2R1Y3QoKVxuICogLy8gMFxuICpcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5kaWFncHJvZHVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZvbGQoKGFjYywgeCwgaWR4KSA9PiB7XG4gICAgYWNjICo9IHhbaWR4XVxuICAgIHJldHVybiBhY2NcbiAgfSkoMSkodGhpcy5fX3ZhbHVlKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBmdW5jdGlvbiBkaWFncHJvZHVjdFxuICogQGRlc2MgUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGUgdmFsdWVzIG9uIHRoZSBkaWFnb25hbFxuICogQHBhcmFtIE0ge01hdHJpeHxBcnJheX0gTWF0cml4IGZyb20gd2hpY2ggdG8gcmV0dXJuIHRoZSBkaWFnb25hbFxuICogQHJldHVybnMge051bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgZGlhZzEgPSBNYXRyaXguZGlhZ3Byb2R1Y3QoW1syLCAxXSwgWzEsIDVdXSlcbiAqIC8vIDEwXG4gKlxuICovXG5NYXRyaXguZGlhZ3Byb2R1Y3QgPSBmdW5jdGlvbiAoTSkge1xuICByZXR1cm4gTWF0cml4Lm9mKE0pLmRpYWdwcm9kdWN0KClcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAbWVtYmVyIHN1bVxuICogQGluc3RhbmNlXG4gKiBAZGVzYyBSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiB0aGUgTWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBkaWFnMSA9IE1hdHJpeC5vbmVzKDMsIDMpLnN1bSgpXG4gKiAvLyA5XG4gKlxuICogY29uc3QgZGlhZzAgPSBNYXRyaXguemVyb3MoNSwgNSkuc3VtKClcbiAqIC8vIDBcbiAqXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZm9sZCgoYWNjLCB4KSA9PiB7XG4gICAgYWNjICs9IGZvbGQoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0KSgwKSh4KVxuICAgIHJldHVybiBhY2NcbiAgfSkoMCkodGhpcy5fX3ZhbHVlKVxufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBNYXRyaXhcbiAqIEBmdW5jdGlvbiBzdW1cbiAqIEBkZXNjIFJldHVybnMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIHRoZSBNYXRyaXhcbiAqIEBwYXJhbSBNIHtNYXRyaXh8QXJyYXl9IE1hdHJpeCBmcm9tIHdoaWNoIHRvIHJldHVybiB0aGUgZGlhZ29uYWxcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGRpYWcxID0gTWF0cml4LnN1bShbWzIsIDFdLCBbMSwgNV1dKVxuICogLy8gOVxuICpcbiAqL1xuTWF0cml4LnN1bSA9IGZ1bmN0aW9uIChNKSB7XG4gIHJldHVybiBNYXRyaXgub2YoTSkuc3VtKClcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAbWVtYmVyIGtyb25lY2tlclxuICogQGluc3RhbmNlXG4gKiBAZGVzYyBUaGUgS3JvbmVja2VyIHByb2R1Y3QgaXMgYW4gb3BlcmF0aW9uIG9uIHR3byBtYXRyaWNlcyBvZiBhcmJpdHJhcnkgc2l6ZSByZXN1bHRpbmcgaW4gYSBibG9jayBtYXRyaXguXG4gKiBAcGFyYW0gTSB7TWF0cml4fSBUaGUgcmlnaHQgc2lkZSBNYXRyaXggb2YgdGhlIHByb2R1Y3QgKHRoaXMg4oqXIE0pXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICovXG5NYXRyaXgucHJvdG90eXBlLmtyb25lY2tlciA9IGZ1bmN0aW9uIChNKSB7XG4gIGNvbnN0IG0gPSB0aGlzLmdldFJvd3MoKVxuICBjb25zdCBuID0gdGhpcy5nZXRDb2xzKClcbiAgY29uc3QgcCA9IE0uZ2V0Um93cygpXG4gIGNvbnN0IHEgPSBNLmdldENvbHMoKVxuXG4gIGNvbnN0IGxlZnQgPSB0aGlzLl9fdmFsdWVcbiAgY29uc3QgcmlnaHQgPSBNLl9fdmFsdWVcblxuICBjb25zdCBmcmFtZSA9IGdlbmVyYXRlKG0gKiBwLCBuICogcSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG07IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHA7IGsrKykge1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHE7IGwrKykge1xuICAgICAgICAgIGZyYW1lW3AgKiBpICsga11bcSAqIGogKyBsXSA9IGxlZnRbaV1bal0gKiByaWdodFtrXVtsXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdHJpeC5vZihmcmFtZSlcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgTWF0cml4XG4gKiBAZnVuY3Rpb24ga3JvbmVja2VyXG4gKiBAZGVzYyBUaGUgS3JvbmVja2VyIHByb2R1Y3QgaXMgYW4gb3BlcmF0aW9uIG9uIHR3byBtYXRyaWNlcyBvZiBhcmJpdHJhcnkgc2l6ZSByZXN1bHRpbmcgaW4gYSBibG9jayBtYXRyaXguXG4gKiBAcGFyYW0gQSB7TWF0cml4fSBUaGUgbGVmdCBzaWRlIE1hdHJpeCBvZiB0aGUgcHJvZHVjdCAoQSDiipcgQilcbiAqIEBwYXJhbSBCIHtNYXRyaXh9IFRoZSByaWdodCBzaWRlIE1hdHJpeCBvZiB0aGUgcHJvZHVjdCAoQSDiipcgQilcbiAqIEByZXR1cm5zIHtNYXRyaXh9XG4gKi9cbk1hdHJpeC5rcm9uZWNrZXIgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gTWF0cml4Lm9mKEEpLmtyb25lY2tlcihCKVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXRyaXhcbiIsImltcG9ydCBjdXJyeSBmcm9tICdmdW4uanMvc3JjL2N1cnJ5J1xuaW1wb3J0IGNvbmNhdCBmcm9tICdmdW4uanMvc3JjL2NvbmNhdCdcblxuLyoqXG4gKiBAZnVuY3Rpb24gY29uY2F0XG4gKiBAcGFyYW0gTSB7TWF0cml4fVxuICogQHBhcmFtIG0ge0FycmF5fVxuICogQHBhcmFtIGlkeCB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnQgZGVmYXVsdCBjdXJyeShmdW5jdGlvbiAoTSwgbSwgaWR4KSB7XG4gIHJldHVybiBjb25jYXQobSwgTS5fX3ZhbHVlW2lkeF0pXG59KVxuIiwiaW1wb3J0IGN1cnJ5IGZyb20gJ2Z1bi5qcy9zcmMvY3VycnknXG5pbXBvcnQgZm9sZCBmcm9tICdmdW4uanMvc3JjL2ZvbGQnXG5pbXBvcnQgbWFwIGZyb20gJ2Z1bi5qcy9zcmMvbWFwJ1xuaW1wb3J0IHJvdW5kIGZyb20gJy4vcm91bmQnXG5cbi8qKlxuICogQGZ1bmN0aW9uIGRvdFxuICogQHBhcmFtIEIge01hdHJpeH1cbiAqIEBwYXJhbSBhIHtBcnJheX1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY3VycnkoKGRlY2ltYWxzLCBCLCBhKSA9PiBtYXAoKGl0ZW0sIGkpID0+IHtcbiAgcmV0dXJuIGZvbGQoKGFjYywgeCwgaikgPT4ge1xuICAgIGFjYyArPSByb3VuZCh4ICogQi5fX3ZhbHVlW2pdW2ldLCBkZWNpbWFscylcbiAgICByZXR1cm4gYWNjXG4gIH0sIDApKGEpXG59KShCLl9fdmFsdWVbMF0pKVxuIiwiaW1wb3J0IGN1cnJ5IGZyb20gJ2Z1bi5qcy9zcmMvY3VycnknXG5cbmV4cG9ydCBkZWZhdWx0IGN1cnJ5KG0gPT4gW10pXG4iLCIvKipcbiAqIEBmdW5jdGlvbiBnZW5lcmF0ZVxuICogQGRlc2MgR2VuZXJhdG9yIGZ1bmN0aW9uIGZvciBhIG1hdHJpeCBhcnJheSwgdmFsdWVzIGFyZSBzZXQgdG8gdW5kZWZpbmVkXG4gKiBAcGFyYW0gcm93cyB7bnVtYmVyfVxuICogQHBhcmFtIGNvbHMge251bWJlcn1cbiAqIEByZXR1cm5zIHthbnlbXVtdfVxuICovXG5leHBvcnQgZGVmYXVsdCAocm93cywgY29scykgPT4gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkocm93cykpLm1hcCh4ID0+IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGNvbHMpKSlcbiIsIi8vIGltcG9ydCBjdXJyeSBmcm9tICdmdW4uanMvc3JjL2N1cnJ5J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncHVtYXAgKGdwdSwgZiwgbWF0cml4KSB7XG4gIHJldHVybiBncHUuY3JlYXRlS2VybmVsKGYpLnNldE91dHB1dChbbWF0cml4Lmxlbmd0aCwgbWF0cml4WzBdLmxlbmd0aF0pKG1hdHJpeClcbn1cbiIsImltcG9ydCBtYXAgZnJvbSAnZnVuLmpzL3NyYy9tYXAnXG5cbi8qKlxuICogQGZ1bmN0aW9uIGlkZW50aXR5XG4gKiBAZGVzYyBDcmVhdGVzIGFuIGlkZW50aXkgbWF0cml4IGZyb20gYW4gZW1wdHkgYXJyYXlcbiAqIEBwYXJhbSBtIHtBcnJheX1cbiAqIEBwYXJhbSBpZHgge251bWJlcn1cbiAqIEByZXR1cm4ge01hdHJpeH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgKG0sIGlkeCkgPT4gbWFwKChyb3dzLCBqZHgpID0+IChpZHggPT09IGpkeCkgKiAxKShtKVxuIiwiLyoqXG4gKiBAZnVuY3Rpb24gcm91bmRcbiAqIEBwYXJhbSB2YWx1ZSB7bnVtYmVyfVxuICogQHBhcmFtIGRlY2ltYWxzIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByb3VuZCAodmFsdWUsIGRlY2ltYWxzKSB7XG4gIHJldHVybiBOdW1iZXIoTWF0aC5yb3VuZCh2YWx1ZSArICdlJyArIGRlY2ltYWxzKSArICdlLScgKyBkZWNpbWFscylcbn1cbiIsImltcG9ydCBtYXAgZnJvbSAnZnVuLmpzL3NyYy9tYXAnXG5pbXBvcnQgY3VycnkgZnJvbSAnZnVuLmpzL3NyYy9jdXJyeSdcblxuLyoqXG4gKiBAZnVuY3Rpb24gdHJhbnNwb3NlXG4gKiBAZGVzYyBUcmFuc3Bvc2VzIGEgYXJyYXkgb2YgYXJyYXlzIHVzaW5nIHRoZSBNYXRyaXgubWFwIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbSB7QXJyYXl9XG4gKiBAcGFyYW0gaWR4IHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtNYXRyaXh9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGN1cnJ5KChwcmV2LCBuZXh0KSA9PiBtYXAoKGl0ZW0sIGkpID0+IChwcmV2W2ldIHx8IFtdKS5jb25jYXQobmV4dFtpXSkpKG5leHQpKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==